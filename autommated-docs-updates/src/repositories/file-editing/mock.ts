import { Result } from '../../types/result';
import { 
  FileEditingRepositoryService, 
  FileEditingRepositoryConfig, 
  FileUpdateResult, 
  FileEditingError 
} from './types';
import { CommitInfo, RepositoryType, GitRepositoryService } from '../git/types';

/**
 * Mock implementation of FileEditingRepositoryService for testing
 */
export class MockFileEditingRepositoryService implements FileEditingRepositoryService {
  private readonly docsRepositoryPath: string;
  private readonly foundationUiRepositoryPath: string;
  private readonly createBackups: boolean;
  private readonly backupDirectory: string;

  constructor(config: FileEditingRepositoryConfig) {
    this.docsRepositoryPath = config.docsRepositoryPath;
    this.foundationUiRepositoryPath = config.foundationUiRepositoryPath;
    this.createBackups = config.createBackups ?? true;
    this.backupDirectory = config.backupDirectory ?? '.backups';
  }

  /**
   * Mock implementation of updating a documentation file
   * @param filePath - The file path relative to docsRepoPath/docs
   * @param commitInfo - Information about the commit that triggered the update
   * @param updateInstructions - Instructions for what content to generate
   * @param gitRepositoryService - Git repository service to use for branch checking
   * @returns Promise<Result<FileUpdateResult, FileEditingError>> - Mock update result
   */
  async updateDocFile(
    filePath: string, 
    commitInfo: CommitInfo, 
    updateInstructions: string,
    gitRepositoryService: GitRepositoryService
  ): Promise<Result<FileUpdateResult, FileEditingError>> {
    // Simulate some processing time
    await new Promise(resolve => setTimeout(resolve, 200));

    console.log(`üìù [MOCK] Updating documentation file: ${filePath}`);
    console.log(`üîç [MOCK] Using commit info for: ${commitInfo.hash}`);
    console.log(`üìã [MOCK] Update instructions: ${updateInstructions.substring(0, 100)}...`);

    // Check current branch using the provided git service
    const branchResult = await gitRepositoryService.getCurrentBranch(RepositoryType.DOCS);
    if (Result.isError(branchResult)) {
      return Result.error({
        type: 'unknown',
        message: `Failed to get current branch: ${branchResult.message.message}`,
        filePath
      });
    }

    const currentBranch = branchResult.value;
    console.log(`üåø [MOCK] Current branch: ${currentBranch}`);

    // Simulate preprod branch check
    if (currentBranch === 'preprod') {
      console.log(`‚ö†Ô∏è [MOCK] Cannot edit files on preprod branch`);
      return Result.error({
        type: 'preprod_branch_active',
        message: 'Cannot edit documentation files while on preprod branch. Please switch to a feature branch.',
        filePath,
        currentBranch
      });
    }

    // Simulate file creation or update
    const originalContent = '';  // In mock, we simulate starting with empty content
    console.log(`üìÑ [MOCK] File operation: ${filePath} (creating/updating)`);

    // Simulate AI-generated content update
    const newContent = `# Mock Updated Documentation

This is mock updated content for: ${filePath}

**Update Instructions:** ${updateInstructions}

**Commit Information:**
- Hash: ${commitInfo.hash}
- Author: ${commitInfo.author}
- Message: ${commitInfo.message}
- Date: ${commitInfo.date.toISOString()}

**Generated:** ${new Date().toISOString()}

This content was generated by the mock file editing service for testing purposes.
`;

    console.log(`‚úÖ [MOCK] File updated successfully: ${filePath}`);
    
    // Calculate lines changed
    const linesChanged = this.calculateLinesChanged(originalContent, newContent);
    
    // Generate backup path if backups are enabled
    const backupPath = this.createBackups ? this.generateBackupPath(filePath) : undefined;

    const result: FileUpdateResult = {
      filePath,
      fullPath: `${this.docsRepositoryPath}/docs/${filePath}`,
      originalContent,
      newContent,
      backupPath,
      linesChanged,
      timestamp: new Date()
    };

    return Result.success(result);
  }

  /**
   * Checks if the file path is within the docs directory
   */
  private isFileInDocsDirectory(filePath: string): boolean {
    const normalizedPath = filePath.replace(/\\/g, '/');
    return !normalizedPath.startsWith('../') && !normalizedPath.includes('/../');
  }

  /**
   * Mock file existence check
   */
  private mockFileExists(filePath: string): boolean {
    // Mock that all .md and .mdx files exist
    return filePath.endsWith('.md') || filePath.endsWith('.mdx');
  }

  /**
   * Generates mock original content for a file
   */
  private generateMockOriginalContent(filePath: string): string {
    return `# Mock Documentation

This is mock original content for the file: ${filePath}

## Section 1
Some existing content here.

## Section 2
More existing content.

---
*Last updated: Mock Date*`;
  }

  /**
   * Generates mock new content based on commit info and instructions
   */
  private generateMockNewContent(
    originalContent: string, 
    commitInfo: CommitInfo, 
    updateInstructions: string
  ): string {
    const timestamp = new Date().toISOString();
    
    return `# Mock Documentation

This is mock updated content for the file based on commit: ${commitInfo.hash}

## Section 1
Some existing content here.

## Section 2
More existing content.

## New Section (AI Generated)
This section was generated based on the commit: "${commitInfo.message}"

The update instructions were: "${updateInstructions}"

### Changes Made
- Added new section based on commit analysis
- Updated content to reflect recent changes
- Maintained existing structure and formatting

---
*Last updated: ${timestamp}*`;
  }

  /**
   * Calculates the number of lines changed between original and new content
   */
  private calculateLinesChanged(originalContent: string, newContent: string): number {
    const originalLines = originalContent.split('\n').length;
    const newLines = newContent.split('\n').length;
    return Math.abs(newLines - originalLines);
  }

  /**
   * Generates a backup file path
   */
  private generateBackupPath(filePath: string): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const fileName = filePath.split('/').pop() || 'unknown';
    const backupFileName = `${fileName}.backup.${timestamp}`;
    return `${this.backupDirectory}/${backupFileName}`;
  }
} 