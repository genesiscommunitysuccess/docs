---
id: custom-components
title: Custom component set-up
sidebar_label: Custom component set-up
sidebar_position: 1

---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A custom component is a user-developed maven module that sits alongside the standard generated Genesis existing modules.

- trading_app-config
- trading_app-dictionary-cache
- trading_app-distribution
- trading_app-eventhandler
- trading_app-messages
- **trading_app-price-feed**  (eg of a custom component)
- trading_app-script-config

To create a new module, create the necessary [standard maven directory structure](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html) from the command line. Alternatively, you can use the module-creation features inIntellij;
select ```File -> New -> Module``` from Intellij's menu options.

![](/img/new-module.png)

The point of a custom component is to implement custom logic for your application. If you create a custom component, you must configure it in [Genesis System Definition](/creating-applications/configure-runtime/system-definitions/). For testing, follow the [standard Genesis practice](/managing-applications/test/integration-testing/).

## Genesis dependency injection framework

Genesis supports the key annotations from javax.annotation and javax.inject defined in [Java Platform Enterprise Edition](https://docs.oracle.com/javaee/7/index.html), The Genesis platform also provides its own annotations.

## @Module

All classes that need to be created by the Genesis startup must have this annotation. It also acts as a singleton.

## @ProviderOf

This is used to annotate a class that is responsible for acting as Factory for a specified type.

Example:-
```kotlin
@Singleton
@ProviderOf(type = PriceFeed::class)
class PriceFeedProvider : Provider<PriceFeedProvider> {
    override fun get(): PriceFeed {
        return new PriceFeed()
    }
}
```

## @Named

This annotation is used to differentiate between different objects of the same type.

## @Inject
This is used to annotate a set of parameters that indicate that Genesis must inject an object matching the type parameters of either the constructor, method or field definition. You can use either the [java](https://docs.oracle.com/javaee/6/api/javax/inject/Inject.html#:~:text=Injectable%20constructors%20are%20annotated%20with,most%20one%20constructor%20per%20class.&text=%40Inject%20is%20optional%20for%20public,injectors%20to%20invoke%20default%20constructors.)
 or google guice version of the file. 

## @PostConstruct

Genesis runtime environment calls this only once after initialization of the object, including all injected beans.

## @PreDestroy

Genesis runtime environment calls this only once, just before Genesis removes this from the application context.

## Example

This example includes **@Module**, **@Named** and **@Inject** annotation on a constructor, on a method and on a field.

```kotlin
@Module
class PriceFeed @Inject constructor(@Named("CONNECTION_URL") private val connectionUrl: String) {

    @Inject
    private val value: Value

    @Inject
    fun methodInject(value: Value) {
        // code would go here
    }

    @PostConstruct
    fun init() {
        // code would go here
    }

    @PreDestroy
    fun cleanUp() {
        // code would go here
    }
}
```


## Conditional annotations
### Conditional on property
You can define a module as conditional, based on system definition properties. For example, the AeronDriverModule will only be instantiated if the MqLayer property is set to AERON:

```kotlin
@Module
@ConditionalOnProperty("MqLayer", conditionalValue = "AERON")
```

### Conditional on class
Likewise, modules can be defined to be conditional on classes. So. if the selected class has been instantiated (e.g. the previous example shown as AeronDriverModule), then our dependency injection mechanism will instantiate this class as well:

```kotlin
@Module
@ConditionalOnClass(AeronDriverModule::class)
```

### Conditional on missing class
We can also add conditional modules on missing classes. This annotation is very helpful if you are developing an “extension” mechanism as part of a Genesis application. For example, you could define an interface; include an @Module implementing the interface with a conditional on that interface class being missing. This means that if a class is defined as a @Module which implements that interface, that class will be selected (i.e. this class can be defined in an external jar and added to classpath using framework config). If no class is defined as an @Module to implement that interface, then the @ConditionalOnMissingClass module will be instantiated.

For example, imagine we want to create a “hook” into the Genesis message-handling logic, so it can be extended as desired in different applicatins. The interface and default class would look like this in Kotlin:

```kotlin
interface MessageTracer{
    fun onMessageReceived(msg: Message)
}

@Module
@ConditionalOnMissingClass(MessageTracer::class)
class DefaultMessageTracer : MessageTracer{
    override fun onMessageReceived(msg: Message) = println("This is a message $msg")
}
```
If a product requires custom logic, a new @Module class could be defined in a separate jar file like this:

```kotlin
@Module
class ProductMessageTracer : MessageTracer{
    override fun onMessageReceived(msg: Message) = println("Hi $msg")
}
```
If the package for this class is available in the classpath (i.e.``` <classpath>``` section in processes.xml) and is also being scanned (i.e. ```<package>``` section in processes.xml), ProductMessageTracer will take precedence when starting the process and DefaultMessageTracer will be ignored. Otherwise, DefaultMessageTracer will be instantiated.

### Conditional on property and missing class
Lastly, we have a combination of both “conditional on property” and “conditional on missing class “annotations. Referring to the previous example, we could use both features at once like this:

```kotlin
@Module
@ConditionalOnPropertyAndMissingClass("MessageTracer", conditionalValue = "DEFAULT", MessageTracer::class)
class DefaultMessageTracer : MessageTracer{
    override fun onMessageReceived(msg: Message) = println("This is a message $msg")
}

```
The process will crash on startup if the system definition value for `MessageTracer` is set to anything other than DEFAULT and no implementation have been provided for MessageTracer . This annotation can be used to enforce good practices.

## Injectable properties from System Definition

#### Example of "genesis-system-definition.kts" file

```kotlin
systemDefinition {
    global {
        item(name = "CONFIG_FILE_NAME", value = "/data/")
        // other params omitted for simplicity
    }
}
```

#### System Definition property being referenced in java file
```java
@Inject
public RequestReplyDefinitionReader(RxDb db,
                                    @Named("CONFIG_FILE_NAME") String configFileName) throws GenesisConfigurationException {
    this(db.getDictionary(), configFileName);
}
```