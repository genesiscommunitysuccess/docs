---
title: 'Define the Data model using Fields, Tables and Views'
sidebar_label: 'Define the Data model using Fields, Tables and Views'
id: data-model
---

Hopefully, the previous step finished with:

```
i Application created successfully! ðŸŽ‰ Please open the application and follow the README to complete setup.
```

and now you are ready to define the fields and tables that make up the data model. 

Open IntelliJ (or your chosen IDE) and open the `positions-app-tutorial` project. After importing and indexing, you should see the files and project structure ready.

### Add fields
The fields are defined in the file **positions-app-tutorial-fields-dictionary.kts**

:::tip

Once the project is open, there are two easy ways to find this file quickly in Intellij:

- Press the **Shift** key twice, then type the name of the file you are looking for.
- Press **Shift** + **Ctrl** + **N**, then type the name of the file you are looking for.

:::

For this application, we will need fields that model a Trade, Position and Company and for that purpose we'll add the following:

```kotlin
fields {
    // Trade
    field(name = "ENTERED_BY", type = STRING)
    field(name = "PRICE", type = DOUBLE)
    field(name = "QUANTITY", type = LONG)
    field(name = "REFERENCE_PX", type = STRING)
    field(name = "REFERENCE_QTY", type = DOUBLE)
    field(name = "SIDE", type = STRING)
    field(name = "SYMBOL", type = LONG)
    field(name = "TRADE_DATE", type = DATE)
    field(name = "TRADE_DATETIME", type = DATETIME)
    field(name = "TRADE_ID", type = STRING)
    field(name = "TRADE_STATUS", type = ENUM("NEW", "ALLOCATED", "CANCELLED", default = "NEW"))

    // Position
    field(name = "POSITION_ID", type = STRING)
    field(name = "QUANTITY", type = LONG) // total number of shares
    field(name = "VALUE", type = DOUBLE) // position qty multiplied by avg trade price
    field(name = "NOTIONAL", type = DOUBLE) // instrument price multiplied by quantity
    field(name = "PNL", type = DOUBLE) // difference between notional and current market price

    // Company
    field(name = "COMPANY_NAME", type = STRING)
    field(name = "COMPANY_LOCATION", type = STRING)

    // Instrument
    field(name = "INSTRUMENT_ID", type = STRING)
    field(name = "INSTRUMENT_SYMBOL", type = STRING)
    field(name = "CURRENCY_ID", type = STRING)

    // Counterparty
    field(name = "COUNTERPARTY_NAME", type = STRING)
    field(name = "COUNTERPARTY_ID", type = STRING)
}
```

After you have saved this file, run `genesis-generated-fields`.

From the Gradle menu on the right of Intellij, this is:

**genesisproduct-positions-app-tutorial**/**positions-app-tutorial-dictionary-cache**/**genesis-generated-fields**/**Tasks**/**genesis**/**generateFields**

![](/img/build-gradle-kts-fields.png)

:::note Why do I have to run this Gradle task?

You are editing a kts file that needs to be compiled and built for use in other places. In this case, we want the fields to be available to the tables (and with intellisense support from the IDE).

As we go, you'll see we have different Gradle tasks, depending on the artifact we want to build.
:::

### Add tables
Now that we have our fields let's define the tables in the file **positions-app-tutorial-tables-dictionary.kts**.
We will define four tables `TRADE`, `POSITION`, `COUNTERPARTY` and `INSTRUMENT`:

```kotlin
tables {
    table (name = "TRADE", id = 11000) {
        sequence(TRADE_ID, "TR")
        INSTRUMENT_ID not null
        COUNTERPARTY_ID not null
        QUANTITY not null
        SIDE not null
        PRICE not null
        TRADE_DATETIME
        ENTERED_BY
        TRADE_STATUS

        primaryKey {
            TRADE_ID
        }
    }

    table(name= "POSITION", id = 11001) {
        sequence(POSITION_ID, "PS")
        INSTRUMENT_ID
        QUANTITY
        NOTIONAL

        primaryKey {
            POSITION_ID
        }

        indices {
            unique {
                INSTRUMENT_ID
            }
        }
    }

    table( name = "COUNTERPARTY", id = 11003) {
        COUNTERPARTY_ID
        COUNTERPARTY_NAME

        primaryKey {
            COUNTERPARTY_ID
        }
    }

    table (name = "INSTRUMENT", id = 11004) {
        INSTRUMENT_ID
        INSTRUMENT_SYMBOL
        CURRENCY_ID

        primaryKey {
            INSTRUMENT_ID
        }
    }
}
```

After you have saved this file, run `genesis-generated-dao`

From the Gradle menu, this is:

**genesisproduct-positions-app-tutorial**/**positions-app-tutorial-dictionary-cache**/**genesis-generated-dao**/**Tasks**/**genesis**/**generateDAO**

![](/img/build-gradle-kts-generated-dao.png)

After running it, you have the DAOs (i.e. data repos) automatically generated from the tables and available to be imported in your code.

:::tip
As we previously generated the fields, autocompletion helps you to define the tables more quickly, and with fewer errors. Also note that Genesis provides several autogenerated primary keys: **sequence**, **uuid**, **autoincrement**.
:::

### Add view

When you set up a data model, it implies relationships between tables. For example, a `TRADE` has a `COUNTERPARTY_ID` and an `INSTRUMENT_ID`. That means it has a relationship with the `COUNTERPARTY` and `INSTRUMENT` tables.

Views enable you join related tables to create a single holistic view.

In short, Views are the genesis equivalent of SQL select queries. Unlike tables, views do not have any data of their own, they are read-only, but present a view based on one or more tables. 

A view always starts with a single table, the root table. Other tables can be joined onto the root table to present composite data. 

Views are very powerful and here we are going to cover just the basics. When you have a chance, have a look at the [documentation](/database/fields-tables-views/views/).

The code below creates a view called `TRADE_VIEW`, which joins the `TRADE` table to the `INSTRUMENT` and `COUNTERPARTY` tables. Edit **positions-app-tutorialâ€“view-dictionary.kts** file and add the view on the `TRADE` tableâ€‹

```kotlin
views {

    view("TRADE_VIEW", TRADE) {

        joins {
            joining(COUNTERPARTY) {
                on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
            }
            joining(INSTRUMENT) {
                on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
            }
        }

        fields {
            TRADE.allFields()

            COUNTERPARTY.NAME withPrefix COUNTERPARTY
            INSTRUMENT.INSTRUMENT_SYMBOL withPrefix INSTRUMENT
            INSTRUMENT.CURRENCY_ID withAlias "CURRENCY"
        }
    }
}
```

Run **positions-app-tutorial-config:assemble** to make the view ready for use

#### Entities

During code generation, [view](/database/data-structures/views/) and [index entities](/database/data-structures/indices/) will be generated from the definitions in your application's **view-dictionary.kts** file. The name of each entity will be the same as the definition, but it is converted from snake case to camel case; for example, VIEW_NAME becomes ViewName.


### Conclusion
With this our data model is defined. As a next step we will add business logic to show the data and create entries