---
id: add-calculated-data
title: Add calculated data
sidebar_label: Add calculated data
sidebar_position: 5

---
At this point, we have a data model that serves both the reference database and the trading database, Our trading application has  a schema for the TRADE table, and it has event handlers, data servers and request servers.

Now we want to add calculations to add position-keeping. In brief you need to:

1. Create some new fields for the position-keeping information.
2. Create two new tables to contain the information.
3. Define the logic that calculates the positions in a new consolidator file.
4. Update the system files to incorporate the new consolidator.

## 1. Define the new fields

Before we create the new POSITION table, we need to create some new fields. Edit the fields file, which is **trading_app-fields-dictionary.kts**.

Add these 5 fields:

* POSITION_ID (this can be an autogenerated sequence, so declare it as such) : STRING
* INSTRUMENT_ID : STRING
* COUNTERPARTY_ID : STRING
* QUANTITY: LONG (total number of shares)
* NOTIONAL: DOUBLE (instrument price multiplied by quantity)

```kotlin
// Position
field(name = "POSITION_ID", type = STRING)
field(name = "INSTRUMENT_ID", type = STRING)
field(name = "COUNTERPARTY_ID", type = STRING)
field(name = "QUANTITY", type = LONG)
field(name = "NOTIONAL", type = DOUBLE)
```

The instrument price table needs at least two fields:

* INSTRUMENT_ID : STRING
* LAST_PRICE: DOUBLE

```kotlin
// Instrument
field(name = "INSTRUMENT_ID", type = STRING)
field(name = "LAST_PRICE", type = DOUBLE)
```

Once you have defined the fields, run the following tasks with maven:

```bash
cd trading_app-dictionary-cache
mvn codegen:generateSysDef
mvn codegen:generateFields
```

The important thing here is that these new fields have now been generated as code; they are now available in the IDE to help with intellisense, which makes the remaining coding quicker, easier and less error-prone.

## 2. Define the POSITION and INSTRUMENT tables

Open the file **trading_app-tables-dictionary.kts** and define the POSITION table.

The primary key (**primaryKey**) for the POSITION table is POSITION_ID.

The table has two unique indices: INSTRUMENT_ID and COUNTERPARTY_ID. There is one non-unique index: COUNTERPARTY_ID.
```kotlin
table(name = "POSITION", id = 11001) {
  sequence(POSITION_ID, "PS") //autogenerated sequence
  INSTRUMENT_ID
  COUNTERPARTY_ID
  QUANTITY
  NOTIONAL
  primaryKey {
    POSITION_ID
  }
  indices {
    unique {
      INSTRUMENT_ID
      COUNTERPARTY_ID
    }
    nonUnique {
      COUNTERPARTY_ID
    }
  }
}
```

Now define the INSTRUMENT_PRICE table.

The primary key (**primaryKey**) for the INSTRUMENT_PRICE, table is INSTRUMENT_ID
```kotlin
table(name = "INSTRUMENT_PRICE", id = 11002) {
  INSTRUMENT_ID
  LAST_PRICE
  primaryKey {
    INSTRUMENT_ID
  }
}
```
Because we previously generated the fields, autocompletion helps you to define more completely. Also note that Genesis provides several autogenerated primary keys: -**sequence**, **uuid**, **autoincrement**.

## 3. Define the position-keeping logic in the consolidator

Define a **trading_app-consolidator2.xml** file inside **trading_app-config/src/main/resources/cfg**. This is where you define the consolidator logic.

The consolidator is going to increase or decrease the quantity for POSITION records, based on the TRADE table updates. It also needs to calculate the new notional.
```xml
<consolidations>
    <consolidation name="CONSOLIDATE_POSITIONS" start="true">
        <tables>
            <table name="TRADE" alias="t" seedKey="TRADE_BY_ID" consolidationFields="QUANTITY PRICE"/>
            <table name="INSTRUMENT_PRICE" alias="ip" >
                <join key="INSTRUMENT_PRICE_BY_INSTRUMENT_ID">
                    <![CDATA[
                    ip.setString("INSTRUMENT_ID", t.getString("INSTRUMENT_ID"))
                    ]]>
                </join>
            </table>
        </tables>
        <groupBy>
            <![CDATA[
                group(t.getString("INSTRUMENT_ID"), t.getString("COUNTERPARTY_ID"))
            ]]>
        </groupBy>
        <consolidateTable name="POSITION" alias="p" consolidationFields="QUANTITY NOTIONAL"
                          transient="true">
            <consolidationTarget key="POSITION_BY_INSTRUMENT_ID_COUNTERPARTY_ID">
                <![CDATA[
                p.setString("COUNTERPARTY_ID", t?.getString("COUNTERPARTY_ID"))
                p.setString("INSTRUMENT_ID", t?.getString("INSTRUMENT_ID"))
                ]]>
            </consolidationTarget>
            <calculation>
                <![CDATA[
                    long quantity = t.getLong("QUANTITY")
                    long previousQuantity = previous_t.getLong("QUANTITY")
                    long quantityDelta = quantity - previousQuantity
                    String tradeStatus = t.getString("TRADE_STATUS")
                    long newQuantity = p.getLong("QUANTITY")
                    switch(tradeStatus) {
                      case "NEW":
                      case "ALLOCATED":
                        String side = t.getString("SIDE")
                        switch(side) {
                          case "BUY":
                            newQuantity += quantityDelta
                            break
                          case "SELL":
                            newQuantity -=quantityDelta
                            break
                          }
                        break
                      case "CANCELLED":
                        String previousSide = previous_t.getString("SIDE")
                        switch(previousSide) {
                          case "BUY":
                            newQuantity -= quantityDelta
                            break
                          case "SELL":
                            newQuantity +=quantityDelta
                            break
                          }
                        break
                    }
                    p.setLong("QUANTITY", newQuantity)
                    Double lastPrice = ip?.getDouble("LAST_PRICE")
                    if (lastPrice != null) {
                        p.setDouble("NOTIONAL", newQuantity * lastPrice )
                    }
                ]]>
            </calculation>
        </consolidateTable>
    </consolidation>
</consolidations>
```
## 4. Update the system files

### Update the processes.xml file

Add a new entry to **trading_app-processes.xml** with the consolidator2 process definition.
```xml
<process name="TRADING_APP_CONSOLIDATOR">
  <groupId>TRADING_APP</groupId>
  <start>true</start>
  <options>-Xmx256m -DRedirectStreamToLog=true</options>
  <module>consolidator2</module>
  <package>global.genesis.consolidator2</package>
  <config>trading_app-consolidator2.xml</config>
  <loggingLevel>INFO,DATADUMP_OFF</loggingLevel>
</process>
```
### Update the service-definitions.xml file

This file lists all the active services for the application. You can see entries have been added automatically when the data server, request server and event handler were generated (by AppGen).

Add a new entry to **trading_app-service-definitions.xml** with the consolidator2 details.

![](/img/add-to-service-defininitions.png)

## Testing

We shall add testing information here shortly.