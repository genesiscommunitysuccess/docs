---
id: extend-trade-view
title: Extending a view
sidebar_label: Extending a view
sidebar_position: 3

---

## Extend the new view

After the first two exercises, we now have the beginnings of our Positions app. This already has a view, which was generated when you ran `AppGen`. 

Now we are going to create some joins that make this view more useful to our users.

In our two joins, we are going to start with the `TRADE` table, and we'll connect it to the `INSTRUMENT` and `COUNTERPARTY` tables. So, when our users look at a trade, they can see what instrument has been traded and who it was traded with.

We'll take this in stages. First, we'll add a `joins` section within the `TRADE_VIEW` block. The code below creates a section that specifies two joins:

```kotlin
  view ("TRADE_VIEW", TRADE) {
    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }
```

Let's take a closer look at that code. We had an existing view called `TRADE VIEW`, It simply showed the `TRADE` table, and the view had the name `TRADE_VIEW`. The first joining statement joins this `TRADE` table to the `COUNTERPARTY_ID` table. The second statement joins the `TRADE` table to the `INSTRUMENT_ID` table.

Now we are going to add some information about the fields after the two `joining` statements.

<!-- TODO check output of AppGen has fields like this, else a line that we add it in as there are joined trades now -->
```kotlin
  view ("TRADE_VIEW", TRADE) {
    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }
    fields {
      TRADE.allFields()
      COUNTERPARTY.NAME withPrefix COUNTERPARTY
      INSTRUMENT.NAME withPrefix INSTRUMENT
      
    }
  }
```
The `fields` statement in the code above tells us that the view contains all the fields from the `TRADE` table, plus `INSTRUMENT_NAME` and `COUNTERPARTY_NAME` from the other tables.

Now look at another example, where we are going to add more complexity.

- Instead of taking all fields from the `TRADE` table, we have identified five specific fields.
- We have created a derived field called `CONSIDERATION`, which contains the overall value (QUANTITY * PRICE) of the trade. Derived fields are a useful way of providing calculated data, but note that you must only use fields that are in the view.

So, use the code below as your final definition of the two joins.

```kotlin
  view ("TRADE_VIEW", TRADE) {
    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }
    fields {
      TRADE.PRICE
      TRADE.QUANTITY
      TRADE.TRADE_DATETIME
      TRADE.SIDE
      TRADE.TRADE_ID
      COUNTERPARTY.NAME withPrefix COUNTERPARTY
      INSTRUMENT.NAME withPrefix INSTRUMENT
      derivedField("CONSIDERATION", DOUBLE) {
        // I: F2*H2
        withInput(TRADE.QUANTITY, TRADE.PRICE) { QUANTITY, PRICE ->
          if(QUANTITY == null) return@withInput null
          if(PRICE == null) return@withInput null
          QUANTITY * PRICE
        }
      }
    }
  }
```

Let's add a new view for the Consolidator to use.

```kotlin
  view("TRADE_PRICE_VIEW", TRADE) {
    joins {
      joining(INSTRUMENT_L1_PRICE, backwardsJoin = true) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT_L1_PRICE { INSTRUMENT_CODE })
      }
    }
    fields {
      TRADE.allFields()

      INSTRUMENT_L1_PRICE.EMS_BID_PRICE
      INSTRUMENT_L1_PRICE.EMS_ASK_PRICE
    }
  }
```
Run `codegen:generateView` to make the new view ready for use (See below).
![](/img/generateView.png)

## Add the new view to the data server

Now go to the Data Server definition (inside the **-script-config** module). Replace the `ALL_TRADES` query in the Data Server with the new `TRADE_VIEW`.

```kotlin
dataServer {
  query("ALL_TRADES", TRADE_VIEW)
}
```
## Testing
Let's now create a unit test showing usage of the view repository generated by the code-generation mechanism.
The purpose of the test is to prove you can look up data with the repo and retrieve the joined-up structure. We can show that we can:
* look up by keys
* perform get bulk from the main table
First, you need to do the following:
1. Add a new test class to the *alpha-script-config* module called `EnhancedTradeViewTest.kt`
2. Add an empty txt file to the genesis home folder. This folder is needed for unit tests. 
3. Add TEST_DATA.csv to a data folder
```csv
#INSTRUMENT
INSTRUMENT_ID,NAME
1,FOO.L
2,BAR.L
#COUNTERPARTY
COUNTERPARTY_ID,COUNTERPARTY_LEI,NAME,
1,335800A8HK6JBITVPA30,Test Ltd,
2,655FG0324Q4LUVJJMS11,Testing AG,
```
Should look like below:
### Test class setup
```kotlin
package global.genesis
import global.genesis.db.util.AbstractDatabaseTest
import global.genesis.db.util.TestUtil
import global.genesis.dictionary.GenesisDictionary
import global.genesis.gen.dao.Trade
import global.genesis.gen.view.entity.TradeView
import global.genesis.gen.view.repository.TradeViewAsyncRepository
import kotlinx.coroutines.flow.count
import kotlinx.coroutines.flow.toList
import org.joda.time.DateTime
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import javax.inject.Inject
class EnhancedTradeViewTest : AbstractDatabaseTest() {
    @Inject
    lateinit var enhancedTradeViewRepository: TradeViewAsyncRepository
    override fun createMockDictionary(): GenesisDictionary = prodDictionary()
    @Before
    fun setup() {
        TestUtil.loadData(resolvePath("data/TEST_DATA.csv"), rxDb)
    }
    private fun buildTrade(tradeId: String, now: DateTime = DateTime.now()) =
        Trade.builder()
            .setTradeDate(now)
            .setCounterpartyId("2") // COUNTERPARTY_NAME = "Testing AG"
            .setInstrumentId("1")   // INSTRUMENT_NAME = "FOO.L"
            .setPrice(12.0)
            .setQuantity(100)
            .setSide("BUY")
            .setTradeId(tradeId)
            .build()
}
```
### Test get single trade by ID
```kotlin
@Test
fun `test get single trade by id`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)
    rxEntityDb.insert(trade).blockingGet()
    val tradeView = enhancedTradeViewRepository.get(EnhancedTradeView.ById(1)).blockingGet()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```
### Test get single trade with getBulk
```kotlin
@Test
fun `test with single trade - use getBulk`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)
    rxEntityDb.insert(trade).blockingGet()
    val tradeViewList = enhancedTradeViewRepository.getBulk()
        .toList()
        .blockingGet()
    assertEquals(1, tradeViewList.size)
    val tradeView = tradeViewList.first()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```
### Test get multiple trades
```kotlin
@Test
fun `test get multiple trades`() {
    rxEntityDb.insertAll(
        buildTrade(1),
        buildTrade(2),
        buildTrade(3),
        buildTrade(4),
        buildTrade(5),
    ).blockingGet()
    val count = enhancedTradeViewRepository.getBulk().count().blockingGet()
    assertEquals(5, count)
}
```
