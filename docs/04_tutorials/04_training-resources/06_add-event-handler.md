---
id: add-event-handler
title: Add logic to the event handler
sidebar_label: Add logic to the event handler
sidebar_position: 6

---


It's time to look at your event handlers. At this stage, you have Positions app with:

* a Reference Data module. This has tables, so you can import the schema to the Positions application
* a Market Data module. This contains the schema for the TRADE table, event handlers, data servers and request servers

Now we are going to change the code in the event handler so that it checks that:

* the counterparty exists in the database (by checking COUNTERPARTY_ID field)
* the instrument exists in the database (by checking INSTRUMENT_ID field)

### 1. Mark the fields as mandatory

In your IDE, go to the TRADE table. Mark the INSTRUMENT_ID and COUNTERPARTY_ID as mandatory.

![](/img/event-s1.png)

### 2. Generate the dao classes

Run maven clean package to generate the dao classes that will be used in the event handler GPAL files.

![](/img/event-s2.png)

### 3. Add the validation code

Go to the **eventhandler.kts** file for the event handler (this was autogenerated by **AppGen**). The file has separate eventHandler blocks to handle insert, modify and delete. The first block is TRADE_INSERT.

Add the verification by inserting an **onVerify** block before the **onCommit** block in TRADE_INSERT. We can see this below, with separate lines checking the Counterparty ID and the Instrument ID exist in the database. The new block ends by sending an **ack()**.

![](/img/event-s3.png)

You can make the same insertion to the TRADE_MODIFY and TRADE_DELETE blocks.

## Testing the event handlers

Now we shall create and run some unit testing for our new event handlers.

### Create test data

You need a set of counterparties and instruments to test the event handlers. This can be a CSV file, as shown in this example.

in the same format as the one found in this folder (see EventHandler Script - TestData file example from different project).

The test data should ideally match the test data in the Trades excel file example (this means matching instrument_id and counterparty_id values in the example INSTRUMENT and COUNTERPARTY records). This makes it easy to correlate the test data.

### Dependencies

Add **ref_app_data-config** as a dependency with provided scope in the parent pom.

Add the same file as a dependency with test scope in the file **script-config module pom**.

### Create unit tests

Create unit tests inside **-script-config** folder. The  maven archetype should have generated a sample file already, so we can reuse it.
```kotlin
package global.genesis

import global.genesis.commons.model.GenesisSet
import global.genesis.testsupport.AbstractGenesisTestSupport
import global.genesis.testsupport.GenesisTestConfig

class TradingEventHandlerTest : AbstractGenesisTestSupport<GenesisSet>(
    GenesisTestConfig {
        addPackageName("global.genesis.eventhandler.pal")
        genesisHome = "/GenesisHome/"
        scriptFileName = "trading_app-eventhandler.kts"
        parser = { it }
        initialDataFile = "TEST_DATA.csv"
    }
) {
    override fun systemDefinition(): Map<String, Any> = mapOf("IS_SCRIPT" to "true")
}
```

Here are three example tests  for the EVENT_TRADE_INSERT.

The first test checks that if all the details are correct, the validation passes the event.
```kotlin
@Test
fun `test insert trade`(): Unit = runBlocking {
    val message = Event(
        details = Trade {
            tradeId = 1
            counterpartyId = "1"
            instrumentId = "2"
        },
        messageType = "EVENT_TRADE_INSERT"
    )
    val result: EventReply? = messageClient.suspendRequest(message)
    result.assertedCast<EventReply.EventAck>()
    val trade = entityDb.get(Trade.ById(1))
    assertNotNull(trade)
    assertEquals("1", trade.counterpartyId)
    assertEquals("2", trade.instrumentId)
}
```

The second test checks that a missing instrument fails validation.
```kotlin
@Test
fun `test invalid instrument`(): Unit = runBlocking {
    val message = Event(
        details = Trade {
            tradeId = 1
            counterpartyId = "1"
            instrumentId = "DOESNOTEXIST"
        },
        messageType = "EVENT_TRADE_INSERT"
    )
    val result: EventReply? = messageClient.suspendRequest(message)
    val eventNack: EventReply.EventNack = result.assertedCast()
    assertThat(eventNack.error).containsExactly(
        StandardError(
            "INTERNAL_ERROR",
            "INSTRUMENT ById(instrumentId=DOESNOTEXIST) not found in database"
        )
    )
}
```

The third test check that a missing counterparty fails validation.
```kotlin
@Test
fun `test invalid counterparty and instrument`(): Unit = runBlocking {
    val message = Event(
        details = Trade {
            tradeId = 1
            counterpartyId = "DOESNOTEXIST"
            instrumentId = "DOESNOTEXIST"
        },
        messageType = "EVENT_TRADE_INSERT"
    )
    val result: EventReply? = messageClient.suspendRequest(message)
    result.assertedCast<EventReply.EventNack>()
}
```

### Run the unit tests

To follow.