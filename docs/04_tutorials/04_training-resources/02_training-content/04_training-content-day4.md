---
id: training-content-day4
title: Day 4
sidebar_label: Day 4
sidebar_position: 4

---
In this day we are covering:

- [Adding logic to the event handler](#adding-logic-to-the-event-handler)
- [State management​](#state-management​)
- [Auditing​](#auditing​)
- [Schedulers​](#schedulers​)

## Adding logic to the event handler

It's time to look at your event handlers. At this stage, you have Positions app with:

* a Reference Data module. This has tables, so you can import the schema to the application
* a Market Data module. This contains the schema for the TRADE table, event handlers, data servers and request servers

Now we are going to change the code in the event handler so that it checks that:

* the counterparty exists in the database (by checking COUNTERPARTY_ID field)
* the instrument exists in the database (by checking INSTRUMENT_ID field)

### Add the validation code

Go to the **eventhandler.kts** file for the event handler (this was autogenerated by **AppGen**). The file has separate eventHandler blocks to handle insert, modify and delete. The first block is TRADE_INSERT.

Add the verification by inserting an **onVerify** block before the **onCommit** block in TRADE_INSERT. We can see this below, with separate lines checking the Counterparty ID and the Instrument ID exist in the database. The new block ends by sending an **ack()**.

```
eventHandler<Trade>(name = "TRADE_INSERT") {
    onValidate { event ->
        val message = event.details
        verify {
            entityDb hasEntry Counterparty.ById(message.counterpartyId.toString())
            entityDb hasEntry Instrument.byId(message.instrumentId.toString())
        }
        ack()
    }
    onCommit { event ->
        val trade = event.details
        entityDb.insert(trade)
        ack()
    }
}
```

You can make the same insertion to the TRADE_MODIFY and TRADE_DELETE blocks.

To test it, you can try to insert a TRADE with a mock COUNTERPARTY or INSTRUMENT and see the validation. 

## State management​

Now we are going to configure state machine to control the workflow of trades.

At this stage, your app has:

* a Reference Data module. This has tables, so you can import the schema to the  application
* a Market Data module. This contains the schema for the TRADE table, plus event handlers, data servers and request servers

Also, you have enhanced the EVENT_TRADE_INSERT event handler so that it performs validation checks.

### The objective

State machines enable you to control workflow by defining the transitions from state to state. This example enables you to build a very simple state machine so that you can add new trades. You will create a new field called TRADE_STATUS, which can have three possible states: NEW, ALLOCATED, CANCELLED.

* NEW can go to ALLOCATED or CANCELLED.
* ALLOCATED and CANCELLED can’t go anywhere else.
* NEW is the only state you can use to insert new records.

![](/img/diagram-of-states.png)

Note that event handlers have already been generated by the `AppGen` process you ran earlier. Once you have added add a new field to the data model, you will edit the event handler file to add controlled transitions from one state to another.

#### 1. Add the new field to the data model

Add the TRADE_STATUS field to the **alpha-fields-dictionary.kts** file.

```kotlin {16}
fields {
  field(name = "COUNTERPARTY", type = STRING)
  field(name = "COUNTERPARTY_LEI", type = STRING)
  field(name = "COUNTERPARTY_NAME", type = STRING)
  field(name = "ENTERED_BY", type = STRING)
  field(name = "FIELD_3", type = LONG)
  field(name = "INSTRUMENT_SYMBOL", type = STRING)
  field(name = "PRICE", type = DOUBLE)
  field(name = "QUANTITY", type = LONG)
  field(name = "REFERENCE_PX", type = STRING)
  field(name = "REFERENCE_QTY", type = DOUBLE)
  field(name = "SIDE", type = STRING)
  field(name = "SYMBOL", type = LONG)
  field(name = "TRADE_DATETIME", type = DATETIME)
  field(name = "TRADE_ID", type = LONG)
  field(name = "TRADE_STATUS", type = ENUM("NEW", "ALLOCATED", "CANCELLED", default = "NEW"))
}
```

Add the TRADE_STATUS field to the TRADE table in the **alpha-tables-dictionary.kts** file.

```kotlin {12}
tables {
  table (name = "TRADE", id = 11000) {
    // Source: Trade
    TRADE_ID            // A
    INSTRUMENT_ID not null       // B
    COUNTERPARTY_ID not null     // C
    QUANTITY            // F
    SIDE                // G
    PRICE               // H
    TRADE_DATETIME      // K
    ENTERED_BY          // L
    TRADE_STATUS

    primaryKey {
      TRADE_ID
    }

  }
}
```

Run *genesis-generated-fields* to generate the fields, AND​ *genesis-generated-dao​* to create the DAOs.

#### 2. Create a new class for the state machine

Add a main folder in the event handler module *alpha-eventhandler* and create a state machine class called *TradeStateMachine*.

Add a state machine definition and assign a field in the **onCommit** block,

```kotlin
package global.genesis

import com.google.inject.Inject
import global.genesis.commons.annotation.Module
import global.genesis.db.rx.entity.multi.AsyncEntityDb
import global.genesis.db.rx.entity.multi.AsyncMultiEntityReadWriteGenericSupport
import global.genesis.db.statemachine.StateMachine
import global.genesis.db.statemachine.Transition
import global.genesis.gen.dao.Trade
import global.genesis.gen.dao.enums.TradeStatus

@Module
class TradeStateMachine @Inject constructor(
    db: AsyncEntityDb
) {
    private val internalState: StateMachine<Trade, TradeStatus, TradeEffect> = db.stateMachineBuilder {
        readState { tradeStatus }

        state(TradeStatus.NEW) {
            isMutable = true

            initialState(TradeEffect.New) {
                onValidate { trade ->
                    if (trade.isTradeIdInitialised && trade.tradeId.isNotEmpty()) {
                        verify {
                            db hasNoEntry Trade.ById(trade.tradeId)
                        }
                    }
                }
            }

            onCommit { trade ->
                if (trade.enteredBy == "TestUser") {
                    trade.price = 10.0
                }
            }

            transition(TradeStatus.ALLOCATED, TradeEffect.Allocated)
            transition(TradeStatus.CANCELLED, TradeEffect.Cancelled)
        }

        state(TradeStatus.ALLOCATED) {
            isMutable = false

            transition(TradeStatus.NEW, TradeEffect.New)
            transition(TradeStatus.CANCELLED, TradeEffect.Cancelled)
        }

        state(TradeStatus.CANCELLED) {
            isMutable = false
        }
    }

    suspend fun insert(trade: Trade): Transition<Trade, TradeStatus, TradeEffect> = internalState.create(trade)

    suspend fun insert(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        trade: Trade,
    ): Transition<Trade, TradeStatus, TradeEffect> =
        internalState.withTransaction(transaction) {
            create(trade)
        }

    suspend fun modify(tradeId: String, modify: suspend (Trade) -> Unit): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.update(Trade.ById(tradeId)) { trade, _ -> modify(trade) }

    suspend fun modify(trade: Trade): Transition<Trade, TradeStatus, TradeEffect>? = internalState.update(trade)

    suspend fun modify(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        tradeId: String, modify: suspend (Trade) -> Unit
    ): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.withTransaction(transaction) {
            update(Trade.ById(tradeId)) {
                    trade, _ -> modify(trade)
            }
        }

    suspend fun modify(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        trade: Trade
    ): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.withTransaction(transaction) {
            update(trade)
        }
}

sealed class TradeEffect {
    object New : TradeEffect()
    object Allocated : TradeEffect()
    object Cancelled : TradeEffect()
}
```

#### 3. Add the module as a dependency in the *build.gradle.kts* inside **alpha-script-config** module. 

```
...
api(project(":alpha-eventhandler"))
api("global.genesis:genesis-pal-eventhandler")
...
```

#### 4. Edit the event handler to add an integrated state machine

Integrate the state machine in the TRADE_INSERT event.

```kotlin {2,15}
eventHandler<Trade>(name = "TRADE_INSERT") {
    onValidate { event ->
        val message = event.details
        verify {
            entityDb hasEntry Counterparty.ById(message.counterpartyId.toString())
            entityDb hasEntry Instrument.byId(message.instrumentId.toString())
        }
        ack()
    }
    onCommit { event ->
        val trade = event.details
        trade.enteredBy = event.userName
        stateMachine.insert(entityDb, trade)
        ack()
    }
}
```

Create two data classes that will be used in the cancel and allocated event handlers:

* TradeCancelled
* TradeAllocated

Both classes have a single single field: **tradeId**.

TradeAllocated:

```kotlin
package global.genesis.alpha.message.event

data class TradeAllocated(val tradeId: String)
```

TradeCancelled:

```kotlin
package global.genesis.alpha.message.event

data class TradeCancel(val tradeId: String)
```

Create a new event handler called TRADE_CANCELLED to handle cancellations. Then integrate the state machine in it.

```kotlin
eventHandler<TradeCancel>(transactional = true) {
    onCommit { event ->
        val message = event.details
        stateMachine.modify(entityDb, message.tradeId) { trade ->
            trade.tradeStatus = TradeStatus.CANCELLED
        }
        ack()
    }
}
```

Create a new event handler called TRADE_ALLOCATED to handle completion. Integrate the state machine in it.

```kotlin
eventHandler<TradeAllocated>(transactional = true) {
    onCommit { event ->
        val message = event.details
        stateMachine.modify(entityDb, message.tradeId) { trade ->
            trade.tradeStatus = TradeStatus.ALLOCATED
        }
        ack()
    }
}
```

Modify the TRADE_MODIFY event handler to use the state machine.

```kotlin {5}
eventHandler<Trade>(name = "TRADE_MODIFY", transactional = true) {
    onCommit { event ->
        val trade = event.details
        stateMachine.modify(entityDb, trade)
        ack()
    }
}
```

Remove the TRADE_DELETE event handler.

You want to manage the state of the trade, so remove the delete event handler. If a trade is incorrect and needs to be deleted, similar functionality can be achieved by cancelling the trade.

To test it, you can try to modify a TRADE and see the states changing accordingly. 

## Auditing​

Now we are going to add basic auditing to the TRADE table in order to keep a record of the changing states of the trades.

At this stage, your app has:

* a Reference Data module. This has tables, so you can import the schema to the Positions application
* a Market Data module. This contains the schema for the TRADE table, plus handlers, a state machine, data servers and request servers.

### The objective

We want to be able to track the changes made to the various trades on the TRADE table, such that we could see the times and modifications made in the history of the trade.

This can be useful for historical purposes, if you need to at a later date be able to produce an accurate course of events.

### Adding Basic Auditing

#### Adding audit to table dictionary

The first step to add basic auditing is to change the relevant table dictionary. In this instance we will be making changes to the **alpha-tables-dictionary.kts**, in order to add the parameter `audit = details()` to the table definition. It should resemble the following:

```kotlin {2}
table (name = "TRADE", id = 2000, audit = details(id = 2100, sequence = "TR")) {
    sequence(TRADE_ID, "TR")
    COUNTERPARTY_ID
    INSTRUMENT_ID
    QUANTITY
    PRICE
    SYMBOL
    DIRECTION
    SIDE
    TRADE_DATE
    ENTERED_BY
    TRADE_STATUS

    primaryKey {
        TRADE_ID
    }
}
```

The id parameter indicates the id of the newly created audit table, and will need to be different from any other table id.

If you are using the GPAL event handlers, this is sufficient to enable auditing on this table. A new table is created by the name of the original table, with the **_AUDIT** suffix added to the end. In this instance that would be the **TRADE_AUDIT** table.

#### Updating the state machine to use auditing

Next you need to change the insert, and modify methods in the **TradeStateMachine.kts** file. Specifically, each method must be edited so that the method signature uses the **AsyncMultiEntityReadWriteGenericSupport** parameter and the `internalState.withTransaction(transaction) { }` code block.  For example:

```kotlin {2,5,10,12,20,23}
    suspend fun insert(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        trade: Trade,
    ): Transition<Trade, TradeStatus, TradeEffect> =
        internalState.withTransaction(transaction) {
            create(trade)
        }

    suspend fun modify(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        tradeId: Long, modify: suspend (Trade) -> Unit
    ): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.withTransaction(transaction) {
            update(Trade.ById(tradeId)) {
                trade, _ -> modify(trade)
            }
        }

    suspend fun modify(
        transaction: AsyncMultiEntityReadWriteGenericSupport,
        trade: Trade
    ): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.withTransaction(transaction) {
            update(trade)
        }
```

#### Update the event handlers to use auditing

Now you must update the **alpha-eventhandler.kts** in order to pass the `entityDb` object into the updated methods of the state machine, as the **syncMultiEntityReadWriteGenericSupport** parameter. This should resemble the example below:

```kotlin {12,19,26,35}
    eventHandler<Trade>(name = "TRADE_INSERT") {
        onValidate { event ->
            val message = event.details
            verify {
                entityDb hasEntry Counterparty.ById(message.counterpartyId)
                entityDb hasEntry Instrument.ById(message.instrumentId)
            }
            ack()
        }
        onCommit { event ->
            val trade = event.details
            stateMachine.insert(entityDb, trade)
            ack()
        }
    }
    eventHandler<Trade>(name = "TRADE_MODIFY") {
        onCommit { event ->
            val trade = event.details
            stateMachine.modify(entityDb, trade)
            ack()
        }
    }
    eventHandler<TradeCancel>(name = "TRADE_CANCELLED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(entityDb, message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.CANCELLED
            }
            ack()
        }
    }
    eventHandler<TradeAllocated>(name = "TRADE_ALLOCATED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(entityDb, message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.ALLOCATED
            }
            ack()
        }
    }
```

To test it, you can try to insert or modify a TRADE and see the auditing happening accordingly.

## Schedulers​

### Cron jobs (static events)​

In this exercise you are going to create a cron rule that will trigger a batch job that will run once each day.

The batch job will generate a position report as a csv for each counterparty. This wil be stored in **runtime/position-daily-report**. The file name of each report written will have the form COUNTERPARTY_ID-DATE.csv.

#### The rule

Our cron rule takes the following form:

| CRON_EXPRESSION | DESCRIPTION | TIME_ZONE | RULE_STATUS | NAME | USER_NAME | PROCESS_NAME | MESSAGE_TYPE | RESULT_EXPRESSION |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 45 7 ? * MON,TUE,WED,THU,FRI * | It’s a rule | Europe/London | ENABLED | A rule | JohnDoe | ALPHA_EVENTHANDLER | EVENT_POSITION_REPORT |  |

Let's look at the most important fields:

* **RULE_STATUS** can be **ENABLED** or **DISABLED**.
* **CRON_EXPRESSION** determines when the rule is evaluated.
* **PROCESS_NAME** is the target process for the rule. When the rule is triggered, it will send a message to the process specified here.
* **MESSAGE_TYPE** is the message that needs to be sent to the specified **PROCESS_NAME**.
* **RESULT_EXPRESSION** is the values that will be sent as part of the transaction to the target PROCESS_NAME, we can leave RESULT_EXPRESSION empty as we are going to generate a report for all positions anyway.



#### 1. Configure the Evaluator

The Genesis Evaluator is the process that runs cron jobs. 
To start, make a copy of **genesis-processes.xml** and place it in **site-specific/cfg**.

In the genesis-processes.xml file,  change the
tag for **GENESIS_EVALUTATOR** and set the  `<start>` tag to true

```xml
<process name="GENESIS_EVALUATOR">
<start>true</start>
<groupId>GENESIS</groupId>
<options>-Xmx512m -DXSD_VALIDATE=false</options>
<module>genesis-evaluator</module>
<primaryOnly>true</primaryOnly>
<package>global.genesis.eventhandler,global.genesis_evaluator</package>
<description>Dynamic/time rules engine</description>
</process_>
```

Run **genesisInstall** to verify that the new process works as expected.

Run **mon**.
You can see that the process is missing.
So, run **startProcess GENESIS_EVALUATOR**.

You can see that the process is present, but on Standby.
![](/img/standbysmall.png)

This is because the evaluator process is set to run only on the primary node. Our application only has one node, but we still have to identofy it as the Primary node.

Run **setPrimary**.

#### 2. Create a new class.
When the eveluator is running, create a PostionReport class to trigger the new event.

```javapackage global.genesis.alpha.message.event
class PositionReport()
```

#### 3. Create an event handler

Create an event handler that will write the csv files to the runtime/position-daily-report folder. Call it EVENT_POSITION_REPORT.

Open the file *alpha-eventhandler.kts* and add an event handler to generate the csv file:

```java
import global.genesis.commons.standards.GenesisPaths
import global.genesis.jackson.core.GenesisJacksonMapper
import java.io.File
import java.time.LocalDate
/**
 *
 * System : alpha
 * Sub-System : alpha Configuration
 * Version : 1.0
 * Copyright : (c) GENESIS
 * Date : 2021-09-07
 *
 * Function : Provide Event Handler configuration for alpha.
 *
 * Modification History
 *
 */
eventHandler {
 //... other event handlers removed for clarity
 eventHandler<PositionReport> {
 onCommit {
 val mapper = GenesisJacksonMapper.csvWriter<Trade>()
 val today = LocalDate.now().toString()
 val positionReportFolder = File(GenesisPaths.runtime()).resolve("position-da
 if (!positionReportFolder.exists()) positionReportFolder.mkdirs()
 entityDb.getBulk(TRADE)
 .filter { it.counterpartyId != null }
```

#### 4. Update the process.xml file for the event handler

Update the **processes.xml** file for the Positions application and change the tag for ALPHA_EVENT_HANDLER:
```xml
<process name="ALPHA_EVENT_HANDLER">
<groupId>ALPHA</groupId>
<start>true</start>
<options>-Xmx256m -DRedirectStreamsToLog=true</options>
<module>genesis-pal-eventhandler</module>
<package>global.genesis.eventhandler.pal</package>
<script>alpha-eventhandler.kts</script>
<description>Handles events</description>
<classpath>alpha-messages*</classpath>
<language>pal</language>
</process>
```

#### 5.Load the cron rule on to the database
Load the cron rule csv into the database. 
Run `SendIt`.

csv:
```
CRON_EXPRESSION,DESCRIPTION,TIME_ZONE,RULE_STATUS,NAME,USER_NAME,PROCESS_NAME,MESSA
"0 * * ? * *","It’s a rule","Europe/London","ENABLED","A
rule","JohnDoe","ALPHA_EVENT_HANDLER","EVENT_POSITION_REPORT"
```

That's it.

### Dynamic events​

We have now set up the evaluator so that our application creates reports daily.

Now you are going to use the evaluator again to set up dynamic events. In this case, you want to send an email automatically if a certain limit has been breached.

#### Preparation

First, check that you have the evaluator running. If it is not, check the procedure at the beginning of the exercise on  [setting up a cron job](/tutorials/building-an-application/events/static-events).

setting up a cron job \[setting up a cron job\](/platform-reference/other-modules/dbtogenesis/dbtogenesis-oracle/).

You need to create two csv files for this exercise.

The first is the file with your rule in the correct format, as you saw with the static cron rule in the previous exercise. Call the file DYNAMIC_RULE.csv.

    NAME,DESCRIPTION,RULE_TABLE,RULE_STATUS,RULE_EXPRESSION,USER_NAME,PROCESS_NAME,MESSA
    MY_RULE,It’s a rule,POSITION,ENABLED,(QUANTITY >
    500),JohnDoe,ALPHA_EVENT_HANDLER,EVENT_POSITION_CANCEL,((QUANTITY = 0) &&
    (POSITION_ID = POSITION_ID))

The second is a csv file that enables you to test the rule. Create a file called POSITION.csv with the following data:

    POSITION_ID,INSTRUMENT_ID,COUNTERPARTY_ID,QUANTITY,NOTIONAL
    ,2,2,600,1100000

Now you are ready to begin setting up your dynamic rule.

#### 1. Set up the dynamic rule

To set up the dynamic rule, go to the DYNAMIC_RULE table and insert a row. Run `SendIt -t DYNAMIC_RULE”`

#### 2. Update the event handler

The rule needs to call an event handler, which will be called `<PositionCancel>`.
We have defined the event handler in the code block below. Open the file **alpha-eventhandler.kts** and insert the code block:

```java
eventHandler<PositionCancel> {
   onCommit { event ->
       val positionId = event.details.positionId
       entityDb.insert(
           Notify {
               topic = "PositionAlert"
               header = "Position Alert for $positionId"
               body = mapOf<String, Any?>(
                   "emailDistribution" to mapOf(
                       "to" to listOf("peter.kievits@genesis.global"),
                       "cc" to emptyList(),
                       "bcc" to emptyList(),
                   ),
                   "content" to "Position $positionId breached the limit"
               ).toJsonString(true)
           }
       )
       ack()
   }
}
```

#### 3. Set up the event handler message class

To define the event handler message class, insert the following code:

```java
package global.genesis.alpha.message.event

data class PositionCancel(
      val positionId: String,
)
```

#### 4. Set up the Notify module and start the process

The module GENESIS_NOTIFY does not run by default. To change this, open and edit the file **genesis-process.xml**.

Change `GENESIS_NOTIFY` to `true`.

Now you need to run `genesisInstall` to update the configuration.

After that, you need to restart the server so that Notify runs along with the other processes.
Run `killServer`to stop the application. When that has been completed, run `startServer` to restart it.

When that has finished, you can run  `mon`. At this  point, you will see  GENESIS_NOTIFY as one of the processes that are running.

#### 5. Set up GENESIS_NOTIFY in the database

##### Insert Gateway Route

Note that the GATEWAY_VALUE column requires an empty email distribution JSON definition.
Insert the following:

    EmailDistribution1,EmailDistribution,"{
    \"emailDistribution\" : { \"to\" : [ ], \"cc\" : [ ], \"bcc\" : [ ] } }"

##### Insert NOTIFY_ROUTE

Insert the following:

    "ENTITY_ID","ENTITY_ID_TYPE","TOPIC_MATCH","GATEWAY_ID"
    ,"GATEWAY","PositionAlert","EmailDistribution1" 

#### 6. Add connection details to the system definition

Open the **genesis-system-definitions.kts** file and add the details of the connection for the SMTP server:

    item(name = "SYSTEM_DEFAULT_USER_NAME", value =
    "GenesisGlobal" )
    item(name = "SYSTEM_DEFAULT_EMAIL", value =
    "notifications@genesis.global" )
    item(name = "EMAIL_SMTP_HOST", value =
    "smtp.office365.com" )
    item(name = "EMAIL_SMTP_PORT", value = "587" )
    item(name = "EMAIL_SMTP_USER", value =
    "notifications@genesis.global" )
    item(name = "EMAIL_SMTP_PW", value = "Dufferin!St33t" )
    item(name = "EMAIL_SMTP_PROTOCOL", value = "SMTP_TLS"
    )

#### 7. Switch on data dumps

Data dumps need to be switched on for both EVALUATOR and NOTIFY.

Run the following commands:

\`
LogLevel -p GENESIS_EVALUATOR -DATADUMP_ON

LogLevel -p GENESIS_NOTIFY -DATADUMP_ON
\`

#### 8. Trigger the event to test the rule

So, let's see if that has worked.

Insert the file POSITION.csv into the database. This is the file that you prepared earlier; it contains a value that breaches a limit,so it should trigger our event.

You can see that when the limit is breached, you receive an email automatically:

![](/img/dynamic-email.png)

Well done!