---
title: 'How to use Kotlin'
sidebar_label: 'Kotlin'
id: ht-kotlin
keywords: [kotlin]
tags:
    - kotlin
  
---



import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Kotlin is often referred to as a dialect of Java. 

Here, we are going to show you a few practical examples of Kotlin code that will help you achieve some things that are pretty necessary in just about any Genesis application.

## Basic concepts
To work with Kotlin code in Genesis, you must already have coding experience, or at least be familiar with basic coding concepts.

Take a look at the [Kotlin introductory course](https://kotlinlang.org/docs/getting-started.html).

This is a well-written and simple introduction to the skill set you need. Either check that you are familiar with it or take a little time to pick up this knowledge.

## Using basic Kotlin in Genesis

Your basic Kotlin skills will enable you to view and update some parts of the code in a newly generated application created via Genesis Create.

Here are some examples of this in Genesis. In the below examples, a lot of the time we are explicitly specifying the type to make it easier to understand. Note though, that Kotlin can infer the types, so this is not necessarily required.

The example snippets in this page include comments to highlight what is happening in each area of the code. 

## Overwriting fields on existing objects
This `eventHandler` 
```kotlin
// Event handler for inserting trades
eventHandler<Trade>("TRADE_INSERT", transactional = true) {

    onCommit { event: Event<Trade> ->
        // Get the Trade from `event` and assign to `trade` variable
        val trade: Trade = event.details

				// Now overwrite a field on the existing `trade` object
        // Set the `tradeStatus` field to NEW using the TradeStatus enum
        trade.tradeStatus = TradeStatus.NEW

        // Insert the trade into the database using `entityDb.insert()` and assign the result to `insertedRow` variable
        val insertedRow: InsertResult<Trade> = entityDb.insert(trade)

        // Return an ack response which contains the generated Id of the inserted trade
        ack(listOf(mapOf(
            "TRADE_ID" to insertedRow.record.tradeId,
        )))
    }
}
```


## If condition
This `eventHandler` 

```kotlin
// Event handler for inserting trades
eventHandler<Trade>("TRADE_INSERT", transactional = true) {

    onCommit { event: Event<Trade> ->
        // Get the Trade from `event` and assign to `trade` variable
        val trade: Trade = event.details

        // Check if the value of the trade's `counterpartyId` is GENESIS.
        val isCounterpartyGenesis = trade.counterpartyId == "GENESIS"

        // If the trade's `counterpartyId` is GENESIS, then set the trade's `needsReview` field to true, otherwise false
        if (isCounterpartyGenesis) {
            trade.needsReview = true
        } else {
		        trade.needsReview = false
        }

        // Insert the trade into the database using `entityDb.insert()` and assign the result to `insertedRow` variable
        val insertedRow: InsertResult<Trade> = entityDb.insert(trade)

        // Return an ack response which contains the generated Id of the inserted trade
        ack(listOf(mapOf(
            "TRADE_ID" to insertedRow.record.tradeId,
        )))
    }
}
```

## Handling null
This `eventHandler` 

```Kotlin
// Event handler for inserting trades
eventHandler<Trade>("TRADE_INSERT", transactional = true) {

    onValidate { event: Event<Trade> ->
        // Get the Trade from `event` and assign to `trade` variable
        val trade: Trade = event.details

        // Get Counterparty from database by its Id field using the Genesis Database API `entityDb`
        // `entityDb.get()` reads from the database
        // `counterparty` variable has type Counterparty?. Note the ?, this means the variable could be null
        val counterparty: Counterparty? = entityDb.get(Counterparty.ById(trade.counterpartyId))

        if (counterparty == null) {
            // If `counterparty` is null then return an error response using nack()
            // We use interpolation to include the `trade.counterpartyId` property in the response string
            nack("Counterparty ${trade.counterpartyId} does not exist")
        } else {
            // Otherwise, `counterparty` is not null and we pass validation and return an ack response
            ack()
        }
    }

    onCommit { event: Event<Trade> ->
        // Get the Trade from `event` and assign to `trade` variable
        val trade: Trade = event.details

        // Get Counterparty from database as we did in onValidate above
        // Now we can be assured that the counterparty exists, so we can use !! which tells Kotlin
        // that we know the variable will not be null, so our `counterparty` object is now not-null, notice the absence
        // of the ? compared to above in onValidate
        val counterparty: Counterparty = entityDb.get(Counterparty.ById(trade.counterpartyId))!!

        // Update the `trade.needsReview` field's value with the value from the `counterparty` record
        trade.needsReview = counterparty.needsReview

        // Insert the trade into the database using `entityDb.insert()` and assign the result to `insertedRow` variable
        val insertedRow: InsertResult<Trade> = entityDb.insert(trade)

        // Return an ack response which contains the generated Id of the inserted trade
        ack(listOf(mapOf(
            "TRADE_ID" to insertedRow.record.tradeId,
        )))
    }
}
```

## For loop
This `eventHandler` 

```kotlin
// Event handler for inserting trades
eventHandler<Trade>("TRADE_INSERT", transactional = true) {

    onValidate { event: Event<Trade> ->
        // onValidate same as Example 3
    }

    onCommit { event: Event<Trade> ->
        // Get the Trade from `event` and assign to `trade` variable
        val trade: Trade = event.details

        // Get Counterparty from database by its Id field using the Genesis Database API `entityDb`
        // We are assured the Counterparty is not-null, refer to Example 3 for more details
        val counterparty: Counterparty = entityDb.get(Counterparty.ById(trade.counterpartyId))!!

        // Get all trade records in the database for counterparty
        val tradesForCounterparty: List<Trade> =
            entityDb.getRange(Trade.ByCounterpartyId(trade.counterpartyId)).toList()

        // Create a new variable for calculating total trade quantity. We use `var` here so this variable can be updated
        var totalTradesQuantity = 0

        // For loop which iterates through each trade in the `tradesForCounterparty` list
        for (counterpartyTrade: Trade in tradesForCounterparty) {
            // Add the quantity from the counterparty trade to the total
            // `totalTradesQuantity += counterpartyTrade.quantity` is the same as `totalTradesQuantity = totalTradesQuantity + counterpartyTrade.quantity`
            totalTradesQuantity += counterpartyTrade.quantity
        }

        // If the quantity of all counterparty's trades exceeds the counterparty's max quantity
        // then return an error response informing user that the trade has been rejected and the reason why
        if (totalTradesQuantity > counterparty.maxQuantity) {
            nack("Trade rejected. Accepting the trade would exceed counterparty ${trade.counterpartyId}'s max quantity")
        } else {
            // If the quantity won't be exceeded, then insert the trade into the database using `entityDb.insert()`
            // and assign the result to `insertedRow` variable
            val insertedRow: InsertResult<Trade> = entityDb.insert(trade)

            // Return an ack response which contains the generated Id of the inserted trade
            ack(listOf(mapOf(
                "TRADE_ID" to insertedRow.record.tradeId,
            )))
        }
    }
}
```

## Handling null
This `eventHandler` 

```Kotlin
// Event handler for inserting trades
eventHandler<Trade>("TRADE_INSERT", transactional = true) {

    onValidate { event: Event<Trade> ->
        // onValidate same as Example 3
    }

    onCommit { event ->
        // Get Trade from event and assign to `trade` variable
        val trade: Trade = event.details

        // Insert the trade into the database using `entityDb.insert()` and assign the result to `insertedRow` variable
        val insertedRow: InsertResult<Trade> = entityDb.insert(trade)

        // Get the Trade object from `insertedRow` and assign to new variable `insertedTrade`
        val insertedTrade: Trade = insertedRow.record

        // Check if the `insertedTrade` needs a review by checking the value of `needsReview` which is a boolean
        if (insertedTrade.needsReview) {

            // If the trade needs a review then we will create a new review and insert new review question records
            // into the database which will need to be answered in the future. We are going to set the answers of
            // the new question records to be the answers of the previous review.
            //
            // Firstly, we get all previous reviews for the counterparty using the `counterpartyId` from `trade`
            // The Trade CounterpartyId field is an index on the Trade table
            // `entityDb.getRange()` returns a list of database records. `getRange` returns a Kotlin Flow type
            // so we must call `toList()` on it to perform further operations on the result
            val previousReviewsForCounterparty =
                entityDb.getRange(TradeReview.ByCounterpartyId(trade.counterpartyId)).toList()

            // Next we use the `maxBy` function which can be used on lists. We are getting a single TradeReview
            // object from the list which has the latest datetime using the TradeReview's `reviewCreated` field
            val lastReviewForCounterparty: TradeReview = previousReviewsForCounterparty.maxBy { it.reviewCreated }

            // Insert new TradeReview record, using the values from `insertedTrade` to set the fields `tradeId`
            // and `counterpartyId` on the new record.
            val newReviewRecordResult: InsertResult<TradeReview> = entityDb.insert(
                TradeReview {
                    tradeId = insertedTrade.tradeId
                    counterpartyId = insertedTrade.counterpartyId
                }
            )

            // Get TradeReview object from the inserted record result
            val newReview: TradeReview = newReviewRecordResult.record

            // Get the review questions of the last review using the `reviewId` from `lastReviewForCounterparty`
            // using `entityDb.getRange()`
            // The ReviewQuestion ReviewId field is an index on the ReviewQuestion table
            val previousReviewQuestions: List<ReviewQuestion> =
                entityDb.getRange(ReviewQuestion.ByReviewId(lastReviewForCounterparty.reviewId)).toList()

            // Next, we use the `map` function on the `previousReviewQuestions` list. `map` is a Kotlin function
            // which can be applied to collections, such as lists. It can be used to create a list of items
            // of a different type based off of another list. It iterates over each item and will add the return value
            // of the `map` lambda to the new list. For more info, see: https://kotlinlang.org/docs/collection-transformations.html#map
            //
            // Below we are applying the `map` function to the `previousReviewQuestions` list and inside the `map`
            // lambda we are creating a new ReviewQuestion object. So, for each item in the `previousReviewQuestions`
            // list we are created a new one. This new ReviewQuestion object is created in the `map` function's
            // lambda. The `questionNumber`, `question` and `answer` fields on the new ReviewQuestion object
            // are being set from the `previousReviewQuestion` object's fields
            val newReviewQuestions: List<ReviewQuestion> =
                previousReviewQuestions.map { previousReviewQuestion: ReviewQuestion ->
                    ReviewQuestion {
                        reviewId = newReview.reviewId
                        questionNumber = previousReviewQuestion.questionNumber
                        question = previousReviewQuestion.question
                        answer = previousReviewQuestion.answer
                    }
                }

            // Here we use `entityDb.insertAll()` to insert multiple records into the database in one go
            entityDb.insertAll(newReviewQuestions)
        }

        // Return an ack response which contains the generated Id of the inserted trade
        ack(listOf(mapOf(
            "TRADE_ID" to insertedRow.record.tradeId,
        )))
    }
}
```
## Filter function
