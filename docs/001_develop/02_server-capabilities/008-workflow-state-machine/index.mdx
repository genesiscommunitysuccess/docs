---
title: 'Workflow (State Machine)'
sidebar_label: 'Workflow (State Machine)'
id: server-workflow-state-machine
keywords: [workflow, state, machine]
tags:
- workflow
- state
- machine
sidebar_position: 8
---

import Log from '/snippet/_LOG.md'
import CommonProcesses from '/snippet/_common-see-processes.md'

## Overview

The Genesis server state machine is used to define workflow for application's table entities. State machines work in conjunction with [Event Handlers](/develop/server-capabilities/core-business-logic-event-handler/) to ensure records for the entity follow the correct workflow at all times.

To give an example, you may be building an Order Management System, and need to define the lifecycle of your Order's. You may have various states for your order defined in an ENUM:

ORDER_STATUS:
- NEW
- ASSIGNED
- PARTIALLY_FILLED
- FULLY_FILLED
- COMPLETED
- CANCELLED

There are typically two aspects of related system logic to define in your state machine:

1. **Transitions** ; Define what the valid transitions between the states are. Building on our example, you may need to configure that order must be `ASSIGNED` before it is moved to `PARTIALLY_FILLED`. Also, `CANCELLED` is an end state and thus has no valid transitions to another state.
1. **State Validation** ; Validate that all the required fields are set to transition to a given state. For example, an Order must have `ASSIGNED_TO` set to a valid user in the system to transition to `ASSIGNED`.

## Example configuration

State Machines can be written in-line within a GPAL event handler, else written in Kotlin and injected for use. Examples of both are detailed here.

### In-line Event Handler State Machine

The following example of a State Machine defines five events that control the transition of orders from one state to another.

```kotlin
eventHandler {
  stateMachine(ORDER.ORDER_STATUS) {
    insertEvent { //This generates an EVENT called `EVENT_ORDER_INSERT`
      initialStates(ORDER_STATUS.NEW, ORDER_STATUS.ASSIGNED) //You can only set the ORDER_STATUS to these values on an insert.

      excludedFields {
        ENTERED_BY
        ENTERED_TIME
        MODIFIED_BY
        MODIFIED_TIME
      }

      TODO is this the same as onCommit on an event?
      onEvent { event ->
        event.withDetails {
          enteredBy = event.userName
          enteredTime = now()
        }
      }

      onValidate { order ->
        verifyOnly { order hasField ORDER.PRICE }
        verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to set status of ASSIGNED")
          }
        }
      }
    }

    modifyEvent {
      mutableStates(OrderStatus.NEW, OrderStatus.ASSIGNED) //You can only modify an order when it is in state NEW or ASSIGNED

      excludedFields {
        ENTERED_BY
        ENTERED_TIME
        MODIFIED_BY
        MODIFIED_TIME
      }

      TODO why does insert use event.withDetails and this does not? Is that right?
      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }

      onValidate { order ->
        verifyOnly { order hasField ORDER.PRICE }
        verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to someone to set status of ASSIGNED")
          }
        }
      }
    }

    //An order can only go to ASSIGNED from NEW
    transitionEvent(OrderStatus.ASSIGNED) {
      fromStates(OrderStatus.NEW)

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }

      onValidate { order ->
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to someone to set status of ASSIGNED")
          }
        }
      }
    }

    //An order can only go to PARTIALLY_FILLED from ASSIGNED
    transitionEvent(OrderStatus.PARTIALLY_FILLED) {
      fromStates(OrderStatus.ASSIGNED)

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }

      onValidate { order ->
        require(order.quantityFilled > 0) { "Order must have some quantity filled to be set as PARTIALLY_FILLED" }
      }
    }

    //An order can only go to FULLY_FILLED from PARTIALLY_FILLED
    transitionEvent(OrderStatus.FULLY_FILLED) {
      fromStates(OrderStatus.PARTIALLY_FILLED)

      onEvent { event, order ->
          order.modifiedBy = event.userName
          order.modifiedTime = now()
      }

      onValidate { order ->
        require(order.quantityFilled == order.quantity) { "Order must have quantity filled to the full order quantity to be set as FULLY_FILLED" }
      }
    }

    //An order can go to COMPLETED from ASSIGNED, PARTIALLY_FILLED, FULLY_FILLED
    transitionEvent(OrderStatus.COMPLETED) {
      fromStates(OrderStatus.ASSIGNED, OrderStatus.PARTIALLY_FILLED, OrderStatus.FULLY_FILLED )

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
    }

    //An order can go to CANCELLED from ASSIGNED, PARTIALLY_FILLED, FULLY_FILLED
    transitionEvent(OrderStatus.CANCELLED) {
      fromStates(OrderStatus.ASSIGNED, OrderStatus.PARTIALLY_FILLED, OrderStatus.FULLY_FILLED)

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
    }
  }
}
```

### Injectable State Machine

The following is an example State Machine written in kotlin. This would be injected into your event handler as described in the [configuration options](#configurationoptions) section.

```kotlin
@Module
class OrderStateMachine @Inject constructor(
    db: AsyncEntityDb
) {
    private val internalState: StateMachine<Order, OrderStatus, OrderEffect> = db.stateMachineBuilder {
      // Read ORDER_STATUS from Order table
      readState { orderStatus }
      
      // Defines how the status NEW is handled
      state(OrderStatus.NEW) {
        // Allows the status to change
        isMutable = true

        // State machine will accept the specified state on creation of order
        initialState(OrderEffect.New) {
          onValidate { order ->
            verifyOnly { order hasField ORDER.PRICE }
            verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
          }
        }

        onCommit { order ->
          event.withDetails {
            enteredBy = event.userName
            enteredTime = now()
          }
        }

        // Allowed transitions are from NEW to ASSIGNED
        transition(OrderStatus.ASSIGNED, OrderEffect.Assigned)
      }

      // Defines how the status NEW is handled
      state(OrderStatus.ASSIGNED) {
        // Allows the status to change
        isMutable = true

        TODO can we use initialState when we have in the one above too?

        // State machine will accept the specified state on creation of order
        initialState(OrderEffect.Assigned) {
          onValidate { order ->
            verifyOnly { order hasField ORDER.PRICE }
            verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
            if(order.orderState == OrderStatus.ASSIGNED) {
              if(order.assignedTo == null) {
                return onValidate@nack("Order must be assigned to set status of ASSIGNED")
              }
            }
          }
        }

        TODO if ASSIGNED can be an initial state + something you transition to do I need to define onValidate twice like this?

        onValidate { order ->
          verifyOnly { order hasField ORDER.PRICE }
          verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
          if(order.orderState == OrderStatus.ASSIGNED) {
            if(order.assignedTo == null) {
              return onValidate@nack("Order must be assigned to set status of ASSIGNED")
            }
          }
        }

        onCommit { order ->
          event.withDetails {
            enteredBy = event.userName
            enteredTime = now()
          }
        }

        // Allowed transitions from ASSIGNED
        transition(OrderStatus.PARTIALLY_FILLED, OrderEffect.PartiallyFilled)
        transition(OrderStatus.COMPLETED, OrderEffect.Completed)
        transition(OrderStatus.CANCELLED, OrderEffect.Cancelled)
      }

      state(OrderStatus.PartiallyFilled) {
        isMutable = true

        onValidate { order ->
          require(order.quantityFilled > 0) { "Order must have some quantity filled to be set as PARTIALLY_FILLED" }
        }

        TODO do we have onCommit on all states? if not does this code need to go in the event handler which changes the state?
        onCommit { order ->
          event.withDetails {
            modifiedBy = event.userName
            modifiedTime = now()
          }
        }

        transition(OrderStatus.ASSIGNED, OrderEffect.Assigned)
      }


      TODO add below states

      - FULLY_FILLED
      - COMPLETED
      - CANCELLED


    //An order can only go to FULLY_FILLED from PARTIALLY_FILLED
    transitionEvent(OrderStatus.FULLY_FILLED) {
      fromStates(OrderStatus.PARTIALLY_FILLED)

      onEvent { event, order ->
          order.modifiedBy = event.userName
          order.modifiedTime = now()
      }

      onValidate { order ->
        require(order.quantityFilled == order.quantity) { "Order must have quantity filled to the full order quantity to be set as FULLY_FILLED" }
      }
    }

    //An order can go to COMPLETED from ASSIGNED, PARTIALLY_FILLED, FULLY_FILLED
    transitionEvent(OrderStatus.COMPLETED) {
      fromStates(OrderStatus.ASSIGNED, OrderStatus.PARTIALLY_FILLED, OrderStatus.FULLY_FILLED )

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
    }

    //An order can go to CANCELLED from ASSIGNED, PARTIALLY_FILLED, FULLY_FILLED
    transitionEvent(OrderStatus.CANCELLED) {
      fromStates(OrderStatus.ASSIGNED, OrderStatus.PARTIALLY_FILLED, OrderStatus.FULLY_FILLED)

      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
    }
  }
}

TODO do we need effects on in-line? 
sealed class OrderEffect {
  object New : OrderEffect()
  object Assigned : OrderEffect()
  object PartiallyFilled : OrderEffect()
  object FullyFilled : OrderEffect()
  object Completed : OrderEffect()
  object Cancelled : OrderEffect()
}

```

## Configuration options

State Machines can be written in-line within a GPAL event handler, else written in Kotlin and injected for use. Configuration options of both are detailed here.

### In-line Event Handler : `stateMachine`

Takes two parameters:
1. `tableField` ;  which is the field of a table which holds the state.
1. `transactional` ; optional boolean parameter (default is true) which functions the same as defining [`transactional` on a standard eventHandler`](/develop/server-capabilities/core-business-logic-event-handler/#eventhandler)

```kotlin
eventHandler {
  stateMachine(tableField = ORDER.ORDER_STATUS, transactional = true) {
  ...
  }
}
```

#### `insertEvent`

Define an event on this state machine for inserting the entity. The resulting eventHandler will be named `EVENT_<table_entity_name>_INSERT`. 
In the below example the event would be called `EVENT_ORDER_INSERT`.

```kotlin {3-5}
eventHandler {
  stateMachine(tableField = ORDER.ORDER_STATUS, transactional = true) {
    insertEvent {
      ...
    }
    ...
  }
}
```

##### `initialStates`

The valid values that can be set on the `tableField` on an `insertEvent` 

```kotlin {3}
  ...
    insertEvent {
      initialStates(ORDER_STATUS.NEW, ORDER_STATUS.ASSIGNED)
    ...
    }
  }
}
```

##### `excludedFields`

Removes fields defined on the table from the event. These fields should only be set by the events and not the client.

```kotlin {3-8}
    insertEvent {
      ...
      excludedFields {
        ENTERED_BY
        ENTERED_TIME
        MODIFIED_BY
        MODIFIED_TIME
      }
      ...
    }
```

##### `onEvent`

Provides event information, which can be used to get and set information on the event such as user entering the event and the event time.

TODO what is it used for? different from onCommit?

```kotlin {3-8}
    insertEvent {
      ...
      onEvent { event ->
        event.withDetails {
          enteredBy = event.userName
          enteredTime = now()
        }
      }
      ...
    }
```

##### `onValidate`

Validate the inbound event details here. See the [event handler `onValidate` documentation](/develop/server-capabilities/core-business-logic-event-handler/#onvalidate) for the full usage of `onValidate`.

TODO is the only difference you don't need to ack() at the end like you do on an event?

```kotlin {3-11}
    insertEvent {
      ...
      onValidate { order ->
        verifyOnly { order hasField ORDER.PRICE }
        verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to set status of ASSIGNED")
          }
        }
      }
      ...
    }
```

#### `modifyEvent`

Define an event on this state machine for modifying the entity. The resulting eventHandler will be named `EVENT_<table_entity_name>__MODIFY`. 
In the below example the event would be called `EVENT_ORDER_MODIFY`.

```kotlin {4-6}
eventHandler {
  stateMachine(tableField = ORDER.ORDER_STATUS, transactional = true) {
    ...
    modifyEvent {
      ...
    }
    ...
  }
}
```

##### `mutableStates`

The valid values that the table record can have set on the `tableField` on an `modifyEvent`.

For the example below, you can only modify an order when it has a status of NEW or ASSIGNED

```kotlin {3}
   ...
    modifyEvent {
      mutableStates(OrderStatus.NEW, OrderStatus.ASSIGNED)
      ...
    }
  }
}
```

##### `excludedFields`

Removes fields defined on the table from the event. These fields should only be set by the events and not the client.

```kotlin {3-8}
    modifyEvent {
      ...
      excludedFields {
        ENTERED_BY
        ENTERED_TIME
        MODIFIED_BY
        MODIFIED_TIME
      }
      ...
    }
```

##### `onEvent`

Provides event information, which can be used to get and set information on the event such as user entering the event and the event time.

TODO what is it used for? different from onCommit?

```kotlin {3-6}
    modifyEvent {
      ...
      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
      ...
    }
```

##### `onValidate`

Validate the inbound event details here. See the [event handler `onValidate` documentation](/develop/server-capabilities/core-business-logic-event-handler/#onvalidate) for the full usage of `onValidate`.

TODO is the only difference you don't need to ack() at the end like you do on an event?

```kotlin {3-11}
    modifyEvent {
      ...
      onValidate { order ->
        verifyOnly { order hasField ORDER.PRICE }
        verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to set status of ASSIGNED")
          }
        }
      }
      ...
    }
```

#### `transitionEvent`

Specifying a `transitionEvent` will generate an event specifically for transitioning the status. These events define the possible transitions of the `ORDER_STATUS` field. The resulting eventHandler will be named `EVENT_<table_entity_name>__<status being transitioned to>`.

In the below example the event would be called `EVENT_ORDER_ASSIGNED`.

```kotlin
    transitionEvent(OrderStatus.ASSIGNED) {
      ...
    }
```

##### `fromStates`

Defines the states we can transition from, to this. Use comma separation to define multiple states.

In the example below the Order.OrderStatus must be NEW for this event to validate.

TODO why do we have mutableStates in one and fromStates in another?

```kotlin {2}
    transitionEvent(OrderStatus.ASSIGNED) {
      fromStates(OrderStatus.NEW)
      ...
    }
```

##### `onEvent`

Provides event information, which can be used to get and set information on the event such as user entering the event and the event time.

TODO what is it used for? different from onCommit?

```kotlin {3-6}
    transitionEvent(OrderStatus.ASSIGNED) {
      ...
      onEvent { event, order ->
        order.modifiedBy = event.userName
        order.modifiedTime = now()
      }
      ...
    }
```

##### `onValidate`

Validate the inbound event details here. See the [event handler `onValidate` documentation](/develop/server-capabilities/core-business-logic-event-handler/#onvalidate) for the full usage of `onValidate`.

TODO is the only difference you don't need to ack() at the end like you do on an event?

```kotlin {3-9}
    transitionEvent(OrderStatus.ASSIGNED) {
      ...
      onValidate { order ->
        if(order.orderState == OrderStatus.ASSIGNED) {
          if(order.assignedTo == null) {
            return onValidate@nack("Order must be assigned to someone to set status of ASSIGNED")
          }
        }
      }
    }
```

### Injectable `StateMachine`

You can build a State Machine using this interface by providing:
- the entity of the State Machine. In our example, it is called `Order`.
- the state of the entity field to manage; this field needs to be ENUM field. In our example, it is called `OrderStatus`.
- the side effect of a state change, which is something you can subscribe to when the state changes. In our example, it is called `OrderEffect` and you can see we add it in-line in the same file we create the StateMachine module.

The following is an example State Machine written in kotlin. This would be injected into your event handler as described in the [configuration options](#configurationoptions) section.

```kotlin {5,10-17}
@Module
class OrderStateMachine @Inject constructor(
    db: AsyncEntityDb
) {
    private val internalState: StateMachine<Order, OrderStatus, OrderEffect> = db.stateMachineBuilder {
      ...
    }
}

sealed class OrderEffect {
  object New : OrderEffect()
  object Assigned : OrderEffect()
  object PartiallyFilled : OrderEffect()
  object FullyFilled : OrderEffect()
  object Completed : OrderEffect()
  object Cancelled : OrderEffect()
}
```

#### `readState`

`readState` must be defined and tells the state machine which field on the table to use for reading the state.

In our example, the field to read is `orderStatus`.

```kotlin
    private val internalState: StateMachine<Order, OrderStatus, OrderEffect> = db.stateMachineBuilder {
      readState { orderStatus }
      ...
    }      
```

#### `state`

The `state` method is where we define how to handle the state of the table. Handling of the state is managed by `StateBuilder`, which is explained in detail below.
```
    private val internalState: StateMachine<Order, OrderStatus, OrderEffect> = db.stateMachineBuilder {
      ...
         
      state(OrderStatus.NEW) {
        ...
      }
    } 
```
##### `isMutable`

TODO
```
        // Allows the status to change
        isMutable = true
```
##### `initialState`

TODO
```
        // State machine will accept the specified state on creation of order
        initialState(OrderEffect.New) {
          onValidate { order ->
            verifyOnly { order hasField ORDER.PRICE }
            verifyOnly { order hasField ORDER.QUANTITY greaterThan 0 }
          }
        }
```
TODO what else in here? onCommit? Why in 2 places?


##### `initialStateWithContext`

TODO from docs no examples

##### `onValidate`

TODO

##### `onCommit`

TODO
```
        onCommit { order ->
          event.withDetails {
            enteredBy = event.userName
            enteredTime = now()
          }
        }
```

##### `transition`

TODO

##### `transitionWithContext`

TODO from docs no examples


## Inject State Machine

### Inject State Machine in [Event Handler](/develop/server-capabilities/core-business-logic-event-handler/) file

```kotlin
eventHandler {
    val stateMachine = inject<OrderStateMachine>()

    eventHandler<Order>(name = "ORDER_INSERT", transactional = true) {
        permissioning {
            permissionCodes = listOf("ORDERR")
            auth(mapName = "ENTITY_VISIBILITY") {
                authKey {
                    key(data.counterpartyId)
                }
            }
        }
        onValidate { event ->
            val message = event.details
            verify {
                entityDb hasEntry Counterparty.ById(message.counterpartyId)
                entityDb hasEntry Instrument.ById(message.instrumentId)
            }
            ack()
        }
        onCommit { event ->
            val order = event.details
            order.enteredBy = event.userName
            stateMachine.insert(entityDb, order)
            ack()
        }
    }
}
```


### Inject State Machine in Event Handler [API](/develop/server-capabilities/core-business-logic-event-handler/#event-handler-api)

```kotlin
@Module
class EventCompanyHandlerAsync @Inject constructor(
  private val entityDb: AsyncEntityDb,
  private val orderMachine: OrderStateMachine
) : AsyncEventHandler<Company, EventReply> {
  override suspend fun process(message: Event<Company>): EventReply {
    val company = message.details
    // custom code block..
    return EventReply.EventAck()
  }
}
```

## Client API

TODO mention that this just adds state validation and point to event handler API for client interaction.

















## Runtime configuration

In-line state Machines are defined as Event Handlers in your application's `*-eventhandler.kts` file and you shouldn't need to do any more.

If you have defined your state-machine in kotlin, make sure the event handler definition in `processes.xml` includes the `.jar` file containing the state machine in `<classpath>`.

<CommonProcesses/>


## Integration testing

A State Machine is just another layer of an Event Handler, the test configuration is same as for Event Handlers.

The Genesis Platform provides the `AbstractGenesisTestSupport` abstract class that enables end-to-end testing of specific areas of your application. In this case, we want to ensure that we have a database, seeded with information, and that our Event Handler configuration is used to create our Event Handler. We also need to add the required packages, genesis home and separately set the `IS_SCRIPT` System Definition property to true (This is required as part of the Event Handler initialization).

```kotlin
class EventHandlerTest : AbstractGenesisTestSupport<GenesisSet>(
    GenesisTestConfig {
      addPackageName("global.genesis.eventhandler.pal")
      genesisHome = "/GenesisHome/"
      parser = { it }
      scriptFileName = "your-application-eventhandler.kts"
      initialDataFile = "seed-data.csv"
    }
) {
    override fun systemDefinition(): Map<String, Any> = mapOf("IS_SCRIPT" to "true")
}
```

Once you have set up your configuration, you can start writing tests against State Machine.

### Writing tests

Let's write some tests for our [examples](#example-configuration) of State Machine.

```kotlin

  //Add these helper functions for test:
  private inline fun <T : Any> T.assertProperty(block: T.() -> Boolean) = assert(block()) {
    toPrettyJsonString(true)
  }

  private fun EventReply.EventAck.extractOrderId(): String {
    val generated = generated.first()
    assert(generated.isNotEmpty())
    assert("ORDER_ID" in generated)
    return generated["ORDER_ID"] as String
  }

  private fun makeOrder(newOrderPrice: Double, orderQuantity: Int) =
    Order {
      orderId = "order_id"
      quantity = orderQuantity
      orderPrice = newOrderPrice
      instrumentId = 1
      enteredBy = null
      enteredTime = null
      modifiedBy = null
      modifiedTime = null
    }

  @Test
  fun `test order insert`() = runBlocking {
    val start = DateTime.now()
    val reply = sendEvent(
      makeOrder(1.25, 12),
      messageType = "EVENT_ORDER_INSERT",
        userName = "admin"
      )

    val ack = reply.assertedCast<EventReply.EventAck>()
    val order = entityDb.get(Order.ById(ack.extractOrderId()))!!

    order.assertProperty { enteredBy == "admin" }
    order.assertProperty { enteredTime!! > start }
    order.assertProperty { orderPrice == 1.25 }
    order.assertProperty { quantity == 12 }
    order.assertProperty { orderStatus == OrderStatus.NEW }
  }

  @Test
  fun `test order insert - failure`() = runBlocking {
    val reply = sendEvent(
      makeOrder(1.25, -1),
      messageType = "EVENT_ORDER_INSERT",
      userName = "admin"
    )

    val nack = reply.assertedCast<EventReply.EventNack>()
    val error = nack.error.first().text

    assertEquals("Expected Order.QUANTITY to be greater than or equal to 0; actual value -1", error)
  }

  @Test
  fun `test order modify`() = runBlocking {
    val reply = sendEvent(
        makeOrder(1.25, 12),
        messageType = "EVENT_ORDER_INSERT",
        userName = "admin"
    )

    val ack = reply.assertedCast<EventReply.EventAck>()

    val orderId = ack.extractOrderId()
    var order = entityDb.get(Order.ById(orderId))!!

    order.quantity = 15

    sendEvent(
        order,
        messageType = "EVENT_ORDER_MODIFY",
        userName = "admin"
    ).assertedCast<EventReply.EventAck>()

    order = entityDb.get(Order.ById(orderId))!!

    order.assertProperty { enteredBy == "admin" }
    order.assertProperty { modifiedBy == "admin" }
    order.assertProperty { quantity == 15 }
    order.assertProperty { orderStatus == OrderStatus.NEW }
  }

  @Test
  fun `test order modify - failure`() = runBlocking {
    val reply = sendEvent(
        makeOrder(1.25, 12),
        messageType = "EVENT_ORDER_INSERT",
        userName = "admin"
    )

    val ack = reply.assertedCast<EventReply.EventAck>()

    val reply2 = reply.messageType

    val orderId = ack.extractOrderId()
    val order = entityDb.get(Order.ById(orderId))!!

    order.orderPrice = null

    val nack = sendEvent(
        order,
        messageType = "EVENT_ORDER_MODIFY",
        userName = "admin"
    ).assertedCast<EventReply.EventNack>()

    val error = nack.error.first().text
    assertEquals("Expected Order.ORDER_PRICE to have a value", error)
  }

  @Test
  fun `test order cancel`() = runBlocking {
    val reply = sendEvent(
      makeOrder(1.25, 12),
      messageType = "EVENT_ORDER_INSERT",
      userName = "admin"
    )

    val ack = reply.assertedCast<EventReply.EventAck>()

    val orderId = ack.extractOrderId()
    val index = Order.ById(orderId)

    sendEvent(
        index,
        messageType = "EVENT_ORDER_CANCELLED",
        userName = "admin"
    ).assertedCast<EventReply.EventAck>()

    val order = entityDb.get(index)!!

    order.assertProperty { enteredBy == "admin" }
    order.assertProperty { modifiedBy == "admin" }
    order.assertProperty { orderStatus == OrderStatus.CANCELLED }
  }

  @Test
  fun `test order modify - fail cancelled`() = runBlocking {
    val reply = sendEvent(
      makeOrder(1.25, 12),
      messageType = "EVENT_ORDER_INSERT",
      userName = "admin"
    )

    val ack = reply.assertedCast<EventReply.EventAck>()

    val orderId = ack.extractOrderId()
    val index = Order.ById(orderId)

    sendEvent(
      index,
      messageType = "EVENT_ORDER_CANCELLED",
      userName = "admin"
    ).assertedCast<EventReply.EventAck>()

    val order = entityDb.get(index)!!
    order.quantity = 100

    val nack = sendEvent(
      order,
      messageType = "EVENT_ORDER_MODIFY",
      userName = "admin"
    ).assertedCast<EventReply.EventNack>()

    val error = nack.error.first().text
    assert(error == "Order CANCELLED is immutable") { error }
  }
```

:::info
For further information on testing, go to our page on [Integration testing](/develop/server-capabilities/testing-api/).
:::