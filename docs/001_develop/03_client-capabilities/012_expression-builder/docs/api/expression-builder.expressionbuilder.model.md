---
format: md
---
<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@genesislcap/expression-builder](./expression-builder.md) &gt; [ExpressionBuilder](./expression-builder.expressionbuilder.md) &gt; [model](./expression-builder.expressionbuilder.model.md)

## ExpressionBuilder.model property

> This API is provided as a beta preview for developers and may change based on feedback that we receive. Do not use this API in a production environment.
> 

model - `Types.Group` the current model which completely describes the state of the component.

\*IMPORTANT\* you should not set this yourself via this property directly, you should always set it via the model property on the [ExpressionBuilder.config](./expression-builder.expressionbuilder.config.md) block.

You may want to read from this variable to get the most up to date state, for example if you create a child component which has a model which isn't valid for every single state (e.g. requires a complete rule) you can check this underlying model to verify what field or operator is selected.

**Signature:**

```typescript
model: ModelGroup | null;
```

## Example


```ts
const model = document.querySelector('expression-builder');
// Once you have the model you can read it to check the applied config. While the primary use should be checking the updated model via
the emited change event, you can use this to check more specific changes that a domain specific model might not.

For example, imagine a RulExpressionBuilder which is an implementation specifically for a boolean logic expression. That component may not
model a non-complete rule (a rule without a field, and operator, and value). In that case when it emits the event the payload will only change
when the user has completely configured a new rule. But if you need to catch cases earlier when they've changed the field but before they've
changed the value you can check the model here.
```

