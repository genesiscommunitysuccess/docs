---
title: "State management"
sidebar_label: "State management"
id: state-management
keywords:
  [
    Attributes,
    Dynamic Attributes,
    Boolean Attributes,
    Attribute Binding,
    Properties,
    Observables,
    Reactive State,
    State Updates,
    Template Bindings,
    Property Observables,
  ]
tags:
  - attr
  - observable
  - Attribute Binding
  - Dynamic Attributes
  - Boolean States
  - Property Change
  - Reactive Data
sidebar_position: 3
---

If you are writing your own web components, there are three ways of managing the state of components: 

- Attributes. You define these are defined in the HTML markup of the element.
- Properties. These are accessed via the DOM object in Javascript (or via a special property-binding syntax in the mark-up).
- Observables. Observable properties and attributes configure the component to watch for changes, enabling the associated html template to update as they are updated.

## Attributes

To create an attribute, use the `@attr` decorator. This creates a property-attribute pair - a binding. Once created, any change in one automatically updates the other, keeping them synchronized.

Here is an example of an attribute for the `MyButton` example component:

```typescript
@customElement({
  name: "my-button",
  template: html<MyButton>`<button>Click Me</button>`,
  styles,
})
export class MyButton extends GenesisElement {
  @attr label: string = "Submit";

  labelChanged(oldValue, newValue) {
    console.log(`Button text changed from ${oldValue} to ${newValue}`);
  }
}
```

The `label` property is tied to an HTML attribute, so to override the value of `label`, you can simply replace it in the HTML.

#### Usage in HTML

Now when you use `<my-button>` in your HTML, you can change the default value of `label` ('Submit'). In this case, we are changing it to `Cancel`.

```typescript
 <my-button label="Cancel"></my-button>
```

The `labelChanged` method in the custom element is not necessary. But it is useful if you want to perform additional actions when the label attribute changes, such as logging or triggering other side effects. The `@attr` decorator handles the synchronization between the attribute and property (updating the DOM whenever label changes).

:::info
Here are the most important things to know about attributes:

- They can be boolean or string. 
  - String attributes have string key-value pairs `attribute="value"`: for example, `attribute="name=John"`.
  - Boolean attributes are considered true if their name is added to a component, and false if not.
- They are used in HTML markup.
- They are visible in Browser Console DOM inspector.
:::

### Binding attribute values

For most attributes, you can directly bind their values to expressions in the template. This enables them to be updated dynamically, based on properties in the component.

The `label` attribute controls the text shown on the button. To bind `label` to a dynamic value, we use an expression within the template.

Here’s an example of this might in a `<my-button>` component:

```typescript
@customElement({
  name: 'my-button',
  template: html<MyButton>`<button>${(x) => x.label}</button>`,
  styles,
})

export class MyButton extends GenesisElement {
    @attr label = 'Click Me';
    // Here we are binding the text inside the button to the `label` attribute.
};
```

#### Usage in HTML

When you use the component in your HTML, the `label` attribute binds directly to the button's text via the `${(x) => x.label}` in the component definition.

- If `label` is set to `"Cancel"` in HTML `(<my-button label="Cancel">)`, the button displays "Cancel".
- When the `label` value is changed dynamically, the button text is updated.

```typescript
<my-button label="Cancel"></my-button>
```

### Interpolated attribute values

Where an attribute value is partially static and partially dynamic, you can combine the static and dynamic parts using interpolated expressions. This approach is useful for creating customized button labels or CSS classes.

Consider this example for the `MyButton` component. You can use interpolation to dynamically construct an `aria-label` that combines a static prefix ("Perform action:") with a dynamic property (`action`). Similarly, the button’s visible label can be updated based on the `label` property:

```typescript
@customElement({
  name: "my-button",
  template: html<MyButton>`<button
    aria-label="${(x) =>
      `Perform action: ${x.action}`}" //textual description for assistive technologies
    label="${(x) => `Click: ${x.label}`}"
    class="button"
  >
    ${(x) => `${x.label}`}
  </button>`,
  styles,
})
export class MyButton extends GenesisElement {
  @attr label = "Go"; // Button text label
  @attr action = "Save";
}
```

:::tip

`label` is strictly for visibility. By contrast, `aria-label` provides a textual description of an element's purpose or action for assistive technologies. This ensures that users relying on screen readers can understand and interact with the element, even if its visible text or appearance is unclear or insufficient.

:::

### Binding boolean attributes

With boolean attributes, their presence or absence determines their value (the string value itself does not). And an attribute can also take a configuration from the `mode` option.

If the attribute is a boolean and the `mode` is set to `"boolean"`, this enables `GenesisElement` to add or remove the attribute from the element.

- If a boolean attribute is present in the HTML markup (e.g., `<button disabled></button>`), it is interpreted as true.
- If the attribute is absent (e.g., `<my-button></my-button>`), it is interpreted as false.

If you want the attribute to change dynamically, use the **?** prefix. This adds or removes the attributes from the DOM, based on the specified condition.

:::info Controlling the button dynamically
The `disabled` attribute controls whether the button is clickable. If you use `?disabled=${(x) => x.isDisabled}`, you can bind it to the component’s `isDisabled` property and dynamically control whether the button is enabled or disabled.
:::

```typescript
@customElement({
  name: "my-button",
  template: html<MyButton>`
    <button ?disabled="${(x) => x.isDisabled}" @click="${(x) => x.handleClick}">
      ${(x) => x.label}
    </button>
  `,
  styles,
})
export class MyButton extends GenesisElement {
  @attr label = "Click Me";
  @attr({ mode: "boolean", attribute: "disabled" }) isDisabled = false; // Use "disabled" in HTML

  handleClick() {
    if (!this.isDisabled) {
      console.log("Button clicked");
    }
  }
}
```

#### Usage in HTML

Here is a simple example of using the attribute in HTML. By default, the button is disabled, but this can be changed dynamically:

```typescript
<my-button label="Submit" disabled></my-button>
```

In this example:

- The `?disabled="${(x) => x.isDisabled}"` syntax causes the templating engine to handle boolean attributes automatically.
  - If `isDisabled` is true, the `disabled` attribute is added to the button (`<button disabled>`).
  - If `isDisabled` is false, the `disabled` attribute is removed from the button.
- The `@attr({ mode: 'boolean' })` decorator ensures that changes to `isDisabled` in JavaScript reflect in the DOM as a disabled attribute, and vice versa.
- The `attribute` key in the `@attr` decorator allows you to explicitly define the attribute name used in HTML. In this example:
  - `isDisabled` is a property and it and follows camelCase convention in JavaScript which help distinguish from the HTML attribute `disabled`.
  - `disabled` is an attribute and it's used in HTML to represent state declaratively and reflect it in the DOM.

## Properties

It's important to distinguish between attributes and properties.

- Attributes are part of the HTML markup. They provide initial configuration and are typically static values of `type` string.
- Properties are JavaScript-based. They can be any data type (boolean, number, object, etc). You can set them on simple Javascript objects and on classes.

You can link attributes to properties via `reflection`. Once you have done this, updates to one (e.g. setting a property) can update the other (e.g. the attribute in HTML).

To manage `reflection`, use the `@attr` decorator, making attributes and properties synchronize automatically to reflect the latest state.

Properties and attributes are effectively two sides of the same coin. The `@attr` decorator creates a two-way binding between a JavaScript property on the component and a DOM attribute. Consequently, changes to the attribute in the HTML reflect on the property in JavaScript, and changes to the property in JavaScript update the attribute in the DOM.

:::important

You can define properties internally in the component class without linking them to HTML attributes. These internal properties are not exposed in the DOM as attributes.

:::

`clickCount` is an internal property and is only accessible within the component. It is **not** reflected in the HTML markup. Only `label` is accessible as an HTML attribute.

```typescript
@customElement({
  name: "my-button",
  template: html<MyButton>`
    <button @click="${(x) => x.handleClick()}">${(x) => x.label}</button>
  `,
  styles,
})
export class MyButton extends GenesisElement {
  @attr label = "Click Me"; // Linked attribute for label
  clickCount = 0; // Internal property, not linked to an attribute

  handleClick() {
    this.clickCount += 1; // Update internal state
    console.log(`Button clicked ${this.clickCount} times`);
  }
}
```

When you declare a property on a class, you can add the `@attr` decorator, which provides reflection between the JavaScript property and the HTML attribute. Changes to the attribute will update the property, and vice versa. For example:

```typescript
export class MyButton extends GenesisElement {
  @attr label = "Click Me"; // Declared as a linked property
}
```

The **:** symbol is useful when you want to bind complex data types or frequently-changing properties that shouldn’t be reflected as attributes in the DOM.

In the example below, the **:** symbol is used for property binding. This binds values directly to DOM properties instead of HTML attributes. See the `clickCount` statement.


```typescript
@customElement({
  name: "my-button",
  template: html<MyButton>`<button
    :clickCount="${(x) => x.clickCount}" // :clickCount property binding dynamically updates the clickCount property of the <button> element.
    @click="${(x) => x.handleClick()}"
  >
    Clicked ${(x) => x.clickCount} times
  </button>`,
  styles,
})
export class MyButton extends GenesisElement {
  clickCount = 0; // Internal property, not reflected as an attribute

  handleClick() {
    this.clickCount += 1; // Update internal property
    console.log(`Button clicked ${this.clickCount} times`);
  }
}
```

## Observables

Observables enable you to create reactive components. The properties of the observable enable you to update the associated view (html template) within a component automatically whenever the data changes. This is essential for dynamic and interactive elements. 

You can declare an observable using the `@observable` decorator.

- Observable properties automatically trigger updates to any part of the template or component that depends on them. Whenever an observable property changes, the UI or other bound elements are updated without additional code.
- Use `@observable` to mark a property as an observable. This ensures that changes to the property automatically trigger any relevant updates in the component.
- For each observable property, there is a built-in mechanism to execute code whenever the property’s value changes. This callback method is named after the observable property, with the suffix '**Changed**'.

Below is another example of a `<my-button>` component. 

- The `@observable` decorator creates a `count` property that updates dynamically every time a button is clicked. 
- The `countChanged` callback logs each change.

```typescript
import { observable, customElement, GenesisElement, html } from '@genesislcap/web-core';

@customElement({
  name: 'my-button',
  template: html<MyButton>`
    <button @click="${(x) => x.increment()}">
        ${(x) => `Clicked: ${x.count} times`}
    </button>
`;,
  styles,
})

export class MyButton extends GenesisElement {
    @observable count = 0; // Observable count property

    // Method to increment the count
    increment() {
        this.count+= 1; // Increases the count by 1
    }

    // Callback triggered whenever `count` changes
    countChanged(oldValue, newValue) {
        console.log(`Count changed from ${oldValue} to ${newValue}`);
    }
}

```
Look at that example again in more detail:

- The `@observable` decorator makes `count` reactive. So, any change in `count` automatically updates the bound elements in the template.
- The template displays the current `count` as part of the button text. Whenever `count` changes, this binding is re-rendered, showing the latest value without extra code. 
- The `countChanged` method is automatically called whenever `count` changes. This callback receives the `oldValue` and `newValue`, enabling you to track and log each change in the console.

#### Usage in HTML

We can declare the button in the HTML with a simple statement:
```typescript
<my-button></my-button>
```

In its initial state, the button displays "Clicked: 0 times".

After there have been clicks on the button:

- After the first click, the button displays `Clicked: 1 times`.
- The count on the display is incremented with each click.

Additionally, each time the `count` updates, `countChanged` logs the old and new values to the console:

```typescript
Count changed from 0 to 1
Count changed from 1 to 2
```
:::important

The `@observable` decorator is an effective way to manage the state of a component, using properties to reactively update the UI, trigger callbacks, and handle complex data in a streamlined way.

:::
