---
title: 'Examples and configuration'
sidebar_label: 'Examples and configuration'
id: client-layout-management-examples
keywords: [ layout, layout management, Drag and drop, Resizable panels, Tabbed , Responsive , Customizable, Splitting, Stacking, Popouts, Nested , State persistence, Flexible, Container, Item, Component, Content item, Stack, Row, Column, Header, Tabs, Lifecycle methods, API, Resize events, Drag , Close events Declerative HTML, Attribute, Property, Template]
tags:
- layout
- layout management
- Drag and drop
- Resizable panels
- Tabbed
- Responsive
- Customizable
- Splitting
- Stacking
- Popouts
- Nested
- State persistence
- Flexible
- Container
- Item
- Component
- Content item
- Stack
- Row
- Column
- Header
- Tabs
- Lifecycle methods
- API
- Resize events
- Drag
- Close events
- Declerative HTML
- Attribute
- Property
- Template
sidebar_position: 15
---

This file contains some extra configuration option explanations, as well as some examples.

## Autosaving layout

You can set the layout to autosave in local storage as the user interacts with it. To do this, set the `auto-save-key` attribute to a unique string on the root element; the layout will be saved in this key. The layout will be saved for later recall in local storage whenever the user performs the following actions:

- adding an item
- removing an item
- resizing items using the divider
- dragging items around the layout

When you have enabled autosave, you are still able to use the manual serialising commands.
<!-- TODO link -->

### Reloading the layout

The function `tryLoadLayoutFromLocalStorage()` is used to rehydrate the layout from local storage, when `auto-save-key` is enabled.
<!-- TODO link -->
If you are using the declarative API, then this function is called for you automatically.

If you are manually registering items (too) using the JavaScript API, you must call this function manually immediately after you have finished registering all the items.
<!-- TODO link -->

### Layout placeholder

If the layout is auto-loaded with items that are missing from the registration, then a placeholder item is displayed instead. Additionally, the close option is added to the pane. This accounts for you removing an item from a layout that a user has autosaved in their config.

You can change the text of the placeholder using the observable binding `:missingItemPlaceholder`. This is a function that takes a string (the missing registration name) and returns the string to use as the placeholder. A default is set, but you can override it. See the override implementation in this example.
<!-- TODO link -->

### Invalidating the cache

As explained in the previous section, a placeholder item is added if an item is no longer registered for the auto-loaded layout. This accounts for removing an item. However, there is the reverse issue if you are only using the declarative API; if you add a new item and the user already has an autosaved layout, then that will be loaded - which effectively hides the new item you've added.

In this case, you must invalidate the autosaved layout cache. The cleanest and easiest implementation is to add a hash onto the end of your `auto-save-key`, which will start a new autosave for this table (and reload the default, containing your new layout item).

## Customising header buttons

You can add custom buttons on layout items, and then control their behaviour. See the custom button API for the full definition.
<!-- TODO link -->
Setting this is optional. If you do define it, you must define it as an array, which enables you to add multiple custom buttons.

* The `svg` parameter controls the icon that is displayed for your button. The format must be a base64 image definition. See the format (as explained in the linked api document above), and then replace the text around the `<< >>` part with a base64 encoded definition of the svg you wish to use.
* The `onClick` parameter will register a callback with the button. When the user clicks the button, your callback will be called. The callback receives a reference to the clicked button element, and to the element that is contained in the layout item associated with the clicked button.

Different layout instances can have their own custom buttons, or they can share definitions. You are not able to have fine-grained control over each layout item, though; so if a layout has a custom button, then every item that it contains will have the button.

### Applying the custom button

To ensure that every item gets the button as expected, you need to ensure that you apply the custom button definitions as early as possible. If you are using the html API then you'll probably want to apply the definitions in the template.

```html
<rapid-layout :customButtons=${() => buttonDefinition}>
  ...
</rapid-layout>
```

If you are only using the javascript API then you should just apply the property as soon as you can.
```typescript
layout.customButtons = buttonDefinition;
```

### Renaming example

See this example of creating a custom button, which enables the user to rename an item.
```typescript
export const layoutCustomButtons: CustomButton[] = [
  {
    svg: LAYOUT_ICONS.renameSVG,
    onClick: (button: HTMLElement, elem: HTMLElement) => {
      const title = prompt('New name?');
      const event: LayoutReceiveEventsDetail['changeTitle'] = {
        title,
        mode: 'replace',
      };
      elem.dispatchEvent(
        new CustomEvent(LayoutReceiveEvents.changeTitle, { detail: event, bubbles: true }),
      );
    },
  },
];
```
You can import `LAYOUT_ICONS`, `CustomButton`, `LayoutReceiveEvents`, and `LayoutReceiveEventsDetail` from the foundation-layout package, to get strong typing.

:::warning
You'll probably want to improve this callback function to handle cases where the user doesn't enter a prompt value.
:::
