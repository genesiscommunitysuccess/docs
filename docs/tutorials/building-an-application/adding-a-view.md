---
id: add-view
title: Adding a view
sidebar_label: Adding a view
sidebar_position: 3

---
At this stage, you have

* a ref_data_app (with all its tables). The schema can be imported into the trading_app.
* a trading_app that contains the schema for the TRADE table. This table will be used to generate the event handlers, data servers and request server.

## Create the new view

You need to create a view that can display relevant information about the trades table.

The trading app already has a view created by the **ExcelToGenesis** script called TRADE_VIEW. You are now going to add a new view called ENHANCED_TRADE_VIEW. This new view makes it possible to display relevant information about the trades table and enhance with data from other tables.

The view will have the TRADE table as root and will be joined to the COUNTERPARTY and INSTRUMENT tables. 

The view will display all the TRADE fields except INSTRUMENT_ID, COUNTERPARTY_ID, COUNTERPARTY_NAME and INSTRUMENT_SYMBOL. These fields will be replaced with the NAME field extracted from the INSTRUMENT table join and the COUNTERPARTY table join.

In short, you will add INSTRUMENT_NAME and COUNTERPARTY_NAME to enhance the view with human readable values.

Run `codegen:generateView` to make the new view ready for use (See below).

![](/img/generateView.png)

## Add the new view to the data server

Now go to the data server definition (inside the **-script-config** module). Replace the ALL_TRADES query in the data server with the new ENHANCED_TRADE_VIEW.

```kotlin
  view ("ENHANCED_TRADE_VIEW", TRADE) {

    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }

    fields {
      TRADE.PRICE
      TRADE.QUANTITY
      TRADE.TRADE_DATETIME
      TRADE.SIDE
      TRADE.TRADE_ID
      COUNTERPARTY.NAME withPrefix COUNTERPARTY
      INSTRUMENT.NAME withPrefix INSTRUMENT
      derivedField("CONSIDERATION", DOUBLE) {
        // I: F2*H2
        withInput(TRADE.QUANTITY, TRADE.PRICE) { QUANTITY, PRICE ->
          if(QUANTITY == null) return@withInput null
          if(PRICE == null) return@withInput null
          QUANTITY * PRICE
        }
      }
    }
  }
```

## Testing

Let's now create a unit test showing usage of the view repository generated by the code generation mechanism.

The purpose of the test is to prove you can look up data with the repo and retrieve the joined-up structure. We can show that we can:

* look up by keys
* perform get bulk from the main table

First you need to do the following:

1. Add the **db-test** dependency to the config module
```xml
<dependency>
    <groupId>global.genesis</groupId>
    <artifactId>genesis-dbtest</artifactId>
    <scope>test</scope>
</dependency>
```
2. Add a dependency on the **ref_data_app-config module** in pom file
```xml
<dependency>
    <groupId>global.genesis</groupId>
    <artifactId>ref_app_data-config</artifactId>
    <version>${ref_app_data.version}</version>
    <scope>test</scope>
</dependency>
```
3. Add a new test class to the config module called `EnhancedTradeViewTest.kt`
4. Add the genesis home folder with an empty txt file. This folder is needed for unit tests. 
5. Add TEST_DATA.csv to a data folder
```csv
#INSTRUMENT
INSTRUMENT_ID,NAME
1,FOO.L
2,BAR.L
#COUNTERPARTY
COUNTERPARTY_ID,COUNTERPARTY_LEI,NAME,
1,335800A8HK6JBITVPA30,Test Ltd,
2,655FG0324Q4LUVJJMS11,Testing AG,
```

Should look like below:

![](/img/view-test-folder-structure.png)

### Test class setup
```kotlin
package global.genesis

import global.genesis.db.util.AbstractDatabaseTest
import global.genesis.db.util.TestUtil
import global.genesis.dictionary.GenesisDictionary
import global.genesis.gen.dao.Trade
import global.genesis.gen.view.entity.EnhancedTradeView
import global.genesis.gen.view.repository.EnhancedTradeViewRepository
import org.joda.time.DateTime
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import javax.inject.Inject

class EnhancedTradeViewTest : AbstractDatabaseTest() {

    @Inject
    lateinit var enhancedTradeViewRepository: EnhancedTradeViewRepository

    override fun createMockDictionary(): GenesisDictionary = prodDictionary()

    @Before
    fun setup() {
        TestUtil.loadData(resolvePath("data/TEST_DATA.csv"), rxDb)
    }

    private fun buildTrade(tradeId: Long, now: DateTime = DateTime.now()) =
        Trade.builder()
            .setTradeDatetime(now)
            .setCounterpartyId("2") // COUNTERPARTY_NAME = "Testing AG"
            .setInstrumentId("1")   // INSTRUMENT_NAME = "FOO.L"
            .setPrice(12.0)
            .setQuantity(100)
            .setSide("BUY")
            .setTradeId(tradeId)
            .build()
}
```

### Test get single trade by ID
```kotlin
@Test
fun `test get single trade by id`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)

    rxEntityDb.insert(trade).blockingGet()

    val tradeView = enhancedTradeViewRepository.get(EnhancedTradeView.ById(1)).blockingGet()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```

### Test get single trade with getBulk
```kotlin
@Test
fun `test with single trade - use getBulk`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)

    rxEntityDb.insert(trade).blockingGet()

    val tradeViewList = enhancedTradeViewRepository.getBulk()
        .toList()
        .blockingGet()

    assertEquals(1, tradeViewList.size)

    val tradeView = tradeViewList.first()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```

### Test get multiple trades
```kotlin
@Test
fun `test get multiple trades`() {
    rxEntityDb.insertAll(
        buildTrade(1),
        buildTrade(2),
        buildTrade(3),
        buildTrade(4),
        buildTrade(5),
    ).blockingGet()

    val count = enhancedTradeViewRepository.getBulk().count().blockingGet()

    assertEquals(5, count)
}
```