---
id: add-state-machine
title: Workflow - add a state machine
sidebar_label: Workflow - add a state machine
sidebar_position: 6

---
Now we are going to configure state machine to control the workflow of trades.

At this stage, you have:

* a Reference Data application. This has tables, so you can import the schema to the Positions application
* a Positions application. This contains the schema for the TRADE table, plus event handlers, data servers and request servers

Also, you have enhanced the EVENT_TRADE_INSERT event handler so that it performs validation checks.

## The objective

State machines enable you to control workflow by defining the transitions from state to state, This example enables you to build a very simple state machine to add new trades. You will create a new field called TRADE_STATUS, which can have three possible states: NEW, ALLOCATED, CANCELLED.

* NEW can go to ALLOCATED or CANCELLED.
* ALLOCATED and CANCELLED canâ€™t go anywhere else.
* NEW is the only state you can use to insert new records.

![](/img/diagram-of-states.png)

Note that event handlers have already been generated by the AppGen process you ran earlier. Once you have added add a new field to the data model, you will  edit the event handler file to add controlled transitions from one state to another.

### 1. Add the new field to the data model

Add the TRADE_STATUS field to the `trading_app-fields-dictionary.kts` file.

```kotlin {16}
fields {
  field(name = "COUNTERPARTY", type = STRING)
  field(name = "COUNTERPARTY_LEI", type = STRING)
  field(name = "COUNTERPARTY_NAME", type = STRING)
  field(name = "ENTERED_BY", type = STRING)
  field(name = "FIELD_3", type = LONG)
  field(name = "INSTRUMENT_SYMBOL", type = STRING)
  field(name = "PRICE", type = DOUBLE)
  field(name = "QUANTITY", type = LONG)
  field(name = "REFERENCE_PX", type = STRING)
  field(name = "REFERENCE_QTY", type = DOUBLE)
  field(name = "SIDE", type = STRING)
  field(name = "SYMBOL", type = LONG)
  field(name = "TRADE_DATETIME", type = DATETIME)
  field(name = "TRADE_ID", type = LONG)
  field(name = "TRADE_STATUS", type = ENUM("NEW", "ALLOCATED", "CANCELLED", default = "NEW"))
}
```

Add the TRADE_STATUS field to the TRADE table in the `trading_app-tables-dictionary.kts` file.

```kotlin {12}
tables {
  table (name = "TRADE", id = 11000) {
    // Source: Trade
    TRADE_ID            // A
    INSTRUMENT_ID not null       // B
    COUNTERPARTY_ID not null     // C
    QUANTITY            // F
    SIDE                // G
    PRICE               // H
    TRADE_DATETIME      // K
    ENTERED_BY          // L
    TRADE_STATUS

    primaryKey {
      TRADE_ID
    }

  }
}
```

Run codegen to generate the fields.
Run codegen again to create the DAOs.

![](/img/state-machine-codegen.png)

### 2. Create a new class for the state machine

Add a main folder in the event handler module and create a state machine class.

![](/img/state-machine-location.png)

Add a state machine definition and assign a field in the **onCommit** block,

```kotlin
package global.genesis

import com.google.inject.Inject
import global.genesis.commons.annotation.Module
import global.genesis.db.rx.entity.multi.AsyncEntityDb
import global.genesis.db.statemachine.StateMachine
import global.genesis.db.statemachine.Transition
import global.genesis.gen.dao.Trade
import global.genesis.gen.dao.enums.TradeStatus

@Module
class TradeStateMachine @Inject constructor(
    db: AsyncEntityDb
) {
    private val internalState: StateMachine<Trade, TradeStatus, TradeEffect> = db.stateMachineBuilder {
        readState { tradeStatus }

        state(TradeStatus.NEW) {
            isMutable = true

            initialState(TradeEffect.New) {
                onValidate { trade ->
                    verify {
                        db hasNoEntry Trade.ById(trade.tradeId)
                    }
                }
            }

            onCommit { trade ->
                if (trade.enteredBy == "TestUser") {
                    trade.price = 10.0
                }
            }

            transition(TradeStatus.ALLOCATED, TradeEffect.Allocated)
            transition(TradeStatus.CANCELLED, TradeEffect.Cancelled)
        }

        state(TradeStatus.ALLOCATED) {
            isMutable = false

            transition(TradeStatus.NEW, TradeEffect.Cancelled)
            transition(TradeStatus.CANCELLED, TradeEffect.Cancelled)
        }

        state(TradeStatus.CANCELLED) {
            isMutable = false
        }
    }

    suspend fun insert(trade: Trade): Transition<Trade, TradeStatus, TradeEffect> = internalState.create(trade)

    suspend fun modify(tradeId: Long, modify: suspend (Trade) -> Unit): Transition<Trade, TradeStatus, TradeEffect>? =
        internalState.update(Trade.ById(tradeId)) { trade, _ -> modify(trade) }

    suspend fun modify(trade: Trade): Transition<Trade, TradeStatus, TradeEffect>? = internalState.update(trade)
}

sealed class TradeEffect {
    object New : TradeEffect()
    object Allocated : TradeEffect()
    object Cancelled : TradeEffect()
}
```

### 3. Add the module as a pom dependency

Add the event handler module as a pom dependency to script-config module and refresh the maven.

![](/img/state-machine-pom-change.png)

### 4. Edit the event handler to add an integrated state machine

Integrate the state machine in the TRADE_INSERT event.

```kotlin {2,15}
eventHandler {
    val stateMachine = inject<TradeStateMachine>()

    eventHandler<Trade>(name = "TRADE_INSERT") {
        onValidate { event ->
            val message = event.details
            verify {
                entityDb hasEntry Counterparty.ById(message.counterpartyId)
                entityDb hasEntry Instrument.ById(message.instrumentId)
            }
            ack()
        }
        onCommit { event ->
            val trade = event.details
            stateMachine.insert(trade)
            ack()
        }
    }
}
```

Create two data classes that will be used in the cancel and allocated event handlers:

* TradeCancelled
* TradeAllocated

Both classes have a single single field: **tradeId**.

TradeAllocated:

```kotlin
package global.genesis.trading_app.message.event

data class TradeAllocated(val tradeId: Long)
```

TradeCancelled:

```kotlin
package global.genesis.trading_app.message.event

data class TradeCancel(val tradeId: Long)
```

Create a new event handler called TRADE_CANCELLED to handle cancellations. Then integrate state machine in it.

```kotlin
eventHandler {
    eventHandler<TradeCancel>(name = "TRADE_CANCELLED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.CANCELLED
            }
            ack()
        }
    }
}
```

Create a new event handler called TRADE_ALLOCATED to handle completion. Integrate state machine in it.

```kotlin
eventHandler {
    eventHandler<TradeAllocated>(name = "TRADE_ALLOCATED") {
        onCommit { event ->
            val message = event.details
            stateMachine.modify(message.tradeId) { trade ->
                trade.tradeStatus = TradeStatus.ALLOCATED
            }
            ack()
        }
    }
}
```

Modify the TRADE_MODIFY event handler to use the state machine

```kotlin {5}
eventHandler {
    eventHandler<Trade>(name = "TRADE_MODIFY") {
        onCommit { event ->
            val trade = event.details
            stateMachine.modify(trade)
            ack()
        }
    }
}
```

Remove the TRADE_DELETE event handler

You want to manage the state of the trade, so remove the delete event handler. If a trade is incorrect and needs to be deleted, similar functionality can be achieved by cancelling the trade.

## Testing

### Create the unit tests

Create helper function to create Trade object which can be reused in tests

```kotlin
private fun setupTrade() = Trade {
    tradeId = 1
    counterpartyId = "1"
    instrumentId = "2"
}
```

Add 6 new unit tests to check the behaviour of the state machine :

Test to cancel a trade successfully:

```kotlin
    @Test
    fun `test cancel trade`(): Unit = runBlocking {
        val setupTrade = setupTrade()
        entityDb.insert(setupTrade)

        val message = Event(
            details = TradeCancel(1),
            messageType = "EVENT_TRADE_CANCELLED"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        result.assertedCast<EventReply.EventAck>()

        val trade = entityDb.get(Trade.ById(1))
        assertEquals(TradeStatus.CANCELLED, trade?.tradeStatus)
    }
```

Test to ensure you cannot cancel a trade that has already been cancelled: :

```kotlin
    @Test
    fun `test trying to cancel an already cancelled trade`(): Unit = runBlocking {
        val setupTrade = Trade {
            tradeId = 1
            counterpartyId = "1"
            instrumentId = "2"
            tradeStatus = TradeStatus.CANCELLED
        }
        entityDb.insert(setupTrade)

        val message = Event(
            details = TradeCancel(1),
            messageType = "EVENT_TRADE_CANCELLED"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        val eventNack = result.assertedCast<EventReply.EventNack>()
        assertThat(eventNack.error).containsExactly(
            StandardError(
                "INTERNAL_ERROR",
                "State CANCELLED not recognised"
            )
        )
    }
```

Test to check that we can allocate trade successfully:

```kotlin
    @Test
    fun `test allocated trade`(): Unit = runBlocking {
        val setupTrade = setupTrade()
        entityDb.insert(setupTrade)

        val message = Event(
            details = TradeAllocated(1),
            messageType = "EVENT_TRADE_ALLOCATED"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        result.assertedCast<EventReply.EventAck>()
        val trade = entityDb.get(Trade.ById(1))
        assertEquals(TradeStatus.ALLOCATED, trade?.tradeStatus)
    }
```

Test to check that you cannot allocate trade that has been cancelled:

```kotlin
    @Test
    fun `test trying to allocate a cancelled trade`(): Unit = runBlocking {
        val setupTrade = setupTrade()
        setupTrade.tradeStatus = TradeStatus.CANCELLED
        entityDb.insert(setupTrade)

        val message = Event(
            details = TradeAllocated(1),
            messageType = "EVENT_TRADE_ALLOCATED"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        val eventNack = result.assertedCast<EventReply.EventNack>()
        assertThat(eventNack.error).containsExactly(
            StandardError(
                "INTERNAL_ERROR",
                "Illegal transition: cannot transition from CANCELLED to ALLOCATED"
            )
        )
    }
```

Test to check that you can change the price of the trade when entered by TestUser, which executes onCommit logic from state machine:

```kotlin
    @Test
    fun `test trade by TestUser`(): Unit = runBlocking {
        val message = Event(
            details = Trade {
                tradeId = 1
                counterpartyId = "1"
                instrumentId = "2"
                price = 5.0
                enteredBy = "TestUser"
            },
            messageType = "EVENT_TRADE_INSERT"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        result.assertedCast<EventReply.EventAck>()

        val trade = entityDb.get(Trade.ById(1))
        assertEquals(10.0, trade?.price)
    }
```

test to check that you can transition from completed to cancelled:

```kotlin
    @Test
    fun `test transition from allocated to cancelled status`(): Unit = runBlocking {
        val setupTrade = setupTrade()
        setupTrade.tradeStatus = TradeStatus.ALLOCATED
        entityDb.insert(setupTrade)

        val message = Event(
            details = TradeCancel(1),
            messageType = "EVENT_TRADE_CANCELLED"
        )

        val result: EventReply? = messageClient.suspendRequest(message)

        result.assertedCast<EventReply.EventAck>()

        val trade = entityDb.get(Trade.ById(1))
        assertEquals(TradeStatus.CANCELLED, trade?.tradeStatus)
    }
```

### Run the tests

Run all unit tests to confirm they pass