---
id: extend-trade-view
title: Extending our trade view
sidebar_label: Extending our trade view
sidebar_position: 3

---

## Extend the new view

The positions app already has a view from running AppGen. Let's now extend this to join reference tables and supply joined fields.

We'll join to the INSTRUMENT and COUNTERPARTY tables so our view can serve up their fields as needed.

Firstly add the joins section within the TRADE_VIEW's block, which will add the joined tables and the fields to join them on:

```kotlin
  view ("TRADE_VIEW", TRADE) {

    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }
```

Now lets add joined table fields, note here we're using withPrefix to give the field a unique name:

<!-- TODO check output of AppGen has fields like this, else a line that we add it in as there are joined trades now -->
```kotlin
  view ("TRADE_VIEW", TRADE) {

    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }

    fields {
      TRADE.allFields()

      COUNTERPARTY.NAME withPrefix COUNTERPARTY
      INSTRUMENT.NAME withPrefix INSTRUMENT
      
    }
  }
```

In short, you will add INSTRUMENT_NAME and COUNTERPARTY_NAME to enhance the view with human readable values.

```kotlin
  view ("TRADE_VIEW", TRADE) {

    joins {
      joining(COUNTERPARTY) {
        on(TRADE.COUNTERPARTY_ID to COUNTERPARTY { COUNTERPARTY_ID })
      }
      joining(INSTRUMENT) {
        on(TRADE.INSTRUMENT_ID to INSTRUMENT { INSTRUMENT_ID })
      }
    }

    fields {
      TRADE.PRICE
      TRADE.QUANTITY
      TRADE.TRADE_DATETIME
      TRADE.SIDE
      TRADE.TRADE_ID
      COUNTERPARTY.NAME withPrefix COUNTERPARTY
      INSTRUMENT.NAME withPrefix INSTRUMENT
      derivedField("CONSIDERATION", DOUBLE) {
        // I: F2*H2
        withInput(TRADE.QUANTITY, TRADE.PRICE) { QUANTITY, PRICE ->
          if(QUANTITY == null) return@withInput null
          if(PRICE == null) return@withInput null
          QUANTITY * PRICE
        }
      }
    }
  }
```

Run `codegen:generateView` to make the new view ready for use (See below).

![](/img/generateView.png)

## Add the new view to the data server

Now go to the data server definition (inside the **-script-config** module). Replace the ALL_TRADES query in the data server with the new ENHANCED_TRADE_VIEW.

```kotlin
dataServer {

  query("ALL_TRADES", ENHANCED_TRADE_VIEW)
}
```

## Testing

Let's now create a unit test showing usage of the view repository generated by the code generation mechanism.

The purpose of the test is to prove you can look up data with the repo and retrieve the joined-up structure. We can show that we can:

* look up by keys
* perform get bulk from the main table

First you need to do the following:

1. Add the **db-test** dependency to the config module
```xml
<dependency>
    <groupId>global.genesis</groupId>
    <artifactId>genesis-dbtest</artifactId>
    <scope>test</scope>
</dependency>
```
2. Add a dependency on the **ref_data_app-config module** in pom file
```xml
<dependency>
    <groupId>global.genesis</groupId>
    <artifactId>ref_app_data-config</artifactId>
    <version>${ref_app_data.version}</version>
    <scope>test</scope>
</dependency>
```
3. Add a new test class to the config module called `EnhancedTradeViewTest.kt`
4. Add the genesis home folder with an empty txt file. This folder is needed for unit tests. 
5. Add TEST_DATA.csv to a data folder
```csv
#INSTRUMENT
INSTRUMENT_ID,NAME
1,FOO.L
2,BAR.L
#COUNTERPARTY
COUNTERPARTY_ID,COUNTERPARTY_LEI,NAME,
1,335800A8HK6JBITVPA30,Test Ltd,
2,655FG0324Q4LUVJJMS11,Testing AG,
```

Should look like below:

![](/img/view-test-folder-structure.png)

### Test class setup
```kotlin
package global.genesis

import global.genesis.db.util.AbstractDatabaseTest
import global.genesis.db.util.TestUtil
import global.genesis.dictionary.GenesisDictionary
import global.genesis.gen.dao.Trade
import global.genesis.gen.view.entity.EnhancedTradeView
import global.genesis.gen.view.repository.EnhancedTradeViewRepository
import org.joda.time.DateTime
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import javax.inject.Inject

class EnhancedTradeViewTest : AbstractDatabaseTest() {

    @Inject
    lateinit var enhancedTradeViewRepository: EnhancedTradeViewAsyncRepository

    override fun createMockDictionary(): GenesisDictionary = prodDictionary()

    @Before
    fun setup() {
        TestUtil.loadData(resolvePath("data/TEST_DATA.csv"), rxDb)
    }

    private fun buildTrade(tradeId: Long, now: DateTime = DateTime.now()) =
        Trade.builder()
            .setTradeDatetime(now)
            .setCounterpartyId("2") // COUNTERPARTY_NAME = "Testing AG"
            .setInstrumentId("1")   // INSTRUMENT_NAME = "FOO.L"
            .setPrice(12.0)
            .setQuantity(100)
            .setSide("BUY")
            .setTradeId(tradeId)
            .build()
}
```

### Test get single trade by ID
```kotlin
@Test
fun `test get single trade by id`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)

    rxEntityDb.insert(trade).blockingGet()

    val tradeView = enhancedTradeViewRepository.get(EnhancedTradeView.ById(1)).blockingGet()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```

### Test get single trade with getBulk
```kotlin
@Test
fun `test with single trade - use getBulk`() {
    val now = DateTime.now()
    val trade = buildTrade(1L, now)

    rxEntityDb.insert(trade).blockingGet()

    val tradeViewList = enhancedTradeViewRepository.getBulk()
        .toList()
        .blockingGet()

    assertEquals(1, tradeViewList.size)

    val tradeView = tradeViewList.first()
    assertEquals("Testing AG", tradeView.counterpartyName)
    assertEquals("FOO.L", tradeView.instrumentName)
    assertEquals(now, tradeView.tradeDatetime)
    assertEquals(12.0, tradeView.price)
    assertEquals(100L, tradeView.quantity)
    assertEquals("BUY", tradeView.side)
}
```

### Test get multiple trades
```kotlin
@Test
fun `test get multiple trades`() {
    rxEntityDb.insertAll(
        buildTrade(1),
        buildTrade(2),
        buildTrade(3),
        buildTrade(4),
        buildTrade(5),
    ).blockingGet()

    val count = enhancedTradeViewRepository.getBulk().count().blockingGet()

    assertEquals(5, count)
}
```