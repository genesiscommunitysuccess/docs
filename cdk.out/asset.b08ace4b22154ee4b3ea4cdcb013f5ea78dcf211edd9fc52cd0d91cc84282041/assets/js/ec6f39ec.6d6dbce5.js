"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[37235],{50154:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return p}});var o=n(87462),a=n(63366),l=(n(67294),n(3905)),i=(n(61839),["components"]),r={title:"Consolidator - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","consolidator","basics"],tags:["server","consolidator","basics"]},s=void 0,u={unversionedId:"server/consolidator/basics",id:"server/consolidator/basics",title:"Consolidator - Basics",description:"Introduction | Basics |  Advanced | Examples | Configuring runtime | Testing",source:"@site/docs/03_server/07_consolidator/02_basics.md",sourceDirName:"03_server/07_consolidator",slug:"/server/consolidator/basics",permalink:"/next/server/consolidator/basics",draft:!1,tags:[{label:"server",permalink:"/next/tags/server"},{label:"consolidator",permalink:"/next/tags/consolidator"},{label:"basics",permalink:"/next/tags/basics"}],version:"current",sidebarPosition:2,frontMatter:{title:"Consolidator - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","consolidator","basics"],tags:["server","consolidator","basics"]},sidebar:"serverModulesSidebar",previous:{title:"Introduction",permalink:"/next/server/consolidator/introduction"},next:{title:"Advanced",permalink:"/next/server/consolidator/advanced"}},d={},p=[{value:"Elements of a Consolidator",id:"elements-of-a-consolidator",level:2},{value:"config block (optional)",id:"config-block-optional",level:3},{value:"select block",id:"select-block",level:3},{value:"logging",id:"logging",level:3},{value:"onCommit block (optional)",id:"oncommit-block-optional",level:3},{value:"groupBy into syntax",id:"groupby-into-syntax",level:3},{value:"groupBy",id:"groupby",level:3},{value:"into",id:"into",level:4},{value:"lookup",id:"lookup",level:4},{value:"build",id:"build",level:4},{value:"indexScan",id:"indexscan",level:3},{value:"where block (optional)",id:"where-block-optional",level:3},{value:"reprocessSchedule block (optional)",id:"reprocessschedule-block-optional",level:3},{value:"Functions",id:"functions",level:2},{value:"Function examples",id:"function-examples",level:3},{value:"Assigning functions to fields",id:"assigning-functions-to-fields",level:3},{value:"Transformations on functions",id:"transformations-on-functions",level:3},{value:"onlyIf",id:"onlyif",level:3},{value:"withInitialValue",id:"withinitialvalue",level:3},{value:"pivotBy",id:"pivotby",level:3},{value:"Shared function definitions",id:"shared-function-definitions",level:3},{value:"index scans",id:"index-scans",level:3},{value:"Starting and killing the process",id:"starting-and-killing-the-process",level:2},{value:"The startProcess command (cold start)",id:"the-startprocess-command-cold-start",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",t)}},m=c("Tabs"),k=c("TabItem"),h={toc:p};function g(e){var t=e.components,n=(0,a.Z)(e,i);return(0,l.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/introduction"},"Introduction")," | ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/basics"},"Basics")," |  ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/advanced"},"Advanced")," | ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/examples"},"Examples")," | ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/configuring-runtime"},"Configuring runtime")," | ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/testing"},"Testing")),(0,l.kt)("p",null,"You define a Consolidator service in a ",(0,l.kt)("strong",{parentName:"p"},"consolidator.kts")," file. Within the file, you can define as many Consolidators as you like. Each one is specified in a ",(0,l.kt)("inlineCode",{parentName:"p"},"consolidator")," block of code. "),(0,l.kt)("p",null,"Here is an example of the simplest Consolidator you could define:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"consolidator(TRADE, ORDER) {\n    select {\n        ORDER {\n            sum { price * quantity } into TOTAL_NOTIONAL\n            count() into TRADE_COUNT\n        }\n    }\n    groupBy { Order.ById(orderId) } \n}\n")),(0,l.kt)("p",null,"So, what was going on there?"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The Consolidator is listening to the ",(0,l.kt)("inlineCode",{parentName:"li"},"TRADE")," table."),(0,l.kt)("li",{parentName:"ul"},"It is publishing its aggregation to the ",(0,l.kt)("inlineCode",{parentName:"li"},"ORDER")," table."),(0,l.kt)("li",{parentName:"ul"},"It is grouping its aggregation by the field ",(0,l.kt)("inlineCode",{parentName:"li"},"orderID"),"."),(0,l.kt)("li",{parentName:"ul"},"It is counting the number of trades into ",(0,l.kt)("inlineCode",{parentName:"li"},"TRADE_COUNT")," and calculating price x quantity into ",(0,l.kt)("inlineCode",{parentName:"li"},"TOTAL_NOTIONAL"),". ")),(0,l.kt)("h2",{id:"elements-of-a-consolidator"},"Elements of a Consolidator"),(0,l.kt)("p",null,"In each ",(0,l.kt)("inlineCode",{parentName:"p"},"consolidator")," block, you must at least provide:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a name"),(0,l.kt)("li",{parentName:"ul"},"an input table or view"),(0,l.kt)("li",{parentName:"ul"},"an output table")),(0,l.kt)("p",null,"In most cases, you will need a lot more than that. Let us look at the elements you can use to create a sophisticated, effective Consolidator."),(0,l.kt)("p",null,"The empty structure below shows the optional and mandatory code blocks in a single ",(0,l.kt)("inlineCode",{parentName:"p"},"consolidator")," block.",(0,l.kt)("br",{parentName:"p"}),"\n","Comments are included to provide further information:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'consolidators {\n    config {\n        // optional file-level configuration\n    }\n    // define a consolidation\n    consolidator("NAME", INPUT_TABLE_OR_VIEW, OUTPUT_TABLE) {\n        config {\n            // optional consolidation configuration\n        }\n        select {\n            // select block\n        }\n        onCommit {\n            // optional onCommit block\n        }\n        groupBy {\n            // groupBy block\n        } into {\n            //\n        }\n        where {\n            // predicate\n        }\n        indexScanOn {\n            // on demand index scan\n        }\n        reprocessSchedule {\n            //\n        }\n    }\n}\n')),(0,l.kt)("p",null,"Now we shall look at each of the possible code blocks in more detail."),(0,l.kt)("h3",{id:"config-block-optional"},"config block (optional)"),(0,l.kt)("p",null,"The config block is available at both the file and Consolidator level. File-level configuration will overwrite default\nproperties, and Consolidator properties will overwrite both."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Property"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"),(0,l.kt)("th",{parentName:"tr",align:null},"Supports Values"),(0,l.kt)("th",{parentName:"tr",align:null},"Default Value"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultLogLevel"),(0,l.kt)("td",{parentName:"tr",align:null},"the default log level for the Consolidator"),(0,l.kt)("td",{parentName:"tr",align:null},"TRACE, DEBUG, INFO, WARN, ERROR"),(0,l.kt)("td",{parentName:"tr",align:null},"TRACE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"onNotFound"),(0,l.kt)("td",{parentName:"tr",align:null},"what to do if an output record is not found"),(0,l.kt)("td",{parentName:"tr",align:null},"BUILD, WARN, IGNORE, FAIL, DEFAULT"),(0,l.kt)("td",{parentName:"tr",align:null},"TBC")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"batchingPeriod"),(0,l.kt)("td",{parentName:"tr",align:null},"the time in ms before writing to the database"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"TBC")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"ignoreIndexScan"),(0,l.kt)("td",{parentName:"tr",align:null},"disables index scans"),(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"TBC")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"defaultErrorHandling"),(0,l.kt)("td",{parentName:"tr",align:null},"what to do if an exception is thrown"),(0,l.kt)("td",{parentName:"tr",align:null},"IGNORE, WARN, FAIL"),(0,l.kt)("td",{parentName:"tr",align:null},"TBC")))),(0,l.kt)("h3",{id:"select-block"},"select block"),(0,l.kt)("p",null,"In the select block, you can specify functions and outputs, for example:"),(0,l.kt)(m,{defaultValue:"tables",values:[{label:"Tables",value:"tables"},{label:"Classes",value:"classes"}],mdxType:"Tabs"},(0,l.kt)(k,{value:"tables",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select {\n    // add the output table here for a more concise syntax\n    // this will go after kotlin supports multiple receivers\n    COMMISSION_AND_FEES_SUMMARY {\n        sum { feeAmount } into FEE_AMOUNT\n        sum { originalFeeAmount } into ORIGINAL_FEE_AMOUNT\n        sum { splitFeeAmount } into SPLIT_FEE_AMOUNT\n    }\n}\n"))),(0,l.kt)(k,{value:"classes",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"select {\n    sum { feeAmount } into CommissionAndFeesSummary::feeAmount\n    sum { originalFeeAmount } into CommissionAndFeesSummary::originalFeeAmount\n    sum { splitFeeAmount } into CommissionAndFeesSummary::splitFeeAmount\n}\n")))),(0,l.kt)("h3",{id:"logging"},"logging"),(0,l.kt)("p",null,"For debugging purposes, the ",(0,l.kt)("inlineCode",{parentName:"p"},"select")," block also supports logging. By default, the Consolidator logs all events with default level ",(0,l.kt)("strong",{parentName:"p"},"TRACE"),", but this can be overwritten with custom messages. To do this, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"logJoin"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"logLeave")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"logNoop")," blocks:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'select {\n    ...\n    logJoin { LOG.info("row joined", input) }\n    logLeave { LOG.info("row left", input) }\n    logNoop { LOG.info("new row: {}, old row: {}", newInput, oldInput) }\n}\n')),(0,l.kt)("h3",{id:"oncommit-block-optional"},"onCommit block (optional)"),(0,l.kt)("p",null,"This block is optional. In the ",(0,l.kt)("inlineCode",{parentName:"p"},"onCommit")," block, you can amend the output row, after all the functions have been\napplied, but before it is written to the database. In the ",(0,l.kt)("inlineCode",{parentName:"p"},"onCommit")," block, you have access to both the ",(0,l.kt)("inlineCode",{parentName:"p"},"input"),"\nand the ",(0,l.kt)("inlineCode",{parentName:"p"},"output")," objects. The ",(0,l.kt)("inlineCode",{parentName:"p"},"input")," property can be any one of the input rows picked up during the consolidation,\nso this should be handled with care."),(0,l.kt)("p",null,"This block can be useful to do further calculations based on the consolidated values, for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"onCommit {\n    val accruedInterest = if (input.isDirtyPrice) input.accruedInterest else 0.0\n    val netAmount = input.notional + accruedInterest\n    output.netAmount = when (input.side) {\n        Side.BUY -> netAmount + output.totalTransactionCosts\n        Side.SELL -> netAmount - output.totalTransactionCosts\n    }\n}\n")),(0,l.kt)("h3",{id:"groupby-into-syntax"},"groupBy into syntax"),(0,l.kt)("p",null,"The syntax of ",(0,l.kt)("inlineCode",{parentName:"p"},"groupBy")," is significantly different for standard Consolidators and object Consolidators.\nFor object Consolidators, table syntax is more complex, as records need to be loaded and created. Also, the table syntax supports\nindex scans, which need to be configured."),(0,l.kt)(m,{defaultValue:"tables",values:[{label:"Tables",value:"tables"},{label:"Classes",value:"classes"}],mdxType:"Tabs"},(0,l.kt)(k,{value:"tables",mdxType:"TabItem"},(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"groupBy"),"-",(0,l.kt)("inlineCode",{parentName:"p"},"into")," syntax determines:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"how records are grouped ",(0,l.kt)("inlineCode",{parentName:"li"},"groupBy { ... } ")),(0,l.kt)("li",{parentName:"ul"},"how the Consolidator interacts with the database ",(0,l.kt)("inlineCode",{parentName:"li"},"into { ... }"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"how output records are loaded from the database ",(0,l.kt)("inlineCode",{parentName:"li"},"into { lookup { ... } }")),(0,l.kt)("li",{parentName:"ul"},"how output records are built when no record is found in the database ",(0,l.kt)("inlineCode",{parentName:"li"},"into { build { ... } }")),(0,l.kt)("li",{parentName:"ul"},"how to look up records after an index scan ",(0,l.kt)("inlineCode",{parentName:"li"},"into { indexScan { ... } }"))))),(0,l.kt)("p",null,"Syntax:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { /* return group id*/ } into {\n    lookup { /* return unique index on output table */ }\n    build { /* return new output record */ }\n    indexScan { /* return index on input table */ }\n}\n"))),(0,l.kt)(k,{value:"classes",mdxType:"TabItem"},(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"groupBy"),"-",(0,l.kt)("inlineCode",{parentName:"p"},"into")," syntax determines:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"how records are grouped ",(0,l.kt)("inlineCode",{parentName:"li"},"groupBy { ... } ")),(0,l.kt)("li",{parentName:"ul"},"how output records are constructed ",(0,l.kt)("inlineCode",{parentName:"li"},"into { ... }"))),(0,l.kt)("p",null,"Syntax:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { /* return group id*/ } into { /* return new output record */ }\n")))),(0,l.kt)("h3",{id:"groupby"},"groupBy"),(0,l.kt)("p",null,"The code you put in your ",(0,l.kt)("inlineCode",{parentName:"p"},"groupBy")," block determines the ",(0,l.kt)("inlineCode",{parentName:"p"},"groupId"),". That is important, because the ",(0,l.kt)("inlineCode",{parentName:"p"},"groupId")," determines the level at which records are aggregated. For example, you can set up the code to group by instrument; in this case, the calculation would then aggregate per instrument."),(0,l.kt)("p",null,"The result of the ",(0,l.kt)("inlineCode",{parentName:"p"},"groupBy")," block can be any kotlin type, as long as it can be used to uniquely identify a grouping. That is, as long as the result has a consistent ",(0,l.kt)("inlineCode",{parentName:"p"},"equals")," method. This includes but is not limited to:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"single fields from the input table:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { allocationId }\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a type safe tuple of input table fields:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { tuple(allocationId, feeGroup) }\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a string concatenation of input table fields:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { group(allocationId, feeGroup) }\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"unique index entries on the output table (table only):")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { CommissionAndFeesSummary.ByAllocationId(allocationId, feeGroup) }\n")),(0,l.kt)("p",null,"Consolidations support single or multiple groupings. Multiple groupings are useful when aggregating data by different levels: for example, where you want to calculate trade totals per currency as well as by counterparty."),(0,l.kt)("h4",{id:"into"},"into"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"into")," statement is different for standard and object Consolidators:"),(0,l.kt)(m,{defaultValue:"tables",values:[{label:"Tables",value:"tables"},{label:"Classes",value:"classes"}],mdxType:"Tabs"},(0,l.kt)(k,{value:"tables",mdxType:"TabItem"},(0,l.kt)("h4",{id:"lookup"},"lookup"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"lookup")," block is optional when grouping by a unique index on the output table. In all other cases, the lookup\nshould be defined. In this block, you have access to the ",(0,l.kt)("inlineCode",{parentName:"p"},"input")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"groupId")," properties."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { tradeId } into {\n    lookup { Trade.ById(groupId) }\n}\n")),(0,l.kt)("h4",{id:"build"},"build"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"build")," block is required if the output table has non-null fields without default values."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { Trade.ById(tradeId) } into {\n    build {\n        Trade {\n            tradeId = groupId.tradeId\n            feeAmount = input.feeAmount ?: 0\n        }\n    }\n}\n")),(0,l.kt)("h3",{id:"indexscan"},"indexScan"),(0,l.kt)("p",null,"If any of the functions triggers an index scan, the Consolidator needs to know which records are affected. ",(0,l.kt)("inlineCode",{parentName:"p"},"indexScan")," will\ntell the Consolidator how to do that. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { Order.ById(orderid) } into {\n    indexScan { Trade.ByOrderId(groupId.orderId) }\n}\n"))),(0,l.kt)(k,{value:"classes",mdxType:"TabItem"},(0,l.kt)("p",null,"Consolidator objects need to be able to build output objects on demand. There is no need to interact with the\ndatabase at this point."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"groupBy { orderId } into {\n    Order {\n        orderId = groupId\n    }\n}\n")))),(0,l.kt)("h3",{id:"where-block-optional"},"where block (optional)"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," block will filter records prior to consolidation. There are two modes for this filter. In the default mode,\nthe consolidation events will be modified, depending on the predicate. This means that a modify event might appear as\nan insert or delete."),(0,l.kt)("p",null,"example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"where {\n    quantity > 1000\n}\n")),(0,l.kt)("p",null,"Optionally, the where block takes an ",(0,l.kt)("inlineCode",{parentName:"p"},"ignore")," parameter that will cause it to ignore certain records. Any\nrecords matching the qualifications specified will be completely ignored."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"where(ignore = true) {\n    tradeDate < today()\n}\n")),(0,l.kt)("h3",{id:"reprocessschedule-block-optional"},"reprocessSchedule block (optional)"),(0,l.kt)("p",null,"Some consolidations might require periodic reprocessing of data. This will trigger a ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/basics/#the-startprocess-command-cold-start"},"cold start")," on a selected range of data."),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("p",null,"Functions are the base building blocks of the select statement."),(0,l.kt)("p",null,"All functions except for for ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," require an input. With ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," input is optional.\nFor the required input, use the syntax ",(0,l.kt)("inlineCode",{parentName:"p"},"sum { feeAmount }"),".\nWithin the curly brackets of the function, you can access all fields on the row, and you can use any kotlin operation on the row. The function will be applied over the result, unless the result is null, in which case it will be ignored."),(0,l.kt)("h3",{id:"function-examples"},"Function examples"),(0,l.kt)("p",null,"There is a full reference of functions in the ",(0,l.kt)("a",{parentName:"p",href:"/server/consolidator/advanced/"},"Advanced")," page on Consolidators."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { feeAmount }                   // sums the FEE_AMOUNT\nsum { feeAmount + otherAmount }     // sums the total of FEE_AMOUNT plus OTHER_AMOUNT\nsum { feeAmount ?: otherAmount }    // sum FEE_AMOUNT or OTHER_AMOUNT if FEE_AMOUNT is null\n// etc.\n")),(0,l.kt)("h3",{id:"assigning-functions-to-fields"},"Assigning functions to fields"),(0,l.kt)("p",null,"After a function is defined, its output can be directed to an output field. To do this, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"into")," keyword.\nNote that functions can only be applied to fields that match in type. For example, you can only assign ",(0,l.kt)("inlineCode",{parentName:"p"},"Double")," value\nto a ",(0,l.kt)("inlineCode",{parentName:"p"},"DOUBLE")," field."),(0,l.kt)(m,{defaultValue:"tables",values:[{label:"Tables",value:"tables"},{label:"Classes",value:"classes"}],mdxType:"Tabs"},(0,l.kt)(k,{value:"tables",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { feeAmount } into FEE_AMOUNT\nsum { originalFeeAmount } into ORIGINAL_FEE_AMOUNT\nsum { splitFeeAmount } into SPLIT_FEE_AMOUNT\n"))),(0,l.kt)(k,{value:"classes",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { feeAmount } into Order::feeAmount\nsum { originalFeeAmount } into Order::originalFeeAmount\nsum { splitFeeAmount } into Order::splitFeeAmount\n")))),(0,l.kt)("h3",{id:"transformations-on-functions"},"Transformations on functions"),(0,l.kt)("p",null,"The Consolidator also supports higher-level functions; this is where you can apply a transformation on the function,\nbefore it is assigned."),(0,l.kt)("h3",{id:"onlyif"},"onlyIf"),(0,l.kt)("p",null,"Where this is present, the function only applies to rows that meet the condition specified, for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { feeAmount } onlyIf { feeGroup == FeeGroup.COMMISSION } into TOTAL_COMMISSION\n")),(0,l.kt)("h3",{id:"withinitialvalue"},"withInitialValue"),(0,l.kt)("p",null,"Some functions support an initial value. Within this context, you can access the first input row, as well as the output\nobject, for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { -feeAmount } withInitialValue { output.expectedFees } into OUTSTANDING_FEES\n")),(0,l.kt)("h3",{id:"pivotby"},"pivotBy"),(0,l.kt)("p",null,"This function can direct a function result across different columns, and change the ",(0,l.kt)("inlineCode",{parentName:"p"},"into")," keyword. Within the ",(0,l.kt)("inlineCode",{parentName:"p"},"into"),"\ntag, the ",(0,l.kt)("inlineCode",{parentName:"p"},"pivot")," property will contain the value of the value returned in the ",(0,l.kt)("inlineCode",{parentName:"p"},"pivotBy { ... }")," tag."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sum { feeAmount } pivotBy { feeGroup } into {\n    when (pivot) {\n        FeeGroup.STAMP -> TOTAL_STAMP\n        FeeGroup.COMMISSION -> TOTAL_COMMISSION\n        FeeGroup.FEE -> TOTAL_FEES\n        FeeGroup.LEVY -> TOTAL_LEVY\n        FeeGroup.TAX -> TOTAL_TAX\n        FeeGroup.OTHER -> TOTAL_OTHER\n        FeeGroup.LOCAL -> TOTAL_LOCAL\n        FeeGroup.CHARGE -> TOTAL_CHARGE\n        FeeGroup.RESEARCH -> TOTAL_RESEARCH\n    }\n}\n")),(0,l.kt)("h3",{id:"shared-function-definitions"},"Shared function definitions"),(0,l.kt)("p",null,"Function definitions can also be assigned to variables and assigned to multiple outputs, for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val feeSum = sum { feeAmount }\nfeeSum into TOTAL_FEES\nfeeSum onlyIf { feeGroup == FeeGroup.COMMISSION } into TOTAL_COMMISSION\n")),(0,l.kt)("h3",{id:"index-scans"},"index scans"),(0,l.kt)("p",null,"Functions can sometimes trigger an index scan. This is when a Consolidator needs to re-read previously consolidated rows\nin order to calculate the correct value. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For some functions, this is never required: for example, ",(0,l.kt)("inlineCode",{parentName:"li"},"sum")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"count"),"."),(0,l.kt)("li",{parentName:"ul"},"For some functions, it is required sometimes: for example, ",(0,l.kt)("inlineCode",{parentName:"li"},"min")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"max"),"."),(0,l.kt)("li",{parentName:"ul"},"For some functions, it is always required: for example, ",(0,l.kt)("inlineCode",{parentName:"li"},"stDev"),".")),(0,l.kt)("h2",{id:"starting-and-killing-the-process"},"Starting and killing the process"),(0,l.kt)("p",null,"All Genesis processes can be started or killed using the ",(0,l.kt)("inlineCode",{parentName:"p"},"startServer")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"killServer")," commands. But here's the thing; if the Consolidator process stops for any reason, you should almost certainly perform a cold start when you restart the process. This ensures that any changes to data while the process was not running are properly recalculated before any real-time calculations are triggered."),(0,l.kt)("admonition",{type:"warning"},(0,l.kt)("p",{parentName:"admonition"},"If you simply restart the Consolidator process, then any changes to data that occurred while the process was not running will not be recalculated. Got that? The changed data will not be recalculated.")),(0,l.kt)("h3",{id:"the-startprocess-command-cold-start"},"The startProcess command (cold start)"),(0,l.kt)("p",null,"A cold start avoids the danger of losing your calculated data. To make a cold start, run the command "),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"startProcess --coldStart")),(0,l.kt)("p",null,"This consolidates all records in the system before starting the real-time event-driven consolidations. "),(0,l.kt)("p",null,"At the beginning of a cold start, all fields in ",(0,l.kt)("inlineCode",{parentName:"p"},"consolidationFields")," of the consolidation table are zeroed (or deleted, if transient) before initiating the re-consolidation of all the records in the database."),(0,l.kt)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,l.kt)("p",null,"You can set the default logging level for all the Consolidators in your ",(0,l.kt)("em",{parentName:"p"},"application"),(0,l.kt)("strong",{parentName:"p"},"-consolidator.kts")," file using a config statement at the beginning.\nHowever, within any individual Consolidator, you can also set a logging level that overrides this setting.\nIf a Consolidator is not functioning as expected, raise its logging level to INFO, or even higher.\nLet's see a very simple example. Here the default logging level has been set to INFO. However, Consolidator B has its own loglevel, ",(0,l.kt)("inlineCode",{parentName:"p"},"DEBUG"),", which overrides the file-level setting:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'consolidators {\n    config {\n        logLevel = INFO\n    }\n    consolidator ("A", ...) {\n        ...     \n    }\n    consolidator ("B", ...) {\n        config {\n            logLevel = DEBUG\n        }\n        ...\n    }\n}\n')))}g.isMDXComponent=!0}}]);