"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[97588],{81562:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return c}});var n=a(87462),r=a(63366),s=(a(67294),a(3905)),i=(a(61839),["components"]),o={title:"DB Streaming Out - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","integration","database streaming out","basics"],tags:["server","integration","database streaming out","basics"]},l=void 0,d={unversionedId:"server/integration/database-streaming-out/basics",id:"version-2022.3/server/integration/database-streaming-out/basics",title:"DB Streaming Out - Basics",description:"Introduction  | Basics | Advanced | Examples | Configuring runtime | Testing",source:"@site/versioned_docs/version-2022.3/03_server/10_integration/02_database-streaming-out/02_basics.md",sourceDirName:"03_server/10_integration/02_database-streaming-out",slug:"/server/integration/database-streaming-out/basics",permalink:"/server/integration/database-streaming-out/basics",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"integration",permalink:"/tags/integration"},{label:"database streaming out",permalink:"/tags/database-streaming-out"},{label:"basics",permalink:"/tags/basics"}],version:"2022.3",sidebarPosition:2,frontMatter:{title:"DB Streaming Out - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","integration","database streaming out","basics"],tags:["server","integration","database streaming out","basics"]},sidebar:"serverModulesSidebar",previous:{title:"Introduction",permalink:"/server/integration/database-streaming-out/introduction"},next:{title:"Advanced",permalink:"/server/integration/database-streaming-out/advanced"}},p={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Process definition",id:"process-definition",level:3},{value:"Process arguments",id:"process-arguments",level:3},{value:"Table joins",id:"table-joins",level:3},{value:"Stored procedures",id:"stored-procedures",level:3},{value:"SQL Procedures",id:"sql-procedures",level:2},{value:"Encrypting user and passwords",id:"encrypting-user-and-passwords",level:3}],u={toc:c};function m(e){var t=e.components,a=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/introduction"},"Introduction"),"  | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/basics"},"Basics")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/advanced"},"Advanced")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/examples"},"Examples")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/configuring-runtime"},"Configuring runtime")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/testing"},"Testing")),(0,s.kt)("h2",{id:"configuration"},"Configuration"),(0,s.kt)("p",null,"You can configure GenesisToDb in an xml file called ",(0,s.kt)("em",{parentName:"p"},"application"),(0,s.kt)("strong",{parentName:"p"},"-genesistodb.xml"),". This must be located in your application's ",(0,s.kt)("strong",{parentName:"p"},"resources/cfg")," directory."),(0,s.kt)("p",null,"The outline of this configuration file is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<genesisToDb xmlns:xi="http://www.w3.org/2001/XInclude">\n    <preExpression>\n        \x3c!-- optional dynamic groovy code goes here --\x3e\n    </preExpression>\n    <options>\n        \x3c!-- database configuration options go here --\x3e\n    </options>\n    <databaseStream>\n        \x3c!-- stream configuration goes here --\x3e\n    </databaseStream>\n</genesisToDb>\n')),(0,s.kt)("h3",{id:"process-definition"},"Process definition"),(0,s.kt)("p",null,"The process definition is made up of several fields that set up the main configuration of the process:"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"preExpression")," defines dynamic groovy code (methods, imports, etc.). You can add to this module for further usage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},"<preExpression>\n    <![CDATA[\n\n        import global.genesis.commons.model.GenesisSet\n        import global.genesis.db.DbRecord\n\n        /*\n        * Get market records for the given instrument id\n        */\n\n        def getMarkets(instrumentId) {\n            def findRec = new DbRecord('MARKET_INSTRUMENT')\n            findRec.setString('INSTRUMENT_ID', instrumentId)\n            List<DbRecord> recs = db.getRange(findRec, 'MARKET_INSTRUMENT_BY_INSTRUMENT_ID_MARKET_ID').get()\n            return recs\n        }\n\n    ]]>\n</preExpression>\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"options")," is a field container that represents the basic behaviour and database configuration of the process."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"databaseType")," can be set to ORACLE, MSSQL or POSTGRES."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"url")," represents the database url to connect to using the JDBC driver. The url definition specifies the ",(0,s.kt)("inlineCode",{parentName:"li"},"databaseType"),":",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"POSTGRES - ",(0,s.kt)("inlineCode",{parentName:"li"},"<url>jdbc:postgresql://IP_ADDRESS:PORT/DATABASE_NAME</url>")),(0,s.kt)("li",{parentName:"ul"},"MSSQL - ",(0,s.kt)("inlineCode",{parentName:"li"},"<url>jdbc:sqlserver://IP_ADDRESS:PORT;databaseName=DATABASE_NAME;</url>")),(0,s.kt)("li",{parentName:"ul"},"ORACLE - ",(0,s.kt)("inlineCode",{parentName:"li"},"<url>jdbc:oracle:thin:@IP_ADDRESS:PORT:DATABASE_NAME</url>")))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"user")," user from RDBMS. Encrypted by command line tool ",(0,s.kt)("inlineCode",{parentName:"li"},"encryptUserPass"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"password")," password from RDBMS. Encrypted by command line tool ",(0,s.kt)("inlineCode",{parentName:"li"},"encryptUserPass"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"dbMinConnections")," represents the minimum number of RDBMS connections that will be created on startup inside each pool partition. Default: 10."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"dbMaxConnections")," sets the maximum number of connections to be created by the RDBMS connection pool. Default: 10."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"maxOutstanding")," sets the threshold for the internal work queue that triggers the process to start logging warnings. Example use case: there are more than ",(0,s.kt)("inlineCode",{parentName:"li"},"maxOutstanding")," records pending to be inserted in the RDBMS. Default: 10000.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},"<options>\n    <databaseType>ORACLE</databaseType>\n    <url>jdbc:oracle:thin:@host.ad.company.com:1521:oracleSid</url>\n    <user>6487f8a8b25986efa34a4906332e7998606acd235b06b7ae2e8acfc0c31</user>\n    <password>db3b7fc7009c86cfa1b8e8b37811594094535b4df9c57b61a9bad169332e1f7c</password>\n    <dbMinConnections>10</dbMinConnections>\n    <dbMaxConnections>10</dbMaxConnections>\n    <maxOutstanding>100000</maxOutstanding>\n</options>\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"databaseStream")," represents one stream from Genesis to the RDBMS. It contains the necessary logic to join different tables if necessary and it sets the fields to be inserted or modified in the RDBMS. It also specifies the stored procedures calls to be used and the parameters ordering used to call them. You can define as many databaseStreams as you want. It has a name attribute to databaseStreams from each other."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tables"),' Similar to DataServer configuration, you can specify a seed Genesis table with its seed key and join it to other Genesis tables so you can get all the data you need. GenesisToDb works with a timestamp system, and it can keep track of the last timestamp processed for each record, so the seedKey should be a timestamp field (e.g. "TIMESTAMP", "DATE_TIMESTAMP", "CREATED_AT", etc.) if you want to take full advantage of GenesisToDb capabilities.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"fields"),' is the representation of the SQL row to be written inside the RDBMS. Parameters are ordered by number from first to last. In the example, we could associate "TRADE_ID" with parameter 1, "TRADE_QUANTITY" with parameter 2, and so on.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"proc")," contains the store procedure calls for each of the use cases: insert, modify and delete. The standard JDBC call to RDBMS store procedures is standardised as ",(0,s.kt)("em",{parentName:"li"},"{call procedure(param1,param2,param3)}"),". The configuration is flexible and allows you to change the parameter order depending on the current call. A stored procedure could be called like this: ",(0,s.kt)("em",{parentName:"li"},"insertIdAndClientName(1,3)")," and ",(0,s.kt)("em",{parentName:"li"},"modifyQuantity(2)"),".")),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},'<databaseStream name="ALL_TRADES">\n  <tables>\n    <table name="TRADE"\n           alias="t"\n           seedKey="TRADE_BY_TIMESTAMP" />\n  </tables>\n  <fields>\n    <![CDATA[\n            sproc.setParameter("id", t.getString("TRADE_ID"))\n            sproc.setParameter("instrumentid", t.getString("INSTRUMENT_ID"))\n            sproc.setParameter("counterpartyid", t.getString("COUNTERPARTY_ID"))\n            sproc.setParameter("amount", t.getInteger("QUANTITY"))\n            sproc.setParameter("side", t.getString("SIDE"))\n            sproc.setParameter("price", t.getDouble("PRICE"))\n            sproc.setParameter("date", t.getLong("TRADE_DATETIME"))\n            sproc.setParameter("trader", t.getString("ENTERED_BY"))\n            sproc.setParameter("status", t.getString("TRADE_STATUS"))\n            ]]>\n  </fields>\n  <proc>\n    <insert>\n      <![CDATA[\n                {call inserttrade(1,2,3,4,5,6,7,8,9)}\n                ]]>\n    </insert>\n    <modify>\n      <![CDATA[\n                {call updatetrade(1,2,3,4,5,6,7,8,9)}\n                ]]>\n    </modify>\n    <delete>\n      <![CDATA[\n                {call deletetrade(1)}\n                ]]>\n    </delete>\n  </proc>\n</databaseStream>\n')),(0,s.kt)("h3",{id:"process-arguments"},"Process arguments"),(0,s.kt)("p",null,"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"startProcess")," to start the GenesisToDb process (see ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/database-streaming-out/configuring-runtime/"},"Configuring Runtime")," for more information on how to configure this). This can take two additional optional arguments:"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"--clearText")," can be passed if you want to use clear text user and passwords in the configuration file, instead of encrypted ones."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"--force")," if passed to the process, this  attempts to re-insert every trade found in our Genesis table to the RDBMS, ignoring previously inserted records."),(0,s.kt)("p",null,"For more information regarding process configuration please see the dedicated page on ",(0,s.kt)("a",{parentName:"p",href:"/server/configuring-runtime/processes"},"Processes"),"."),(0,s.kt)("h3",{id:"table-joins"},"Table joins"),(0,s.kt)("p",null,"The process keeps track of the last record timestamp, so if you want to avoid reloading all records in Genesis to the RDBMS, it is very important to use a TIMESTAMP seedKey in order to make this work properly."),(0,s.kt)("h3",{id:"stored-procedures"},"Stored procedures"),(0,s.kt)("p",null,"You must have a separate table for each database stream."),(0,s.kt)("p",null,"Each database must have a table that can hold records as specified in the ",(0,s.kt)("strong",{parentName:"p"},"fields")," field. So, following the previous example with TRADE_ID, TRADE_QUANTIY, CLIENT_NAME and CURRENCY_DESCRIPTION, you must have an SQL table with those column names and matching types. Matching types in this example could be: varchar(50), int, varchar(50) and varchar(50)."),(0,s.kt)("p",null,"A stored procedure is a prepared SQL code that can be saved, allowing for it to be reused many times. You can also pass parameters to a stored procedure, so that the stored procedure can act based on the parameter value(s) that is passed."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"The stored procedures for insert, modify and delete should also be created beforehand"),". This process does not create any store procedures; it just attempts to call already existing ones. Therefore, ",(0,s.kt)("inlineCode",{parentName:"p"},"insertTrade")," should insert a trade into its correspondent TRADE table and likewise for the rest of the stored procedures."),(0,s.kt)("h2",{id:"sql-procedures"},"SQL Procedures"),(0,s.kt)("p",null,"Even though Genesis cannot modify these triggers/procedures and they can potentially be implemented in any desired way as long as they behave as expected, it is always useful to have some simple working examples."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/server/integration/database-streaming-out/examples/#oracle-sample"},"Oracle sample")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/server/integration/database-streaming-out/examples/#mssql-sample"},"MSSQL sample")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"/server/integration/database-streaming-out/examples/#postgresql-sample"},"PostgreSQL sample"))),(0,s.kt)("h3",{id:"encrypting-user-and-passwords"},"Encrypting user and passwords"),(0,s.kt)("p",null,"A script called ",(0,s.kt)("inlineCode",{parentName:"p"},"encryptUserPass")," is provided with Genesis, enabling us to encrypt our user and password before using it in GenesisToDb configuration."))}m.isMDXComponent=!0}}]);