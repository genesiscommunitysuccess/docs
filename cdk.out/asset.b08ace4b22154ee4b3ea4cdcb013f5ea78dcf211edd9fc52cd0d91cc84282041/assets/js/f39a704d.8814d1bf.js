"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[27165],{44382:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return m}});var a=t(87462),s=t(63366),o=(t(67294),t(3905)),r=(t(61839),["components"]),i={title:"Server Setup - Config Management",sidebar_label:"Config Management",sidebar_position:3,id:"config-management",keywords:["operations","server","setup","config","management"],tags:["database","server","setup","config","management"]},l=void 0,p={unversionedId:"operations/server-setup/config-management",id:"version-2022.3/operations/server-setup/config-management",title:"Server Setup - Config Management",description:"This document describes the recommended uses of config management with Genesis frameworks.  It is written for a reader with some",source:"@site/versioned_docs/version-2022.3/05_operations/01_server-setup/03_config-management.md",sourceDirName:"05_operations/01_server-setup",slug:"/operations/server-setup/config-management",permalink:"/operations/server-setup/config-management",draft:!1,tags:[{label:"database",permalink:"/tags/database"},{label:"server",permalink:"/tags/server"},{label:"setup",permalink:"/tags/setup"},{label:"config",permalink:"/tags/config"},{label:"management",permalink:"/tags/management"}],version:"2022.3",sidebarPosition:3,frontMatter:{title:"Server Setup - Config Management",sidebar_label:"Config Management",sidebar_position:3,id:"config-management",keywords:["operations","server","setup","config","management"],tags:["database","server","setup","config","management"]},sidebar:"operationsSidebar",previous:{title:"Initial Application Install",permalink:"/operations/server-setup/initial-application-install"},next:{title:"Server Commands",permalink:"/operations/commands/server-commands"}},c={},m=[{value:"Config Management vs Continuous Deployment",id:"config-management-vs-continuous-deployment",level:2},{value:"Suitable elements for CM",id:"suitable-elements-for-cm",level:2},{value:"Dependencies",id:"dependencies",level:3},{value:"Nginx Configuration",id:"nginx-configuration",level:3},{value:"Using a Docker image (recommended)",id:"using-a-docker-image-recommended",level:3},{value:"Manual configuration",id:"manual-configuration",level:3},{value:"Environment overrides",id:"environment-overrides",level:3}],d={toc:m};function u(e){var n=e.components,t=(0,s.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This document describes the recommended uses of config management with Genesis frameworks.  It is written for a reader with some\nLinux system administration experience."),(0,o.kt)("h2",{id:"config-management-vs-continuous-deployment"},"Config Management vs Continuous Deployment"),(0,o.kt)("p",null,"In environments where servers are managed to a greater or lesser degree by config management systems, like Chef, Pupper or Ansible, there is a decision to be made about which aspects of a system are config managed, and which are subject to operator actions."),(0,o.kt)("p",null,"When deciding about the division of responsibilities, it is worth considering development systems and production systems somewhat separately."),(0,o.kt)("p",null,"During application development, it is likely that there will be frequent code releases to a development host, and using config management systems to enact such an upgrade is likely to be more complicated than allowing a CI/CD system to issue releases.  Development-phase versioning is less rigorous than when an application approaches readiness.  Ill-behaved versions are possible.  Releases may be frequent.  These conditions are a poor fit for the automation and consistency that is the mainstay of a config management system."),(0,o.kt)("h2",{id:"suitable-elements-for-cm"},"Suitable elements for CM"),(0,o.kt)("p",null,"Key aspects of a host prepared for Genesis applications are suitable for config management:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Dependency packages"),(0,o.kt)("li",{parentName:"ul"},"Nginx reverse-proxy configuration"),(0,o.kt)("li",{parentName:"ul"},"Environmental override configuration (needs alteration to ",(0,o.kt)("a",{parentName:"li",href:"/server/configuring-runtime/processes"},"processes.xml"),")")),(0,o.kt)("h3",{id:"dependencies"},"Dependencies"),(0,o.kt)("p",null,"Packages needed to run a Genesis application are covered in more detail in\n",(0,o.kt)("a",{parentName:"p",href:"/operations/server-setup/host-preparation"},"host preparation"),".\nAll of them are off-the-shelf packages found either in OS core package repos or extended repos such as EPEL."),(0,o.kt)("h3",{id:"nginx-configuration"},"Nginx Configuration"),(0,o.kt)("p",null,"Nginx is used as a reverse proxy as the Genesis applications' entry point.  A comparatively simple config file achieves this. This file must specify the port to listen on, hostname to respond to, and if TLS is configured, the details of certificates to use."),(0,o.kt)("p",null,"These are not matters specific to Genesis applications.  The Genesis-specific part is relative constant (unless the Router application is running on non-standard ports)."),(0,o.kt)("h3",{id:"using-a-docker-image-recommended"},"Using a Docker image (recommended)"),(0,o.kt)("p",null,"To configure NGINX using a Docker image, make sure you have the your artifactory credentials to hand. Then, in your CentOS terminal, enter the following commands:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Enter your artifactory credentials.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"docker login genesisglobal-docker-internal.jfrog.io\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Download the latest Genesis software:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"docker pull genesisglobal-docker-internal.jfrog.io/genesis-console-proxy:latest\n")),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Run the following command:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"docker run -it --rm -d -p 80:80 -p 443:443 --name genesis-console-proxy --add-host localnode:$(hostname -I) genesisglobal-docker-internal.jfrog.io/genesis-console-proxy\n")),(0,o.kt)("h3",{id:"manual-configuration"},"Manual configuration"),(0,o.kt)("p",null,"For a manual set-up of NGINX, use this sample server block."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"server {\n\n    listen 443 ssl;\n    listen 80;\n    server_name _;\n\n    root /data/positions/web;\n\n    location ~ ^/(gwf)(.*)$ {\n        proxy_set_header        Host $host:$server_port;\n        proxy_pass              http://127.0.0.1:9064$2$is_args$args;\n        proxy_http_version      1.1;\n        proxy_set_header        X-Real-IP $remote_addr;\n        proxy_set_header        HOSTNAME $remote_addr;\n        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header        X-Forwarded-Proto $scheme;\n        proxy_pass_request_headers      on;\n        proxy_set_header        Upgrade $http_upgrade;\n        proxy_set_header        Connection $connection_upgrade;\n    }\n    \n    ssl_certificate             /etc/ssl/certs/certs.crt;\n    ssl_certificate             /etc/ssl/certs/certs.key;\n    ssl_protocols               TLSv1.2;\n    ssl_ciphers                 HIGH:!aNULL:!MD5;\n}\n")),(0,o.kt)("p",null,"The IP and port shown are for the application's Router process.  This example also shows configuration for TLS and listening on both port 443 for HTTPS and port 80 for plain-text traffic."),(0,o.kt)("h3",{id:"environment-overrides"},"Environment overrides"),(0,o.kt)("p",null,"Each process within the application can be instructed to read another file to override the main configuration file, systems-definitions."),(0,o.kt)("p",null,"The overrides files can be placed anywhere that is readable to the Genesis application's run user.  Overrides files can be 1-to-1 with processes or re-used.  Their location is specified on a per-process basis in the ",(0,o.kt)("strong",{parentName:"p"},"processes.xml")," config file (which is part of the site-specific directory contents)."),(0,o.kt)("p",null,"They take the form of a ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3schools.io/file/properties-extension-introduction/"},"Java properties file"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-properties"},"# override DB details\nDbUser = genesisFdbUser\nDbHost = fdb01.my.domain\n")),(0,o.kt)("p",null,"Note, overrides files are not able to perform environment substitutions the way system-definitions can - it is a .kts file (Kotlin script) and thus effectively ",(0,o.kt)("em",{parentName:"p"},"executed"),", whereas the properties file is only read.  See\n",(0,o.kt)("a",{parentName:"p",href:"/operations/clustering/clusters#Environment-variables"},"clusters/Environment variables"),"."))}u.isMDXComponent=!0}}]);