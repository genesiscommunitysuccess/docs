"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[12063],{83169:function(e,t,a){a.r(t),a.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return d}});var n=a(87462),i=a(63366),r=(a(67294),a(3905)),o=(a(61839),["components"]),s={title:"API Reference - Authorisation API",sidebar_label:"Authorisation API",id:"authorisation-api",keywords:["database","api","reference","authorisation"],tags:["database","api","reference","authorisation"]},c=void 0,u={unversionedId:"database/api-reference/authorisation-api",id:"database/api-reference/authorisation-api",title:"API Reference - Authorisation API",description:"The authorisation API consists of two main classes that enable you to add permission checks to your custom component.",source:"@site/docs/02_database/09_api-reference/01_authorisation-api.md",sourceDirName:"02_database/09_api-reference",slug:"/database/api-reference/authorisation-api",permalink:"/next/database/api-reference/authorisation-api",draft:!1,tags:[{label:"database",permalink:"/next/tags/database"},{label:"api",permalink:"/next/tags/api"},{label:"reference",permalink:"/next/tags/reference"},{label:"authorisation",permalink:"/next/tags/authorisation"}],version:"current",sidebarPosition:1,frontMatter:{title:"API Reference - Authorisation API",sidebar_label:"Authorisation API",id:"authorisation-api",keywords:["database","api","reference","authorisation"],tags:["database","api","reference","authorisation"]},sidebar:"databaseSidebar",previous:{title:"Overview",permalink:"/next/database/api-reference/overview"},next:{title:"Dependency Injection",permalink:"/next/database/api-reference/dependency-injection"}},l={},d=[{value:"Permission code API",id:"permission-code-api",level:3},{value:"AuthCache API",id:"authcache-api",level:3},{value:"In practice",id:"in-practice",level:3}],p={toc:d};function m(e){var t=e.components,a=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The authorisation API consists of two main classes that enable you to add permission checks to your custom component."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"RightSummaryCache")," is a Kotlin class whose instance can be obtained by simply injecting it into your custom component. This functionality relates directly to the permission codes functionality covered in more detail in the ",(0,r.kt)("a",{parentName:"p",href:"/server/access-control/authorisation-overview/"},"Authorisation Overview"),". The method ",(0,r.kt)("inlineCode",{parentName:"p"},"userHasRight(userName: String, rightCode: String): Boolean")," is used to determine if a particular user has the permission to a rights code.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"AuthCache")," is a Kotlin class whose instance should be created by calling the static method ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthCache.newReader(mapName: String, updateQueue: UpdateQueue): AuthCache"),".\nAn ",(0,r.kt)("inlineCode",{parentName:"p"},"UpdateQueue")," instance can be obtained from an injected RxDb connection: ",(0,r.kt)("inlineCode",{parentName:"p"},"rxDb.updateQueue"),". A permission check for the entity is done by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"isAuthorised(entityId: String?, userName: String): Boolean"),". How this works is also covered in more detail in the ",(0,r.kt)("a",{parentName:"p",href:"/server/access-control/authorisation-overview/"},"Authorisation Overview"),"."))),(0,r.kt)("h3",{id:"permission-code-api"},"Permission code API"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'package global.genesis.session\n// imports omitted for brevity\n\n@Singletonclass RightSummaryCache \n@Inject constructor(db: RxDb) : AbstractBulkTableSubscriber<RightSummaryCache.RightSummary>(\n    db,\n    "RIGHT_SUMMARY"\n) {        \n    // other members omitted for brevity    \n    fun userHasRight(userName: String, rightCode: String): Boolean {        \n        // details omitted for brevity \n    }\n}\n')),(0,r.kt)("h3",{id:"authcache-api"},"AuthCache API"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"package global.genesis.session\n// imports omitted for brevity\n\nclass AuthCache private constructor(private val mapName: String, updateQueue: UpdateQueue) : MasterAuthCache {      \n    companion object {        \n        @JvmStatic        \n        fun newReader(mapName: String, updateQueue: UpdateQueue): AuthCache {\n            // details omitted for brevity       \n        }    \n    }    \n    \n    override fun isAuthorised(entityId: String?, userName: String): Boolean {        \n        // details omitted for brevity   \n    }\n}\n")),(0,r.kt)("h3",{id:"in-practice"},"In practice"),(0,r.kt)("p",null,"The example below shows permission codes and ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthCache")," in use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'// import and package omitted for brevity \n\n@Moduleclass PriceFeedEventHandler @Inject constructor(    \n    private val rxDb: RxDb,    \n    private val rightSummaryCache: RightSummaryCache\n) : SyncEventHandler<PriceFeedRequest, EventReply> {    \n    private lateinit var authCache: Authority    \n    @Inject    \n    fun init() {        \n        LOG.info("Starting Price Feed Handler")        \n        authCache = AuthCache.newReader("PRICE_FEEDS", rxDb.updateQueue)    \n    }    \n    \n    override fun process(event: Event<PriceFeedRequest>): EventReply {        \n        val userName = event.userName        \n        // Determines if User has access to any PRICE_FEED        \n        if (rightSummaryCache.userHasRight(userName, "PRICE_FEEDS")) {            \n            // Determines if User has granular access to a specific PRICE_FEED            \n            val feedName = event.details.name            \n            if (authCache.isAuthorised(feedName, userName)) {                \n                val feelUrl = getFeedUrl(feedName)               \n                return EventReply.EventAck(listOf(mapOf("FEED_URL" to feelUrl)))            \n            }        \n        }        \n        return StandardError("NOT_AUTHORISED", "User $userName lacks sufficient permissions").toEventNackError()    \n    }    \n    \n    private fun getFeedUrl(feedName: String): String {        \n        // details omitted for brevity        \n        return "TODO"    \n    }    \n    \n    companion object {        \n        private val LOG = LoggerFactory.getLogger(PriceFeedEventHandler::class.java)    \n    }\n}\n')))}m.isMDXComponent=!0}}]);