"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[80861],{64:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return v},frontMatter:function(){return d},metadata:function(){return o},toc:function(){return p}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),i=(n(61839),["components"]),d={title:"State Machine - Testing",sidebar_label:"Testing",id:"testing",keywords:["server","state machine","testing"],tags:["server","state machine","testing"]},l=void 0,o={unversionedId:"server/state-machine/testing",id:"version-2022.3/server/state-machine/testing",title:"State Machine - Testing",description:"Integration testing",source:"@site/versioned_docs/version-2022.3/03_server/06_state-machine/06_testing.md",sourceDirName:"03_server/06_state-machine",slug:"/server/state-machine/testing",permalink:"/server/state-machine/testing",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"state machine",permalink:"/tags/state-machine"},{label:"testing",permalink:"/tags/testing"}],version:"2022.3",sidebarPosition:6,frontMatter:{title:"State Machine - Testing",sidebar_label:"Testing",id:"testing",keywords:["server","state machine","testing"],tags:["server","state machine","testing"]},sidebar:"serverModulesSidebar",previous:{title:"Configuring Runtime",permalink:"/server/state-machine/configuring-runtime"},next:{title:"Introduction",permalink:"/server/consolidator/introduction"}},c={},p=[{value:"Integration testing",id:"integration-testing",level:2},{value:"Writing tests",id:"writing-tests",level:2}],u={toc:p};function v(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"integration-testing"},"Integration testing"),(0,s.kt)("p",null,"As state machine is another layer on Event Handler, so the test configuration is same as Event Handlers\nThe Genesis Platform provides the ",(0,s.kt)("inlineCode",{parentName:"p"},"AbstractGenesisTestSupport"),' abstract class that enables end-to-end testing of specific areas of your application. In this case, we want to ensure that we have a database, seeded with information, and that our Event Handler configuration is used to create our Event Handler. We also need to add the required packages, genesis home and separately set the "IS_SCRIPT" System Definition property to true (This is required as part of the Event Handler initialisation.).'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'class EventHandlerTest : AbstractGenesisTestSupport<GenesisSet>(\n    GenesisTestConfig {\n        addPackageName("global.genesis.eventhandler.pal")\n        genesisHome = "/GenesisHome/"\n        parser = { it }\n        scriptFileName = "your-application-eventhandler.kts"\n        initialDataFile = "seed-data.csv"\n    }\n) {\n    override fun systemDefinition(): Map<String, Any> = mapOf("IS_SCRIPT" to "true")\n}\n')),(0,s.kt)("p",null,"For more information about ",(0,s.kt)("inlineCode",{parentName:"p"},"AbstractGenesisTestSupport"),", see the ",(0,s.kt)("a",{parentName:"p",href:"/operations/testing/integration-testing/#abstractgenesistestsupport"},"Testing pages"),"."),(0,s.kt)("p",null,"Once you have set up your configuration, you can start writing tests against State machine."),(0,s.kt)("h2",{id:"writing-tests"},"Writing tests"),(0,s.kt)("p",null,"Let's write some tests for this ",(0,s.kt)("a",{parentName:"p",href:"/server/state-machine/examples/"},"example")," of State Machine."),(0,s.kt)("p",null,"Add these helper functions for test:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'    private inline fun <T : Any> T.assertProperty(block: T.() -> Boolean) = assert(block()) {\n        toPrettyJsonString(true)\n    }\n\n    private fun EventReply.EventAck.extractTradeId(): String {\n        val generated = generated.first()\n        assert(generated.isNotEmpty())\n        assert("TRADE_ID" in generated)\n        return generated["TRADE_ID"] as String\n    }\n\n    private fun makeTrade(newTradePrice: Double, tradeQuantity: Int) =\n        Trade {\n            tradeId = "test_id"\n            quantity = tradeQuantity\n            tradePrice = newTradePrice\n            currencyId = "USD"\n            enteredBy = null\n            enteredTime = null\n            modifiedBy = null\n            modifiedTime = null\n        }\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'    @Test\n    fun `test trade insert`() = runBlocking {\n        val start = DateTime.now()\n        val reply = sendEvent(\n            makeTrade(1.25, 12),\n            messageType = "EVENT_TRADE_INSERT",\n                userName = "harry"\n            )\n\n        val ack = reply.assertedCast<EventReply.EventAck>()\n        val trade = entityDb.get(Trade.ById(ack.extractTradeId()))!!\n\n        trade.assertProperty { enteredBy == "harry" }\n        trade.assertProperty { enteredTime!! > start }\n        trade.assertProperty { tradePrice == 1.25 }\n        trade.assertProperty { quantity == 12 }\n        trade.assertProperty { tradeStatus == TradeStatus.DRAFT }\n    }\n\n    @Test\n    fun `test trade insert - failure`() = runBlocking {\n        val reply = sendEvent(\n            makeTrade(1.25, -1),\n            messageType = "EVENT_TRADE_INSERT",\n            userName = "harry"\n        )\n\n        val nack = reply.assertedCast<EventReply.EventNack>()\n        val error = nack.error.first().text\n\n        assertEquals("Expected Trade.QUANTITY to be greater than or equal to 0; actual value -1", error)\n    }\n\n    @Test\n    fun `test trade modify`() = runBlocking {\n        val reply = sendEvent(\n            makeTrade(1.25, 12),\n            messageType = "EVENT_TRADE_INSERT",\n            userName = "harry"\n        )\n\n        val ack = reply.assertedCast<EventReply.EventAck>()\n\n        val tradeId = ack.extractTradeId()\n        var trade = entityDb.get(Trade.ById(tradeId))!!\n\n        trade.quantity = 15\n\n        sendEvent(\n            trade,\n            messageType = "EVENT_TRADE_MODIFY",\n            userName = "john"\n        ).assertedCast<EventReply.EventAck>()\n\n        trade = entityDb.get(Trade.ById(tradeId))!!\n\n        trade.assertProperty { enteredBy == "harry" }\n        trade.assertProperty { modifiedBy == "john" }\n        trade.assertProperty { quantity == 15 }\n        trade.assertProperty { tradeStatus == TradeStatus.DRAFT }\n    }\n\n    @Test\n    fun `test trade modify - failure`() = runBlocking {\n        val reply = sendEvent(\n            makeTrade(1.25, 12),\n            messageType = "EVENT_TRADE_INSERT",\n            userName = "harry"\n        )\n\n        val ack = reply.assertedCast<EventReply.EventAck>()\n\n        val reply2 = reply.messageType\n\n        val tradeId = ack.extractTradeId()\n        val trade = entityDb.get(Trade.ById(tradeId))!!\n\n        trade.tradePrice = null\n\n        val nack = sendEvent(\n            trade,\n            messageType = "EVENT_TRADE_MODIFY",\n            userName = "john"\n        ).assertedCast<EventReply.EventNack>()\n\n        val error = nack.error.first().text\n        assertEquals("Expected Trade.TRADE_PRICE to have a value", error)\n    }\n\n    @Test\n    fun `test trade cancel`() = runBlocking {\n        val reply = sendEvent(\n            makeTrade(1.25, 12),\n            messageType = "EVENT_TRADE_INSERT",\n            userName = "harry"\n        )\n\n        val ack = reply.assertedCast<EventReply.EventAck>()\n\n        val tradeId = ack.extractTradeId()\n        val index = Trade.ById(tradeId)\n\n        sendEvent(\n            index,\n            messageType = "EVENT_TRADE_CANCELLED",\n            userName = "john"\n        ).assertedCast<EventReply.EventAck>()\n\n        val trade = entityDb.get(index)!!\n\n        trade.assertProperty { enteredBy == "harry" }\n        trade.assertProperty { modifiedBy == "john" }\n        trade.assertProperty { tradeStatus == TradeStatus.CANCELLED }\n    }\n\n    @Test\n    fun `test trade modify - fail cancelled`() = runBlocking {\n        val reply = sendEvent(\n            makeTrade(1.25, 12),\n            messageType = "EVENT_TRADE_INSERT",\n            userName = "harry"\n        )\n\n        val ack = reply.assertedCast<EventReply.EventAck>()\n\n        val tradeId = ack.extractTradeId()\n        val index = Trade.ById(tradeId)\n\n        sendEvent(\n            index,\n            messageType = "EVENT_TRADE_CANCELLED",\n            userName = "john"\n        ).assertedCast<EventReply.EventAck>()\n\n        val trade = entityDb.get(index)!!\n        trade.quantity = 100\n\n        val nack = sendEvent(\n            trade,\n            messageType = "EVENT_TRADE_MODIFY",\n            userName = "john"\n        ).assertedCast<EventReply.EventNack>()\n\n        val error = nack.error.first().text\n        assert(error == "Trade CANCELLED is immutable") { error }\n    }\n')))}v.isMDXComponent=!0}}]);