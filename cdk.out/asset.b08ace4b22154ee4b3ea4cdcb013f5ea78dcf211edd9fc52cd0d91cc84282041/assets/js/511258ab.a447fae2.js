"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[76085],{42191:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return u}});var n=a(87462),i=a(63366),l=(a(67294),a(3905)),r=(a(61839),["components"]),s={title:"Data Server - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","data server","dataserver","basics"],tags:["server","data server","dataserver","basics"]},o=void 0,d={unversionedId:"server/data-server/basics",id:"server/data-server/basics",title:"Data Server - Basics",description:"Let's make things really simple.",source:"@site/docs/03_server/02_data-server/02_basics.md",sourceDirName:"03_server/02_data-server",slug:"/server/data-server/basics",permalink:"/next/server/data-server/basics",draft:!1,tags:[{label:"server",permalink:"/next/tags/server"},{label:"data server",permalink:"/next/tags/data-server"},{label:"dataserver",permalink:"/next/tags/dataserver"},{label:"basics",permalink:"/next/tags/basics"}],version:"current",sidebarPosition:2,frontMatter:{title:"Data Server - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","data server","dataserver","basics"],tags:["server","data server","dataserver","basics"]},sidebar:"serverModulesSidebar",previous:{title:"Introduction",permalink:"/next/server/data-server/introduction"},next:{title:"Advanced",permalink:"/next/server/data-server/advanced"}},p={},u=[{value:"The simplest possible definition",id:"the-simplest-possible-definition",level:2},{value:"Specifying fields",id:"specifying-fields",level:2},{value:"Derived fields",id:"derived-fields",level:2},{value:"Configuration settings",id:"configuration-settings",level:2},{value:"Global settings",id:"global-settings",level:3},{value:"Top-level global setting",id:"top-level-global-setting",level:3},{value:"Query-level global settings",id:"query-level-global-settings",level:3},{value:"Shared settings",id:"shared-settings",level:3},{value:"Backwards joins",id:"backwards-joins",level:2},{value:"Where clauses",id:"where-clauses",level:2},{value:"Indices",id:"indices",level:2},{value:"Index definition",id:"index-definition",level:3}],c={toc:u};function h(e){var t=e.components,a=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Let's make things really simple."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A Data Server is a component that supplies streaming real-time data to the front end of your application."),(0,l.kt)("li",{parentName:"ul"},"You define your application's Data Server in a Kotlin script file named ",(0,l.kt)("em",{parentName:"li"},"application-name"),(0,l.kt)("strong",{parentName:"li"},"-dataserver.kts"),". This file can be found inside the ",(0,l.kt)("em",{parentName:"li"},"application-name"),(0,l.kt)("strong",{parentName:"li"},"-script-config")," module (",(0,l.kt)("em",{parentName:"li"},"application-name"),"\\",(0,l.kt)("em",{parentName:"li"},"application-name"),"-script-config\\src\\main\\resources\\scripts","\\",(0,l.kt)("em",{parentName:"li"},"application-name"),"-dataserver.kts). "),(0,l.kt)("li",{parentName:"ul"},"In this file, you define specific ",(0,l.kt)("inlineCode",{parentName:"li"},"query")," codeblocks, each of which is designed to supply different sets of data."),(0,l.kt)("li",{parentName:"ul"},"Each ",(0,l.kt)("inlineCode",{parentName:"li"},"query")," listens to a specified table or view; when data on that source changes, it publishes the changes. "),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"query")," can include a number of other subtleties, such as ",(0,l.kt)("inlineCode",{parentName:"li"},"where")," clauses or ranges, so that you can create code that matches your precise requirements."),(0,l.kt)("li",{parentName:"ul"},"If you use ",(0,l.kt)("inlineCode",{parentName:"li"},"AppGen")," to build from your dictionary, then a basic kts file will be built automatically for you, covering all the tables and views in your data model. You can edit this file to add sophistication to the component."),(0,l.kt)("li",{parentName:"ul"},"Otherwise, you can build your kts by defining each ",(0,l.kt)("inlineCode",{parentName:"li"},"query")," codeblock from scratch. ")),(0,l.kt)("h2",{id:"the-simplest-possible-definition"},"The simplest possible definition"),(0,l.kt)("p",null,"Your ",(0,l.kt)("em",{parentName:"p"},"application-name"),"-",(0,l.kt)("strong",{parentName:"p"},"dataserver.kts")," Kotlin script file contains all the queries you create. These are wrapped in a single ",(0,l.kt)("inlineCode",{parentName:"p"},"dataServer")," statement.\nOur example below shows a file with a single query, which publishes changes to the table INSTRUMENT_DETAILS."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"dataServer {\n    query(INSTRUMENT_DETAILS)\n}\n")),(0,l.kt)("p",null,"And here is a simple example that has two queries:"),(0,l.kt)("p",null,"Note that each query is subscribed to separately."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"dataServer {\n    query(INSTRUMENT_DETAILS)\n\n    query(COUNTERPARTY)\n}\n")),(0,l.kt)("h2",{id:"specifying-fields"},"Specifying fields"),(0,l.kt)("p",null,"By default, all table or view fields in a query definition will be exposed. If you don't want them all to be available, you must define the fields that are required. In the example below, we specify eight fields:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"dataServer {\n    query(INSTRUMENT_DETAILS) {\n        fields {\n            INSTRUMENT_CODE\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n        }\n    }\n}\n")),(0,l.kt)("h2",{id:"derived-fields"},"Derived fields"),(0,l.kt)("p",null,"You can also define derived fields in a Data Server, to supplement the fields supplied by the table or view. The input for the derived field is the Data Server query row.  All fields are available for use."),(0,l.kt)("p",null,"In the example below, we add a ninth field to our Data Server from the previous example. The new field is a derived field:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'dataServer {\n    query(INSTRUMENT_DETAILS) {\n        fields {\n            INSTRUMENT_CODE\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n            derivedField("IS_USD", BOOLEAN) {\n                tradedCurrency == "USD"\n            }\n        }\n    }\n}\n')),(0,l.kt)("h2",{id:"configuration-settings"},"Configuration settings"),(0,l.kt)("p",null,"Before you define any queries, you can make configuration settings for the Data Server within the ",(0,l.kt)("inlineCode",{parentName:"p"},"config")," block. These control the overall behaviour of the Data Server."),(0,l.kt)("p",null,"Here is an example of some configuration settings: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'dataServer {\n    config {\n        lmdbAllocateSize = 512.MEGA_BYTE() // top level only setting\n        // Items below can be overriden in individual query definitions\n        compression = true \n        chunkLargeMessages = true\n        defaultStringSize = 40\n        batchingPeriod = 500\n        linearScan = true\n        excludedEmitters = listOf("PurgeTables")\n        enableTypeAwareCriteriaEvaluator = true\n    }\n    query("SIMPLE_QUERY", SIMPLE_TABLE) {\n        config {\n            // Items below only available in query level config\n            defaultCriteria = "SIMPLE_PRICE > 0"\n            backwardsJoins = false\n            disableAuthUpdates = false\n        }\n    }\n}\n')),(0,l.kt)("p",null,"Below, we shall examine the settings that are available for your ",(0,l.kt)("inlineCode",{parentName:"p"},"config")," statement."),(0,l.kt)("h3",{id:"global-settings"},"Global settings"),(0,l.kt)("p",null,"Global settings can be applied at two levels:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Top level"),(0,l.kt)("li",{parentName:"ul"},"Query level")),(0,l.kt)("h3",{id:"top-level-global-setting"},"Top-level global setting"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"lmdbAllocateSize"),"\nThis sets the size of the memory-mapped file where the in-memory cache stores the Data Server query rows. This configuration setting can only be applied at the top level. It affects the whole Data Server. "),(0,l.kt)("p",null,"By default, the size is defined in bytes. To use MB or GB, use the ",(0,l.kt)("inlineCode",{parentName:"p"},"MEGA_BYTE")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"GIGA_BYTE")," functions. You can see these in the example below. The default is 2 GB."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"lmdbAllocateSize = 2.GIGA_BYTE()\n// or\nlmdbAllocateSize = 512.MEGA_BYTE()\n")),(0,l.kt)("h3",{id:"query-level-global-settings"},"Query-level global settings"),(0,l.kt)("p",null,"The following settings can be applied at a query-level."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"defaultCriteria"),"\nThis represents the default criteria for the query. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,l.kt)("p",null," ",(0,l.kt)("inlineCode",{parentName:"p"},"disableAuthUpdates"),"\nThis disables real-time auth updates in order to improve the overall data responsiveness and performance of the server. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"backJoins"),"\nSeen in older versions of the platform, this has been replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"backwardsJoins"),". It is functionally the same."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"backwardsJoins"),"\nThis enables backwards joins on a view query. Backwards joins ensure real-time updates on the fields that have been joined. These need to be configured at the join level of the query in order to work correctly. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,l.kt)("h3",{id:"shared-settings"},"Shared settings"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"compression"),"\nIf this is set to ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", it will compress the query row data before writing it to the in-memory cache. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"chunkLargeMessages"),"\nIf this is set to true, it will split large updates into smaller ones. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"defaultStringSize"),"\nThis is the size to be used for string storage in the Data Server in-memory cache. Higher values lead to higher memory use; lower values lead to lower memory use, which can lead to string overflow. See the ",(0,l.kt)("inlineCode",{parentName:"p"},"onStringOverflow")," setting for details of how the overflows are handled. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"40"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"batchingPeriod"),"\nThis is the delay in milliseconds to wait before sending new data to Data Server clients. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"500ms"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"linearScan"),"\nThis enables linear scan behaviour in the query definition. If false, it will reject criteria expressions that don't hit defined indexes. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"excludedEmitters"),"\nThis enables update filtering for a list of process names. Any database updates that originate from one of these processes will be ignored. Defaults to an empty list."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"onStringOverflow")," This controls how the system responds to a string overflow. A string overflow happens when the value of a String field in an index is larger than ",(0,l.kt)("inlineCode",{parentName:"p"},"defaultStringSize"),", or the size set on the field."),(0,l.kt)("p",null,"There are two options for handling string overflows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"IGNORE_ROW")," - rows with string overflows will be ignored. This can lead to data missing from the Data Server."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"TRUNCATE_FIELD")," - indices with string overflows will be truncated. The data with the overflow will still be returned in full, and will be searchable. However, if multiple rows are truncated to the same value, any subsequent rows will lead to duplicate index exceptions during the insert, so these rows will not be available to the Data Server.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"enableTypeAwareCriteriaEvaluator"),"\nThis enables the type-aware criteria evaluator. Defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),". "),(0,l.kt)("p",null,"The type-aware criteria evaluator can automatically convert criteria comparisons that don't match the original type of the Data Server field; these can still be useful to end users."),(0,l.kt)("p",null,"For example, you might want a front-end client to perform a criteria search on a ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_DATE")," field like this: ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_DATE > '2015-03-01' && TRADE_DATE < '2015-03-02'"),".\nThis search can be translated automatically to the right field types internally (even though ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_DATE")," is a field of type ",(0,l.kt)("inlineCode",{parentName:"p"},"DateTime"),"). The Genesis index search mechanism can also identify the appropriate search intervals in order to provide an optimised experience.\nThe type-aware evaluator can transform strings to integers, and any other sensible and possible conversion (e.g ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_ID == '1'"),"). As a side note, this type-aware evaluator is also available in ",(0,l.kt)("inlineCode",{parentName:"p"},"DbMon")," for operations like ",(0,l.kt)("inlineCode",{parentName:"p"},"search")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"qsearch"),"."),(0,l.kt)("p",null,"By contrast, the traditional criteria evaluator needs the field types to match the query fields in the Data Server. So the same comparison using the default criteria evaluator for ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_DATE")," would be something like: ",(0,l.kt)("inlineCode",{parentName:"p"},"TRADE_DATE > new DateTime(1425168000000) && TRADE_DATE < new DateTime(1425254400000)"),". This approach is less intuitive and won't work with our automatic index selection mechanism. In this case, you should use our common date expressions (more at Advanced technical details) to handle date searches."),(0,l.kt)("h2",{id:"backwards-joins"},"Backwards joins"),(0,l.kt)("p",null,"Each query in a Data Server creates what is effectively an open connection between each requesting user and the Data Server. After the initial send of all the data, the Data Server only sends modifications, deletions and insertions in real time."),(0,l.kt)("p",null,"For queries with backwards joins enabled, the primary table and all joined tables and views are actively monitored. Any changes to these tables and views are sent automatically."),(0,l.kt)("p",null,"Monitoring of backwards joins can come at a cost, as it can cause significant extra processing. Do not use backwards joins unless there is a need for the data in question to be updated in real time. For example, counterparty data, if changed, can wait until overnight. The rule of thumb is that you should only use backwards joins where the underlying data is being updated intraday."),(0,l.kt)("p",null,"The backwards join flag is true by default. You must explicitly set ",(0,l.kt)("inlineCode",{parentName:"p"},"backwardsJoins = false")," if you wish to turn backwards joins off for your query."),(0,l.kt)("h2",{id:"where-clauses"},"Where clauses"),(0,l.kt)("p",null,"If you include a ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," clause in a query, the request is only processed if the criteria specified in the clause are met. For example, If you have an application that deals with derivatives that have parent and child trades, you can use a ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," clause to confine the query to parent trades only."),(0,l.kt)("p",null,"Also, you can use these clauses to focus on a specific set of fields or a single field."),(0,l.kt)("p",null,"Finally, note that ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," clauses can also be used for permissioning. In the below example, users that have the TRADER or SUPPORT permission code are able to see all trades that meet the ",(0,l.kt)("inlineCode",{parentName:"p"},"where")," condition."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'dataServer {\n\n    query("ALL_TRADES_LARGE_POSITION", ENHANCED_TRADE_VIEW) {\n        permissioning {\n            permissionCodes = listOf("TRADER", "SUPPORT")\n            auth(mapName = "ENTITY_VISIBILITY") {\n                ENHANCED_TRADE_VIEW.COUNTERPARTY_ID\n            }\n        }\n        where { trade -> \n            (trade.quantity * trade.price) > 1000000 \n        }\n    }\n}\n')),(0,l.kt)("h2",{id:"indices"},"Indices"),(0,l.kt)("p",null,"Here is an example of a simple index:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'dataServer {\n    query("SIMPLE_QUERY", SIMPLE_TABLE) {\n        indices {\n            unique("SIMPLE_QUERY_BY_QUANTITY") {\n                QUANTITY\n                SIMPLE_ID\n            }\n        }\n    }\n}\n')),(0,l.kt)("h3",{id:"index-definition"},"Index definition"),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"indices")," (optional) block defines additional indexing at the query level. When an index is used, it will order all query rows by the fields specified, in ascending order. This definition is identical to the one defined in data modelling for dictionary tables."),(0,l.kt)("p",null,"There are two scenarios in which an index can be used:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Optimising query criteria search. If a Data Server client specifies criteria such as ",(0,l.kt)("inlineCode",{parentName:"li"},"QUANTITY > 1000 && QUANTITY < 5000"),", the Data Server will automatically select the best matching index. In our example, it would be ",(0,l.kt)("inlineCode",{parentName:"li"},"SIMPLE_QUERY_BY_QUANTITY"),". This means we don't need to scan all the query rows stored in the Data Server memory-mapped file cache; instead, we perform a very efficient indexed search."),(0,l.kt)("li",{parentName:"ul"},"Index specified in the Data Server client. If an ",(0,l.kt)("inlineCode",{parentName:"li"},"ORDER_BY")," value is received as part of the ",(0,l.kt)("inlineCode",{parentName:"li"},"DATA_LOGON")," process, the Data Server will use a specific index to query the data. The data will be returned to the client in ascending order, based on the index field definition. See more at Advanced technical details.")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Important"),": Index definitions are currently limited to ",(0,l.kt)("em",{parentName:"p"},"unique")," indices. As quantity does not have a unique constraint in the example definition shown above, we need to add SIMPLE_ID to the index definition to ensure we maintain uniqueness."))}h.isMDXComponent=!0}}]);