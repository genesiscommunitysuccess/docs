"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[56224],{91371:function(e,n,t){t.r(n),t.d(n,{assets:function(){return s},contentTitle:function(){return d},default:function(){return k},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=t(87462),l=t(63366),r=(t(67294),t(3905)),i=(t(61839),["components"]),o={title:"API Reference - Event Handler API",sidebar_label:"Event Handler API",id:"event-handler-api",keywords:["database","api","reference","event handler"],tags:["database","api","reference","event handler"]},d=void 0,p={unversionedId:"database/api-reference/event-handler-api",id:"database/api-reference/event-handler-api",title:"API Reference - Event Handler API",description:"In most cases, you will create Event Handlers in a kts file using GPAL. This offers a method with succinct code and a good degree of flexibility.",source:"@site/docs/02_database/09_api-reference/03_event-handler-api.md",sourceDirName:"02_database/09_api-reference",slug:"/database/api-reference/event-handler-api",permalink:"/next/database/api-reference/event-handler-api",draft:!1,tags:[{label:"database",permalink:"/next/tags/database"},{label:"api",permalink:"/next/tags/api"},{label:"reference",permalink:"/next/tags/reference"},{label:"event handler",permalink:"/next/tags/event-handler"}],version:"current",sidebarPosition:3,frontMatter:{title:"API Reference - Event Handler API",sidebar_label:"Event Handler API",id:"event-handler-api",keywords:["database","api","reference","event handler"],tags:["database","api","reference","event handler"]},sidebar:"databaseSidebar",previous:{title:"Dependency Injection",permalink:"/next/database/api-reference/dependency-injection"},next:{title:"Network API",permalink:"/next/database/api-reference/network-api"}},s={},m=[{value:"Configure in processes.xml file",id:"configure-in-processesxml-file",level:2},{value:"Event Handler interface",id:"event-handler-interface",level:2},{value:"Inject objects",id:"inject-objects",level:2},{value:"Async\u200b",id:"async",level:2},{value:"AsyncEventHandler\u200b",id:"asynceventhandler",level:3},{value:"AsyncValidatingEventHandler",id:"asyncvalidatingeventhandler",level:3},{value:"Implementation",id:"implementation",level:3},{value:"AsyncContextValidatingEventHandler",id:"asynccontextvalidatingeventhandler",level:3},{value:"Implementation\u200b",id:"implementation-1",level:3},{value:"Rx3",id:"rx3",level:2},{value:"Rx3EventHandler",id:"rx3eventhandler",level:3},{value:"Implementation",id:"implementation-2",level:3},{value:"Helper methods",id:"helper-methods",level:3},{value:"Rx3ValidatingEventHandler",id:"rx3validatingeventhandler",level:3},{value:"Implementation",id:"implementation-3",level:3},{value:"Rx3ContextValidatingEventHandler",id:"rx3contextvalidatingeventhandler",level:3},{value:"Implementation",id:"implementation-4",level:3},{value:"Helper methods",id:"helper-methods-1",level:3},{value:"Sync",id:"sync",level:2},{value:"SyncEventHandler\u200b",id:"synceventhandler",level:3},{value:"Implementation\u200b",id:"implementation-5",level:3},{value:"Helper methods\u200b",id:"helper-methods-2",level:3},{value:"SyncValidatingEventHandler\u200b",id:"syncvalidatingeventhandler",level:2},{value:"Implementation\u200b",id:"implementation-6",level:3},{value:"SyncContextValidatingEventHandler\u200b",id:"synccontextvalidatingeventhandler",level:2},{value:"Implementation\u200b",id:"implementation-7",level:3},{value:"Helper methods\u200b",id:"helper-methods-3",level:3}],u={toc:m};function k(e){var n=e.components,t=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In most cases, you will create ",(0,r.kt)("a",{parentName:"p",href:"/server/event-handler/introduction/"},"Event Handlers")," in a kts file using GPAL. This offers a method with succinct code and a good degree of flexibility."),(0,r.kt)("p",null,"However, you can also implement Event Handlers as a set of classes. Typically, this is useful where you have a complex requirement for business logic and database interaction. For example, a kts file of 1,000 lines is difficult to test and maintain; in this case, a set of individual classes is much more convenient."),(0,r.kt)("p",null,"For implementing an Event Handler as a set of classes, there are three different options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Async. This uses the Kotlin coroutine API to simplify asynchronous development. This is the underlying implementation used in GPAL Event Handlers. You can only create Async Event Handlers using Kotlin."),(0,r.kt)("li",{parentName:"ul"},"RxJava3. This uses the RxJava3 library, which is a popular option for composing asynchronous event-based programs. You can create RxJava3 Event Handlers using either Kotlin or Java."),(0,r.kt)("li",{parentName:"ul"},"Sync. This creates synchronous Event Handlers. You can create Sync Event Handlers using either Kotlin or Java.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Java Event Handlers can be implemented using ",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#rx3eventhandler"},"RxJava3")," and ",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#sync"},"Sync")," Event Handlers only. Async Event Handlers cannot be used, as there is no implementation for Kotlin coroutines in Java."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("strong",{parentName:"p"},"We recommend using Kotlin to implement Event Handlers."))),(0,r.kt)("h2",{id:"configure-in-processesxml-file"},"Configure in processes.xml file"),(0,r.kt)("p",null,"You need to add the ",(0,r.kt)("inlineCode",{parentName:"p"},"global.genesis.eventhandler")," package in the package tag of the process; this tag defines which package the process should refer to. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'<process name="POSITION_NEW_PROCESS">    \n    <groupId>POSITION</groupId>    \n    <start>true</start>    \n    <options>-Xmx256m -DRedirectStreamsToLog=true -DXSD_VALIDATE=false</options>    <module>position-new-process</module>    \n    <package>global.genesis.eventhandler,position.company.manager</package>    <description>Handles events</description>  \n</process>\n')),(0,r.kt)("h2",{id:"event-handler-interface"},"Event Handler interface"),(0,r.kt)("p",null,"The Event Handler interface is the common supertype of AsyncEventHandler, Rx3EventHandler and SyncEventHandler, but it is not meant to be used on its own. It provides basic options for each Event Handler definition, which can be overridden. See the Kotlin methods explanation below:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"),(0,r.kt)("th",{parentName:"tr",align:null},"Default value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"excludeMetadataFields"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun excludeMetadataFields(): Set<String>")),(0,r.kt)("td",{parentName:"tr",align:null},'setOf("RECORD_ID", "TIMESTAMP")'),(0,r.kt)("td",{parentName:"tr",align:null},"Contains a list of metadata fields to be excluded from the event metadata extracted from the input ",(0,r.kt)("inlineCode",{parentName:"td"},"I"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"includeMetadataFields"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun includeMetadataFields(): Set<String>")),(0,r.kt)("td",{parentName:"tr",align:null},"emptySet()"),(0,r.kt)("td",{parentName:"tr",align:null},"Contains a list of metadata fields that need to be included in the event metadata; this must be available in input ",(0,r.kt)("inlineCode",{parentName:"td"},"I"),". A non-empty list will exclude the other fields.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"messageType"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun messageType(): String?")),(0,r.kt)("td",{parentName:"tr",align:null},"null"),(0,r.kt)("td",{parentName:"tr",align:null},"Contains the name of the Event Handler. If undefined, the Event Handler name will become ",(0,r.kt)("inlineCode",{parentName:"td"},"EVENT_*INPUT_CLASS_NAME*"),". So, for an Event Handler using an input type called ",(0,r.kt)("inlineCode",{parentName:"td"},"TradeInsert"),", the message type will become ",(0,r.kt)("inlineCode",{parentName:"td"},"EVENT_TRADE_INSERT"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"overrideMetadataFields"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun overrideMetadataFields(): Map<String, OverrideMetaField>")),(0,r.kt)("td",{parentName:"tr",align:null},"emptySet()"),(0,r.kt)("td",{parentName:"tr",align:null},"Contains a map (key-value entries) of metadata field names to metadata field definitions in the shape of ",(0,r.kt)("inlineCode",{parentName:"td"},"OverrideMetaField"),". This enables you to override the metadata field properties extracted from input ",(0,r.kt)("inlineCode",{parentName:"td"},"I"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"requiresPendingApproval"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun requiresPendingApproval(): Boolean")),(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null},"This is used where particular system events require a second system user to approve them (",(0,r.kt)("a",{parentName:"td",href:"/server/event-handler/advanced/#pending-approvals"},"pending approval")," in order to take effect)")))),(0,r.kt)("p",null,"Each custom Event Handler must define an input message type ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," and an output message type ",(0,r.kt)("inlineCode",{parentName:"p"},"O")," (these need to be data classes), as GPAL Event Handlers do). In the examples below, ",(0,r.kt)("inlineCode",{parentName:"p"},"Company")," is the input message and ",(0,r.kt)("inlineCode",{parentName:"p"},"EventReply")," is the output message. The ",(0,r.kt)("inlineCode",{parentName:"p"},"message")," object contains event message and has the following properties :"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Default value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"details"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"This has input information, example: Company")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"messageType"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Name of the Event Handler")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"userName"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Name of logged-in user")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ignoreWarnings"),(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null},"If set to false, events will not be processed if there are any warnings; you will get EventNack with warning message. If set to true, warning messages will be ignored; processing of events will be stopped only if there are any errors")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"requiresApproval"),(0,r.kt)("td",{parentName:"tr",align:null},"false"),(0,r.kt)("td",{parentName:"tr",align:null},"This particular event needs approval from a second user if set to true. For more details, check ",(0,r.kt)("a",{parentName:"td",href:"/server/event-handler/advanced/#pending-approvals"},"Pending Approval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"approvalKey"),(0,r.kt)("td",{parentName:"tr",align:null},"null"),(0,r.kt)("td",{parentName:"tr",align:null},"Auto-generated key ID for particular approval request. For more details, check ",(0,r.kt)("a",{parentName:"td",href:"/server/event-handler/advanced/#pending-approvals"},"Pending Approval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"approvalMessage"),(0,r.kt)("td",{parentName:"tr",align:null},"null"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional message for approval request. For more details, check ",(0,r.kt)("a",{parentName:"td",href:"/server/event-handler/advanced/#pending-approvals"},"Pending Approval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"reason"),(0,r.kt)("td",{parentName:"tr",align:null},"null"),(0,r.kt)("td",{parentName:"tr",align:null},"Optional reason sent as part of event message")))),(0,r.kt)("h2",{id:"inject-objects"},"Inject objects"),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/dependency-injection/"},"@Inject")," to provide instances for any objects needed as part of the dependency injection stage"),(0,r.kt)("h2",{id:"async"},"Async",(0,r.kt)("a",{parentName:"h2",href:"/database/api-reference/event-handler-api/#asyncdirect-link-to-heading"},"\u200b")),(0,r.kt)("h3",{id:"asynceventhandler"},"AsyncEventHandler",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#asynceventhandlerdirect-link-to-heading"},"\u200b")),(0,r.kt)("p",null,"This is the most basic definition of an Async Event Handler. You can define an ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncEventHandler")," by implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncEventHandler")," interface, which is defined as: ",(0,r.kt)("inlineCode",{parentName:"p"},"interface AsyncEventHandler<I : Any, O : Outbound> : AsyncEventWorkflowProcessor<I, O>, EventHandler")),(0,r.kt)("p",null,"The only mandatory method to implement this in the interface is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"process"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun suspend process(message: Event<I>) : O"))))),(0,r.kt)("p",null,"This method passes the input message type ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," as a parameter and expects the output message type ",(0,r.kt)("inlineCode",{parentName:"p"},"O")," to be returned."),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import com.google.inject.Inject\nimport global.genesis.commons.annotation.Module\nimport global.genesis.db.rx.entity.multi.AsyncEntityDb\nimport global.genesis.eventhandler.typed.async.AsyncEventHandler\nimport global.genesis.gen.dao.Company\nimport global.genesis.message.core.event.Event\nimport global.genesis.message.core.event.EventReply\n\n@Moduleclass EventCompanyHandlerAsync @Inject constructor(        \n    private val entityDb: AsyncEntityDb,        \n    private val companyService: CompanyService\n) : AsyncEventHandler<Company, EventReply> {   \n    override suspend fun process(message: Event<Company>): EventReply {       \n        val company = message.details        \n        // custom code block..        \n        return EventReply.EventAck()    \n    }\n}\n")),(0,r.kt)("p",null,"The methods below are provided as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncEventHandler"),"; they provide an easy way of creating ",(0,r.kt)("inlineCode",{parentName:"p"},"EventReply")," responses."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> AsyncEventHandler<I, EventReply>.ack(): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> AsyncEventHandler<I, EventReply>.ack(generated: List<Map<String, Any>> = emptyList()): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> AsyncEventHandler<I, EventReply>.nack(throwable: Throwable): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> AsyncEventHandler<I, EventReply>.nack(error: String): EventReply"))))),(0,r.kt)("p",null,"Using these helper methods, you could simplify the previous implementation like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module\nimport global.genesis.eventhandler.typed.async.AsyncEventHandler\nimport global.genesis.message.core.event.Event\nimport global.genesis.message.core.event.EventReply\n\n@Moduleclass EventCompanyHandlerAsync : AsyncEventHandler<Company, EventReply> {    \n    override suspend fun process(message: Event<Company>): EventReply {        \n        val company = message.details        \n        // custom code block..        \n        return ack()    \n    }\n}\n")),(0,r.kt)("h3",{id:"asyncvalidatingeventhandler"},"AsyncValidatingEventHandler"),(0,r.kt)("p",null,"In the previous example, there was no distinction between validation and commit blocks, which is possible in GPAL Event Handlers. In order to have a better separation of concerns using custom Event Handlers, you can implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncValidatingEventHandler")," interface, which is defined as:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface AsyncValidatingEventHandler<I : Any, O : Outbound> : AsyncEventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"Using this interface, you do not need to override the ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," method; you can split your logic into validation and commit stages. There are various methods of implementing this, which are described below:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"suspend fun onValidate(message: Event<I>): O"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"suspend fun onCommit(message: Event<I>): O"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module\nimport global.genesis.eventhandler.typed.async.AsyncValidatingEventHandler\nimport global.genesis.message.core.event.Event\nimport global.genesis.message.core.event.EventReply\n\n@Moduleclass TestCompanyHandlerAsync : AsyncValidatingEventHandler<Company, EventReply> {\n    override suspend fun onValidate(message: Event<Company>): EventReply {        \n        val company = message.details        \n        // custom code block..        \n        return ack()    \n    }    \n    \n    override suspend fun onCommit(message: Event<Company>): EventReply {        \n        val company = message.details        \n        // custom code block..        \n        return ack()    \n    }\n}\n")),(0,r.kt)("p",null,"If the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"validate"),"\xa0flag is received as\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", only the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate"),"\xa0code block will be executed. If the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"validate"),"\xa0flag is received as\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", both the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate"),"\xa0and\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onCommit"),"\xa0blocks will be executed."),(0,r.kt)("h3",{id:"asynccontextvalidatingeventhandler"},"AsyncContextValidatingEventHandler"),(0,r.kt)("p",null,"In some cases, you might want to carry information from the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate"),"\xa0code block to the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onCommit"),"\xa0code block for efficiency purposes. (For example, if several database look-ups happen in\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate"),"\xa0and you want to reuse that information.) Using the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncContextValidatingEventHandler"),"\xa0interface, you can provide this context information from the validation stage to the commit stage. See the interface below:\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"interface AsyncContextValidatingEventHandler<I : Any, O : Outbound, C : Any> : AsyncEventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation-1"},"Implementation","[\u200b]"),(0,r.kt)("p",null,"As with the previous example, when using this interface, you do not need to override the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"process"),"\xa0method. The different methods for implementing this are described below:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"suspend fun onValidate(message: Event<I>): ValidationResult<O, C>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"suspend fun onCommit(message: Event<I>, context: C?): O"))))),(0,r.kt)("p",null,"The\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"validationResult"),"\xa0methods are provided to help with the context creation:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O): ValidationResult<O, C>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O, context: C): ValidationResult<O, C>"))))),(0,r.kt)("p",null,"The type\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"C"),"\xa0represents the contextual information we want to provide, and it can be any Java/Kotlin type. Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module\nimport global.genesis.eventhandler.typed.async.AsyncContextValidatingEventHandler\nimport global.genesis.message.core.event.Event\nimport global.genesis.message.core.event.EventReply\nimport global.genesis.message.core.event.ValidationResult\n\n@Moduleclass TestCompanyHandlerAsync : AsyncContextValidatingEventHandler<Company, EventReply, String> {    \n    override suspend fun onValidate(message: Event<Company>): ValidationResult<EventReply, String> {        \n        val company = message.details        \n        // custom code block..        \n        val companyName = company.companyName        \n        return validationResult(ack(), companyName)    \n    }    \n    \n    override suspend fun onCommit(message: Event<Company>, context: String?): EventReply {        \n        if(context != null) {            \n            // Do something with the context        \n        }        \n        val company = message.details        \n        // custom code block..        \n        return ack()    \n    }\n}\n")),(0,r.kt)("h2",{id:"rx3"},"Rx3"),(0,r.kt)("p",null,"The mechanism explained in\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#async"},"Async"),"\xa0can be recycled and reapplied in Rx3 Event Handlers."),(0,r.kt)("h3",{id:"rx3eventhandler"},"Rx3EventHandler"),(0,r.kt)("p",null,"In a similar fashion to\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncEventHandler"),", there is an Rx3 implementation flavour. It works in a very similar way to\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#asynceventhandler"},(0,r.kt)("inlineCode",{parentName:"a"},"AsyncEventHandler")),", but requires different return types (i.e. we expect to return RxJava3\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"Single<O>"),"\xa0type, instead of just the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"O"),"\xa0type)."),(0,r.kt)("p",null,"See the interface definition below:\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"interface Rx3EventHandler<I : Any, O : Outbound> : Rx3EventWorkflowProcessor<I, O>, EventHandler")),(0,r.kt)("h3",{id:"implementation-2"},"Implementation"),(0,r.kt)("p",null,"The mandatory method for implementing this is:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"process"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun process(message: Event<I>) : Single<O>"))))),(0,r.kt)("h3",{id:"helper-methods"},"Helper methods"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> Rx3EventHandler<I, EventReply>.ack(): Single<EventReply>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> Rx3EventHandler<I, EventReply>.ack(generated: List<Map<String, Any>> = emptyList()): Single<EventReply>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> Rx3EventHandler<I, EventReply>.nack(throwable: Throwable): Single<EventReply>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> Rx3EventHandler<I, EventReply>.nack(error: String): Single<EventReply>"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module    \nimport global.genesis.eventhandler.typed.rx3.Rx3EventHandler    \nimport global.genesis.gen.dao.Company    \nimport global.genesis.message.core.event.Event    \nimport global.genesis.message.core.event.EventReply    \nimport io.reactivex.rxjava3.core.Single    \n\n@Module    \nclass TestCompanyHandlerRx3 : Rx3EventHandler<Company, EventReply> {        \n    override fun process(message: Event<Company>): Single<EventReply> {            \n        return ack()        \n    }    \n}\n")),(0,r.kt)("h3",{id:"rx3validatingeventhandler"},"Rx3ValidatingEventHandler"),(0,r.kt)("p",null,"The same applies to an Rx3ValidatingEventHandler. It is similar to\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#asyncvalidatingeventhandler"},"AsyncValidatingEventHandler"),"\xa0in every way, but the return type is still\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"Single<O>"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface Rx3ValidatingEventHandler<I : Any, O : Outbound> : Rx3EventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation-3"},"Implementation"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onValidate(message: Event<I>): Single<O>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onCommit(message: Event<I>): Single<O>"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module    \nimport global.genesis.eventhandler.typed.rx3.Rx3ValidatingEventHandler    \nimport global.genesis.gen.dao.Company    \nimport global.genesis.message.core.event.Event    \nimport global.genesis.message.core.event.EventReply    \nimport io.reactivex.rxjava3.core.Single    \n\n@Module    \nclass TestCompanyHandlerRx3 : Rx3ValidatingEventHandler<Company, EventReply> {        \n    override fun onValidate(message: Event<Company>): Single<EventReply> {            \n        val company = message.details            \n        // custom code block..            \n        return ack()        \n    }        \n    \n    override fun onCommit(message: Event<Company>): Single<EventReply> {            \n        val company = message.details            \n        // custom code block..            \n        return ack()        \n    }    \n}\n")),(0,r.kt)("h3",{id:"rx3contextvalidatingeventhandler"},"Rx3ContextValidatingEventHandler"),(0,r.kt)("p",null,"And the same goes for\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"Rx3ContextValidatingEventHandler"),"\xa0in relation to\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#asynccontextvalidatingeventhandler"},"AsyncContextValidatingEventHandler"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface Rx3ContextValidatingEventHandler<I : Any, O : Outbound, C : Any> : Rx3EventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation-4"},"Implementation"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onValidate(message: Event<I>): Single<ValidationResult<O, C>>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onCommit(message: Event<I>, context: C?): Single<O>"))))),(0,r.kt)("h3",{id:"helper-methods-1"},"Helper methods"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O): ValidationResult<O, C>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O, context: C): ValidationResult<O, C>"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import global.genesis.commons.annotation.Module    \nimport global.genesis.eventhandler.typed.rx3.Rx3ContextValidatingEventHandler    \nimport global.genesis.gen.dao.Company    \nimport global.genesis.message.core.event.Event    \nimport global.genesis.message.core.event.EventReply    \nimport global.genesis.message.core.event.ValidationResult    \nimport io.reactivex.rxjava3.core.Single    \n\n@Module    \nclass TestCompanyHandlerRx3 : Rx3ContextValidatingEventHandler<Company, EventReply, String> {        \n    override fun onValidate(message: Event<Company>): Single<ValidationResult<EventReply, String>> {            \n        val company = message.details            \n        // custom code block..            \n        val companyName = company.companyName            \n        return Single.just(validationResult(EventReply.EventAck(), companyName))        \n    }        \n        \n    override fun onCommit(message: Event<Company>, context: String?): Single<EventReply> {            \n        if (context != null) {            \n            // Do something with the context            \n        }           \n        val company = message.details            \n        // custom code block..            \n        return ack()        \n    }    \n}\n")),(0,r.kt)("h2",{id:"sync"},"Sync"),(0,r.kt)("p",null,"Sync works similarly to\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#async"},"Async"),"\xa0and\xa0",(0,r.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/#rx3"},"Rx3"),", but in this case, there is no\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"Single<O>"),"\xa0returned and no\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"suspend"),"\xa0modifier used for Kotlin coroutines. The expected output of the Event Handler logic is just the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"O"),"\xa0type."),(0,r.kt)("h3",{id:"synceventhandler"},"SyncEventHandler",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#synceventhandlerdirect-link-to-heading"},"\u200b")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface SyncEventHandler<I : Any, O : Outbound> : SyncEventWorkflowProcessor<I, O>, EventHandler")),(0,r.kt)("h3",{id:"implementation-5"},"Implementation",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#implementationdirect-link-to-heading-5"},"\u200b")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"process"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun process(message: Event<I>) : O"))))),(0,r.kt)("h3",{id:"helper-methods-2"},"Helper methods",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#helper-methodsdirect-link-to-heading-2"},"\u200b")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> SyncEventHandler<I, EventReply>.ack(): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> SyncEventHandler<I, EventReply>.ack(generated: List<Map<String, Any>> = emptyList()): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> SyncEventHandler<I, EventReply>.nack(throwable: Throwable): EventReply"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nack"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun <I : Any> SyncEventHandler<I, EventReply>.nack(error: String): EventReply"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"    import global.genesis.commons.annotation.Module    \n    import global.genesis.eventhandler.typed.sync.SyncEventHandler    \n    import global.genesis.gen.dao.Company    \n    import global.genesis.message.core.event.Event    \n    import global.genesis.message.core.event.EventReply    \n    @Module    \n    class TestCompanyHandlerSync : SyncEventHandler<Company, EventReply> {        \n        override fun process(message: Event<Company>): EventReply {            \n            return ack()        \n        }    \n    }\n")),(0,r.kt)("h2",{id:"syncvalidatingeventhandler"},"SyncValidatingEventHandler",(0,r.kt)("a",{parentName:"h2",href:"/database/api-reference/event-handler-api/#syncvalidatingeventhandlerdirect-link-to-heading"},"\u200b")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface SyncValidatingEventHandler<I : Any, O : Outbound> : SyncEventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation-6"},"Implementation",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#implementationdirect-link-to-heading-6"},"\u200b")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onValidate(message: Event<I>): O"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onCommit(message: Event<I>): O"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"    import global.genesis.commons.annotation.Module    \n    import global.genesis.eventhandler.typed.sync.SyncValidatingEventHandler    \n    import global.genesis.gen.dao.Company    \n    import global.genesis.message.core.event.Event    \n    import global.genesis.message.core.event.EventReply    \n    \n    @Module    \n    class TestCompanyHandlerSync : SyncValidatingEventHandler<Company, EventReply> {        \n        override fun onValidate(message: Event<Company>): EventReply {            \n            val company = message.details           \n            return ack()        \n        }        \n        \n        override fun onCommit(message: Event<Company>): EventReply {            \n            val company = message.details            \n            return ack()        \n        }\n    }\n")),(0,r.kt)("h2",{id:"synccontextvalidatingeventhandler"},"SyncContextValidatingEventHandler",(0,r.kt)("a",{parentName:"h2",href:"/database/api-reference/event-handler-api/#synccontextvalidatingeventhandlerdirect-link-to-heading"},"\u200b")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"interface SyncContextValidatingEventHandler<I : Any, O : Outbound, C : Any> : SyncEventHandler<I, O>")),(0,r.kt)("h3",{id:"implementation-7"},"Implementation",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#implementationdirect-link-to-heading-7"},"\u200b")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onValidate"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onValidate(message: Event<I>): ValidationResult<O, C>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"onCommit"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun onCommit(message: Event<I>, context: C?): O"))))),(0,r.kt)("h3",{id:"helper-methods-3"},"Helper methods",(0,r.kt)("a",{parentName:"h3",href:"/database/api-reference/event-handler-api/#helper-methodsdirect-link-to-heading-3"},"\u200b")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O): ValidationResult<O, C>"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"validationResult"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fun validationResult(result: O, context: C): ValidationResult<O, C>"))))),(0,r.kt)("p",null,"Here is an example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Kotlin"),(0,r.kt)("li",{parentName:"ul"},"Java")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"    import global.genesis.commons.annotation.Module    \n    import global.genesis.eventhandler.typed.sync.SyncContextValidatingEventHandler    \n    import global.genesis.gen.dao.Company    \n    import global.genesis.message.core.event.Event    \n    import global.genesis.message.core.event.EventReply    \n    import global.genesis.message.core.event.ValidationResult    \n    \n    @Module    \n    class TestCompanyHandlerSync : SyncContextValidatingEventHandler<Company, EventReply, String> {        \n        override fun onValidate(message: Event<Company>): ValidationResult<EventReply, String> {            \n            val company = message.details            \n            // custom code block..            \n            val companyName = company.companyName            \n            return validationResult(ack(), companyName)        \n        }        \n        \n        override fun onCommit(message: Event<Company>, context: String?): EventReply {            \n            if (context != null) {                \n                // Do something with the context            \n            }            \n            val company = message.details            \n            // custom code block..            \n            return ack()        \n        }    \n    }\n")))}k.isMDXComponent=!0}}]);