"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[52909],{85162:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(67294),r=n(86010),s="tabItem_Ymn6";function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(s,i),hidden:n},t)}},65488:function(e,t,n){n.d(t,{Z:function(){return m}});var a=n(87462),r=n(67294),s=n(86010),i=n(72389),o=n(67392),l=n(7094),u=n(12466),d="tabList__CuJ",p="tabItem_LNqP";function c(e){var t,n,i=e.lazy,c=e.block,m=e.defaultValue,h=e.values,T=e.groupId,E=e.className,A=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=h?h:A.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),R=(0,o.l)(f,(function(e,t){return e.value===t.value}));if(R.length>0)throw new Error('Docusaurus error: Duplicate values "'+R.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var g=null===m?m:null!=(t=null!=m?m:null==(n=A.find((function(e){return e.props.default})))?void 0:n.props.value)?t:A[0].props.value;if(null!==g&&!f.some((function(e){return e.value===g})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var F=(0,l.U)(),S=F.tabGroupChoices,v=F.setTabGroupChoices,_=(0,r.useState)(g),I=_[0],N=_[1],q=[],y=(0,u.o5)().blockElementScrollPositionUntilNextRender;if(null!=T){var b=S[T];null!=b&&b!==I&&f.some((function(e){return e.value===b}))&&N(b)}var D=function(e){var t=e.currentTarget,n=q.indexOf(t),a=f[n].value;a!==I&&(y(t),N(a),null!=T&&v(T,String(a)))},O=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,r=q.indexOf(e.currentTarget)+1;n=null!=(a=q[r])?a:q[0];break;case"ArrowLeft":var s,i=q.indexOf(e.currentTarget)-1;n=null!=(s=q[i])?s:q[q.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,s.Z)("tabs-container",d)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},E)},f.map((function(e){var t=e.value,n=e.label,i=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:I===t?0:-1,"aria-selected":I===t,key:t,ref:function(e){return q.push(e)},onKeyDown:O,onFocus:D,onClick:D},i,{className:(0,s.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":I===t})}),null!=n?n:t)}))),i?(0,r.cloneElement)(A.filter((function(e){return e.props.value===I}))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},A.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==I})}))))}function m(e){var t=(0,i.Z)();return r.createElement(c,(0,a.Z)({key:String(t)},e))}},24384:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return d},default:function(){return T},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return m}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),i=(n(61839),n(65488)),o=n(85162),l=["components"],u={title:"Custom Endpoints - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","integration","custom endpoints","advanced"],tags:["server","integration","custom endpoints","advanced"]},d=void 0,p={unversionedId:"server/integration/custom-endpoints/advanced",id:"version-2022.3/server/integration/custom-endpoints/advanced",title:"Custom Endpoints - Advanced",description:"Introduction | Basics |  Advanced | Examples | Configuring runtime | Testing",source:"@site/versioned_docs/version-2022.3/03_server/10_integration/07_custom-endpoints/03_advanced.md",sourceDirName:"03_server/10_integration/07_custom-endpoints",slug:"/server/integration/custom-endpoints/advanced",permalink:"/server/integration/custom-endpoints/advanced",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"integration",permalink:"/tags/integration"},{label:"custom endpoints",permalink:"/tags/custom-endpoints"},{label:"advanced",permalink:"/tags/advanced"}],version:"2022.3",sidebarPosition:3,frontMatter:{title:"Custom Endpoints - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","integration","custom endpoints","advanced"],tags:["server","integration","custom endpoints","advanced"]},sidebar:"serverModulesSidebar",previous:{title:"Basics",permalink:"/server/integration/custom-endpoints/basics"},next:{title:"Examples",permalink:"/server/integration/custom-endpoints/examples"}},c={},m=[{value:"A more advanced example of custom endpoints",id:"a-more-advanced-example-of-custom-endpoints",level:2},{value:"AttachmentCommon",id:"attachmentcommon",level:3},{value:"AttachmentDownloadEndpoint",id:"attachmentdownloadendpoint",level:3},{value:"AttachmentUploadEndpoint",id:"attachmentuploadendpoint",level:3}],h={toc:m};function T(e){var t=e.components,n=(0,r.Z)(e,l);return(0,s.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/introduction/"},"Introduction")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/basics/"},"Basics")," |  ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/advanced/"},"Advanced")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/examples/"},"Examples")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/configuring-runtime/"},"Configuring runtime")," | ",(0,s.kt)("a",{parentName:"p",href:"/server/integration/custom-endpoints/testing/"},"Testing")),(0,s.kt)("h2",{id:"a-more-advanced-example-of-custom-endpoints"},"A more advanced example of custom endpoints"),(0,s.kt)("p",null,"Here is a collection of three classes that make up two custom endpoints: one for file upload, and one for file download. The third class defines a common set of useful methods for use by both endpoints."),(0,s.kt)("p",null,"These endpoints do not implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"requiresAuth()")," method from the ",(0,s.kt)("inlineCode",{parentName:"p"},"WebEndpoint")," interface, and instead use the default return value of ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,s.kt)("h3",{id:"attachmentcommon"},"AttachmentCommon"),(0,s.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,s.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Module\nclass AttachmentCommon @Inject constructor(\n    @Named(SYS_DEF_ATTACHMENT_STORAGE_PATH) sysdefFileStoragePath: String,\n    @Named(SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS) sysdefPayloadMaxSize: Long,\n    @Named(SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX) sysdefReqFolderPrefix: String?,\n    private val db: RxEntityDb,\n) {\n    var fileStoragePath: Path? = null\n        private set\n    var maxFileSize: Long = 0\n        private set\n    private var REQUEST_FOLDER_PREFIX: String? = null\n\n    init {\n        require(!validateAttachmentServerStorageSetup(sysdefFileStoragePath))\n        setupMaxPayloadSize(sysdefPayloadMaxSize)\n        setupReqFolderPrefix(sysdefReqFolderPrefix)\n    }\n\n    fun errorResponse(e: FileEndpointException): DefaultFullHttpResponse {\n        val responseJson = ("{\\"ERROR\\": \\"" + e.message + "\\"}").toByteArray()\n        val responseBuffer = Unpooled.wrappedBuffer(responseJson)\n        val response = DefaultFullHttpResponse(\n            HttpVersion.HTTP_1_1,\n            e.httpResponseStatus,\n            responseBuffer\n        )\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON)\n        HttpUtil.setContentLength(response, responseJson.size.toLong())\n        return response\n    }\n\n    fun errorResponse(errorMsg: String, errorResponseStatus: HttpResponseStatus?): DefaultFullHttpResponse {\n        val responseJson = "{\\"ERROR\\": \\"$errorMsg\\"}".toByteArray()\n        val responseBuffer = Unpooled.wrappedBuffer(responseJson)\n        val response = DefaultFullHttpResponse(\n            HttpVersion.HTTP_1_1,\n            errorResponseStatus,\n            responseBuffer\n        )\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON)\n        HttpUtil.setContentLength(response, responseJson.size.toLong())\n        return response\n    }\n\n    fun successResponse(responseText: String): DefaultFullHttpResponse {\n        val responseJson = "{\\"SUCCESS\\": \\"$responseText\\"}".toByteArray()\n        val responseBuffer = Unpooled.wrappedBuffer(responseJson)\n        val response = DefaultFullHttpResponse(\n            HttpVersion.HTTP_1_1,\n            HttpResponseStatus.OK,\n            responseBuffer\n        )\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON)\n        HttpUtil.setContentLength(response, responseJson.size.toLong())\n        return response\n    }\n\n    @Throws(FileEndpointException::class)\n    fun getValidatedUserName(sessionAuthToken: String): String {\n        val foundUserSession = db.get(UserSession.BySessionAuthToken(sessionAuthToken)).blockingGet()\n        return foundUserSession?.userName\n            ?: throw FileEndpointException("No session found for auth token",\n                HttpResponseStatus.BAD_REQUEST)\n    }\n\n    fun getFullPathToFile(requestId: Int, fileName: String?): Path {\n        return Paths.get(getFullPathToRequestAttachmentFolder(requestId).toString(), fileName)\n    }\n\n    fun getFullPathToApprovalFile(requestId: Int, approvalId: Int, fileName: String?): Path {\n        return Paths.get(getFullPathToApprovalAttachmentFolder(requestId, approvalId).toString(), fileName)\n    }\n\n    fun getFullPathToFile(requestId: Int, approvalType: String?, fileName: String?): Path {\n        return Paths.get(getFullPathToRequestAttachmentFolder(requestId).toString(), approvalType, fileName)\n    }\n\n    fun getFullPathToRequestAttachmentFolder(requestId: Int): Path {\n        return Paths.get(fileStoragePath.toString(), getRequestFolder(requestId))\n    }\n\n    fun getFullPathToApprovalAttachmentFolder(requestId: Int, approvalId: Int): Path {\n        return Paths.get(fileStoragePath.toString(), getRequestFolder(requestId), "approval_$approvalId")\n    }\n\n    private fun getRequestFolder(requestId: Int): String {\n        return String.format("%s%s", REQUEST_FOLDER_PREFIX, requestId)\n    }\n\n    private fun validateAttachmentServerStorageSetup(sysdefFileStoragePath: String): Boolean {\n        if (sysdefFileStoragePath.isEmpty()) {\n            LOG.error("System Definition Item {} must be defined. Shutting down", SYS_DEF_ATTACHMENT_STORAGE_PATH)\n            ProcessUtils.shutdownProcess(-1)\n            return false\n        } else {\n            fileStoragePath = Paths.get(sysdefFileStoragePath)\n            //Check it\'s a valid dir and you have write access\n            if (!Files.exists(fileStoragePath)) {\n                try {\n                    Files.createDirectories(fileStoragePath)\n                } catch (e: IOException) {\n                    LOG.error("Unable to create file storage path configured in System Definition Item {}. Shutting down.",\n                        SYS_DEF_ATTACHMENT_STORAGE_PATH, e)\n                    ProcessUtils.shutdownProcess(-1)\n                    return false\n                }\n            } else if (!Files.isWritable(fileStoragePath)) {\n                LOG.error("No write access to file storage path configured in System Definition Item {}. Shutting down.",\n                    SYS_DEF_ATTACHMENT_STORAGE_PATH)\n                ProcessUtils.shutdownProcess(-1)\n                return false\n            }\n        }\n        return true\n    }\n\n    private fun setupMaxPayloadSize(sysdefPayloadMaxSize: Long?) {\n        maxFileSize = if (sysdefPayloadMaxSize == null) {\n            LOG.warn("System Definition Item {} not defined. Using default value 1Mb!",\n                SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS)\n            1000000L // Default is 1 Mb\n        } else {\n            sysdefPayloadMaxSize\n        }\n    }\n\n    private fun setupReqFolderPrefix(sysdefReqFolderPrefix: String?) {\n        REQUEST_FOLDER_PREFIX = if (sysdefReqFolderPrefix == null || sysdefReqFolderPrefix.isEmpty()) {\n            val defaultVal = "request_"\n            LOG.warn("System Definition Item {} not defined. Using default value \'{}\'",\n                SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX,\n                defaultVal)\n            defaultVal\n        } else {\n            sysdefReqFolderPrefix\n        }\n    }\n\n    companion object {\n        private val LOG: Logger = LoggerFactory.getLogger(AttachmentCommon::class.java)\n        const val ATTACHMENT_PATH = "attachment-handler"\n        private const val SYS_DEF_ATTACHMENT_STORAGE_PATH = "ATTACHMENT_STORAGE_PATH"\n        private const val SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX = "REQUEST_ATTACHMENT_FOLDER_PREFIX"\n        private const val SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS = "ATTACHMENT_MAX_SIZE_IN_BITS"\n    }\n}\n'))),(0,s.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'@Module\npublic class AttachmentCommon {\n\n    private static final Logger LOG = LoggerFactory.getLogger(AttachmentCommon.class);\n    static final String ATTACHMENT_PATH = "attachment-handler";\n\n    private static final String SYS_DEF_ATTACHMENT_STORAGE_PATH = "ATTACHMENT_STORAGE_PATH";\n    private static final String SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX = "REQUEST_ATTACHMENT_FOLDER_PREFIX";\n    private static final String SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS = "ATTACHMENT_MAX_SIZE_IN_BITS";\n\n    private Path FILE_STORAGE_PATH;\n    private long PAYLOAD_MAX_SIZE;\n    private String REQUEST_FOLDER_PREFIX;\n    private final RxEntityDb db;\n\n    @Inject\n    public AttachmentCommon(@Named(SYS_DEF_ATTACHMENT_STORAGE_PATH) String sysdefFileStoragePath,\n                             @Named(SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS) Long sysdefPayloadMaxSize,\n                             @Named(SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX) String sysdefReqFolderPrefix,\n                             final RxEntityDb db) {\n        this.db = db;\n\n        if (!validateAttachmentServerStorageSetup(sysdefFileStoragePath)) {\n            //Invalid setup, process will shut down\n            return;\n        }\n\n        setupMaxPayloadSize(sysdefPayloadMaxSize);\n\n        setupReqFolderPrefix(sysdefReqFolderPrefix);\n    }\n\n    public Path getFileStoragePath() {\n        return FILE_STORAGE_PATH;\n    }\n\n    long getMaxFileSize() {\n        return PAYLOAD_MAX_SIZE;\n    }\n\n    DefaultFullHttpResponse errorResponse(FileEndpointException e) {\n        byte[] responseJson = ("{\\"ERROR\\": \\"" + e.getMessage() + "\\"}").getBytes();\n        ByteBuf responseBuffer = Unpooled.wrappedBuffer(responseJson);\n        DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n                HTTP_1_1,\n                e.getHttpResponseStatus(),\n                responseBuffer\n        );\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);\n        HttpUtil.setContentLength(response, responseJson.length);\n        return response;\n    }\n\n    DefaultFullHttpResponse errorResponse(String errorMsg, HttpResponseStatus errorResponseStatus) {\n        byte[] responseJson = ("{\\"ERROR\\": \\"" + errorMsg + "\\"}").getBytes();\n        ByteBuf responseBuffer = Unpooled.wrappedBuffer(responseJson);\n        DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n                HTTP_1_1,\n                errorResponseStatus,\n                responseBuffer\n        );\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);\n        HttpUtil.setContentLength(response, responseJson.length);\n        return response;\n    }\n\n    DefaultFullHttpResponse successResponse(String responseText) {\n        byte[] responseJson = ("{\\"SUCCESS\\": \\"" + responseText + "\\"}").getBytes();\n        ByteBuf responseBuffer = Unpooled.wrappedBuffer(responseJson);\n        DefaultFullHttpResponse response = new DefaultFullHttpResponse(\n                HTTP_1_1,\n                HttpResponseStatus.OK,\n                responseBuffer\n        );\n        response.headers().add(HttpHeaderNames.CONTENT_TYPE, HttpHeaderValues.APPLICATION_JSON);\n        HttpUtil.setContentLength(response, responseJson.length);\n        return response;\n    }\n\n    String getValidatedUserName(String sessionAuthToken) throws FileEndpointException {\n        UserSession foundUserSession = db.get(new UserSession.BySessionAuthToken(sessionAuthToken)).blockingGet();\n        if (foundUserSession != null) {\n            return foundUserSession.getUserName();\n        } else {\n            throw new FileEndpointException("No session found for auth token", HttpResponseStatus.BAD_REQUEST);\n        }\n    }\n\n    Path getFullPathToFile(int requestId, String fileName) {\n        return Paths.get(getFullPathToRequestAttachmentFolder(requestId).toString(), fileName);\n    }\n\n    Path getFullPathToApprovalFile(int requestId, int approvalId, String fileName) {\n        return Paths.get(getFullPathToApprovalAttachmentFolder(requestId, approvalId).toString(), fileName);\n    }\n\n    Path getFullPathToFile(int requestId, String approvalType, String fileName) {\n        return Paths.get(getFullPathToRequestAttachmentFolder(requestId).toString(), approvalType, fileName);\n    }\n\n    public Path getFullPathToRequestAttachmentFolder(int requestId) {\n        return Paths.get(getFileStoragePath().toString(), getRequestFolder(requestId));\n    }\n\n    public Path getFullPathToApprovalAttachmentFolder(int requestId, int approvalId) {\n        return Paths.get(getFileStoragePath().toString(), getRequestFolder(requestId), "approval_" + approvalId);\n    }\n\n    private String getRequestFolder(int requestId) {\n        return String.format("%s%s", REQUEST_FOLDER_PREFIX, requestId);\n    }\n\n    private boolean validateAttachmentServerStorageSetup(final String sysdefFileStoragePath) {\n        if (sysdefFileStoragePath.isEmpty()) {\n            LOG.error("System Definition Item {} must be defined. Shutting down", SYS_DEF_ATTACHMENT_STORAGE_PATH);\n            ProcessUtils.shutdownProcess(-1);\n            return false;\n        } else {\n            this.FILE_STORAGE_PATH = Paths.get(sysdefFileStoragePath);\n            //Check it\'s a valid dir and you have write access\n            if (!Files.exists(FILE_STORAGE_PATH)) {\n                try {\n                    Files.createDirectories(FILE_STORAGE_PATH);\n                } catch (IOException e) {\n                    LOG.error("Unable to create file storage path configured in System Definition Item {}. Shutting down.",\n                            SYS_DEF_ATTACHMENT_STORAGE_PATH, e);\n                    ProcessUtils.shutdownProcess(-1);\n                    return false;\n                }\n            } else if (!Files.isWritable(FILE_STORAGE_PATH)) {\n                LOG.error("No write access to file storage path configured in System Definition Item {}. Shutting down.",\n                        SYS_DEF_ATTACHMENT_STORAGE_PATH);\n                ProcessUtils.shutdownProcess(-1);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void setupMaxPayloadSize(Long sysdefPayloadMaxSize) {\n        if (sysdefPayloadMaxSize == null) {\n            LOG.warn("System Definition Item {} not defined. Using default value 1Mb!", SYS_DEF_ATTACHMENT_MAX_SIZE_IN_BITS);\n            this.PAYLOAD_MAX_SIZE = 1000000L;  // Default is 1 Mb\n        } else {\n            this.PAYLOAD_MAX_SIZE = sysdefPayloadMaxSize;\n        }\n    }\n\n    private void setupReqFolderPrefix(String sysdefReqFolderPrefix) {\n        if (sysdefReqFolderPrefix == null || sysdefReqFolderPrefix.isEmpty()) {\n            String defaultVal = "request_";\n            LOG.warn("System Definition Item {} not defined. Using default value \'{}\'",\n                    SYS_DEF_REQUEST_ATTACHMENT_FOLDER_PREFIX,\n                    defaultVal);\n            this.REQUEST_FOLDER_PREFIX = defaultVal;\n        } else {\n            this.REQUEST_FOLDER_PREFIX = sysdefReqFolderPrefix;\n        }\n    }\n}\n')))),(0,s.kt)("h3",{id:"attachmentdownloadendpoint"},"AttachmentDownloadEndpoint"),(0,s.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,s.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Module\nclass AttachmentDownloadEndpoint\n@Inject constructor(\n    private val registry: WebEndpointRegistry,\n    private val attachmentCommon: AttachmentCommon,\n    private val db: RxEntityDb\n) : WebEndpoint {\n    @PostConstruct\n    fun init() {\n        registry.registerEndpoint(AttachmentCommon.ATTACHMENT_PATH, this)\n    }\n\n    override fun allowedMethods(): Set<RequestType> {\n        return ALLOWED_HTTP_METHODS\n    }\n\n    override fun name(): String {\n        return "download"\n    }\n\n    override fun process(method: String, request: FullHttpRequest, conn: Channel): Any {\n\n        val parameters = QueryStringDecoder(request.uri()).parameters()\n        val requestAttachment: RequestAttachment\n        return try {\n            val parametersList = parameters[FORM_ATTACHMENT_ID]\n            if (parametersList == null || parametersList.size == 0) {\n                LOG.error("{} is not present in request parameters.", FORM_ATTACHMENT_ID)\n                throw FileEndpointException("$FORM_ATTACHMENT_ID is not present in request parameters.",\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR)\n            }\n            //Validate attachment id and get the validated attachment details from Db\n            val attachmentId = validateAttachmentId(parametersList[0])\n            requestAttachment = getValidatedFileUploadId(attachmentId)\n\n            // Retrieve and return the file, check exists and readable else error\n            val pathToFile: Path? = if (requestAttachment.requestApprovalId != null) {\n                attachmentCommon.getFullPathToApprovalFile(requestAttachment.requestId,\n                    requestAttachment.requestApprovalId!!,\n                    requestAttachment.fileName)\n            } else {\n                attachmentCommon.getFullPathToFile(requestAttachment.requestId, requestAttachment.fileName)\n            }\n            if (pathToFile == null) {\n                throw FileEndpointException("Unable to find file for " +\n                    FORM_ATTACHMENT_ID + " " + requestAttachment.byAttachmentId(),\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR)\n            }\n            val fileToSend = pathToFile.toFile()\n            if (!fileToSend.exists() || fileToSend.isDirectory || !fileToSend.canRead()) {\n                throw FileEndpointException("Unable to find file for " +\n                    FORM_ATTACHMENT_ID + " " + requestAttachment.byAttachmentId(),\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR)\n            }\n\n            //Create chunkedFile and reply with it\n            val chunkedFile = getChunkedFile(fileToSend)\n\n            //Send response with file\n            val response: HttpResponse = DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)\n            HttpUtil.setContentLength(response, fileToSend.length())\n            setContentTypeHeader(response, fileToSend)\n\n            // Write the initial line and the header.\n            conn.write(response)\n            LOG.debug("Returning file {}", fileToSend.absolutePath)\n            HttpChunkedInput(chunkedFile)\n        } catch (e: FileEndpointException) {\n            attachmentCommon.errorResponse(e.message?: e.toString(), e.httpResponseStatus)\n        }\n    }\n\n    @Throws(FileEndpointException::class)\n    private fun getValidatedFileUploadId(attachmentId: Int): RequestAttachment {\n        //Make sure dealId is valid, else reject\n        return try {\n            val requestAttachment = RequestAttachment.builder().setAttachmentId(attachmentId).build()\n            val foundRequestAttachment = db.get(requestAttachment).blockingGet()\n            if (foundRequestAttachment == null) {\n                //Not a valid attachment ID\n                LOG.error("Received {} {} which is not known to system", FORM_ATTACHMENT_ID, attachmentId)\n                throw FileEndpointException("Unknown $FORM_ATTACHMENT_ID $attachmentId received",\n                    HttpResponseStatus.BAD_REQUEST)\n            } else if (foundRequestAttachment.fileName.isEmpty()) {\n                LOG.error("Received {} {} which is in DB but no FILE_NAME set on Db Record",\n                    FORM_ATTACHMENT_ID,\n                    attachmentId)\n                throw FileEndpointException("No FileName found for $FORM_ATTACHMENT_ID $attachmentId",\n                    HttpResponseStatus.INTERNAL_SERVER_ERROR)\n            }\n            foundRequestAttachment\n        } catch (e: FileEndpointException) {\n            throw e\n        } catch (e: Exception) {\n            LOG.error("Unable to lookup {} {} in DB", FORM_ATTACHMENT_ID, attachmentId, e)\n            throw FileEndpointException("Unable to validate $FORM_ATTACHMENT_ID $attachmentId exists in DB",\n                HttpResponseStatus.INTERNAL_SERVER_ERROR)\n        }\n    }\n\n    @Throws(FileEndpointException::class)\n    private fun getChunkedFile(fileToChunk: File): ChunkedFile {\n        return try {\n            LOG.debug("Chunking file {}. Total space of file = {}", fileToChunk.absolutePath, fileToChunk.totalSpace)\n            ChunkedFile(fileToChunk)\n        } catch (e: IOException) {\n            LOG.error("Unable to chunk file {}", fileToChunk.absoluteFile, e)\n            throw FileEndpointException("Unable to convert original file to send",\n                HttpResponseStatus.INTERNAL_SERVER_ERROR)\n        }\n    }\n\n    @Throws(FileEndpointException::class)\n    private fun validateAttachmentId(attachmentId: String?): Int {\n        if (attachmentId == null || attachmentId.isEmpty()) {\n            LOG.error("Received no {} parameter", FORM_ATTACHMENT_ID)\n            throw FileEndpointException("No $FORM_ATTACHMENT_ID supplied", HttpResponseStatus.BAD_REQUEST)\n        }\n        return try {\n            attachmentId.toInt()\n        } catch (e: NumberFormatException) {\n            LOG.error("Received invalid format for {} parameter - {} - must be an int",\n                FORM_ATTACHMENT_ID,\n                attachmentId)\n            throw FileEndpointException("No $FORM_ATTACHMENT_ID supplied", HttpResponseStatus.BAD_REQUEST)\n        }\n    }\n\n    companion object {\n        private val LOG = LoggerFactory.getLogger(AttachmentDownloadEndpoint::class.java)\n        private val ALLOWED_HTTP_METHODS: Set<RequestType> = setOf(RequestType.GET)\n        private const val FORM_ATTACHMENT_ID = "attachment-id"\n        private fun setContentTypeHeader(response: HttpResponse, file: File) {\n            val mimeTypesMap = MimetypesFileTypeMap()\n            response.headers()[HttpHeaderNames.CONTENT_TYPE] = mimeTypesMap.getContentType(file.path)\n            response.headers()["Content-disposition"] = "attachment; filename=" + file.name\n            response.headers()["Access-Control-Expose-Headers"] =\n                "Content-disposition, Content-Type, Accept, X-Requested-With"\n        }\n    }\n}\n'))),(0,s.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'@Module\npublic class AttachmentDownloadEndpoint implements WebEndpoint {\n\n    private static final Logger LOG = LoggerFactory.getLogger(AttachmentDownloadEndpoint.class);\n    private static final Set<RequestType> ALLOWED_HTTP_METHODS = ImmutableSet.of(RequestType.GET);\n\n    private final WebEndpointRegistry registry;\n    private final AttachmentCommon attachmentCommon;\n    private final RxEntityDb db;\n\n    private static final String FORM_ATTACHMENT_ID = "attachment-id";\n\n    @Inject\n    public AttachmentDownloadEndpoint(final WebEndpointRegistry registry,\n                                      final AttachmentCommon attachmentCommon,\n                                      final RxEntityDb db) {\n        this.registry = registry;\n        this.db = db;\n        this.attachmentCommon = attachmentCommon;\n    }\n\n    @PostConstruct\n    public void init() {\n        this.registry.registerEndpoint(AttachmentCommon.ATTACHMENT_PATH, this);\n    }\n\n    @NotNull\n    @Override\n    public Set<RequestType> allowedMethods() {\n        return ALLOWED_HTTP_METHODS;\n    }\n\n    @NotNull\n    @Override\n    public String name() {\n        return "download";\n    }\n\n    @NotNull\n    @Override\n    public Object process(@NotNull String s, FullHttpRequest fullHttpRequest, @NotNull Channel channel) {\n\n        //Lookup the attachment-id, handle any errors\n        Map<String, List<String>> parameters = new QueryStringDecoder(fullHttpRequest.uri()).parameters();\n\n        RequestAttachment requestAttachment;\n        try {\n            List<String> parametersList = parameters.get(FORM_ATTACHMENT_ID);\n            if (parametersList == null || parametersList.size() == 0) {\n                LOG.error("{} is not present in request parameters.", FORM_ATTACHMENT_ID);\n                throw new FileEndpointException(FORM_ATTACHMENT_ID + " is not present in request parameters.", HttpResponseStatus.INTERNAL_SERVER_ERROR);\n            }\n            //Validate attachment id and get the validated attachment details from Db\n            int attachmentId = validateAttachmentId(parametersList.get(0));\n            requestAttachment = getValidatedFileUploadId(attachmentId);\n\n            // Retrieve and return the file, check exists and readable else error\n            Path pathToFile;\n            if (requestAttachment.getRequestApprovalId() != null) {\n                pathToFile = attachmentCommon.getFullPathToApprovalFile(requestAttachment.getRequestId(), requestAttachment.getRequestApprovalId(), requestAttachment.getFileName());\n            } else {\n                pathToFile = attachmentCommon.getFullPathToFile(requestAttachment.getRequestId(), requestAttachment.getFileName());\n            }\n\n            if (pathToFile == null) {\n                throw new FileEndpointException("Unable to find file for " +\n                        FORM_ATTACHMENT_ID + " " + requestAttachment.byAttachmentId(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n            }\n\n            File fileToSend = pathToFile.toFile();\n            if(!fileToSend.exists() || fileToSend.isDirectory() || !fileToSend.canRead()) {\n                throw new FileEndpointException("Unable to find file for " +\n                        FORM_ATTACHMENT_ID + " " + requestAttachment.byAttachmentId(), HttpResponseStatus.INTERNAL_SERVER_ERROR);\n            }\n\n            //Create chunkedFile and reply with it\n            ChunkedFile chunkedFile = getChunkedFile(fileToSend);\n\n            //Send response with file\n            HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);\n            HttpUtil.setContentLength(response, fileToSend.length());\n            setContentTypeHeader(response, fileToSend);\n\n            // Write the initial line and the header.\n            channel.write(response);\n\n            LOG.debug("Returning file {}", fileToSend.getAbsolutePath());\n\n            return new HttpChunkedInput(chunkedFile);\n        } catch (FileEndpointException e) {\n            return attachmentCommon.errorResponse(e.getMessage(), e.getHttpResponseStatus());\n        }\n    }\n\n    private RequestAttachment getValidatedFileUploadId(Integer attachmentId) throws FileEndpointException {\n        //Make sure dealId is valid, else reject\n        try {\n            RequestAttachment requestAttachment = RequestAttachment.builder().setAttachmentId(attachmentId).build();\n            RequestAttachment foundRequestAttachment = db.get(requestAttachment).blockingGet();\n           if (foundRequestAttachment == null) {\n                //Not a valid attachment ID\n                LOG.error("Received {} {} which is not known to system", FORM_ATTACHMENT_ID, attachmentId);\n                throw new FileEndpointException("Unknown " + FORM_ATTACHMENT_ID + " " + attachmentId + " received", HttpResponseStatus.BAD_REQUEST);\n            } else if (foundRequestAttachment.getFileName().isEmpty()) {\n                LOG.error("Received {} {} which is in DB but no FILE_NAME set on Db Record", FORM_ATTACHMENT_ID, attachmentId);\n                throw new FileEndpointException("No FileName found for " + FORM_ATTACHMENT_ID + " " + attachmentId, HttpResponseStatus.INTERNAL_SERVER_ERROR);\n            }\n            return foundRequestAttachment;\n        } catch (FileEndpointException e) {\n            throw e;\n        } catch (Exception e) {\n            LOG.error("Unable to lookup {} {} in DB", FORM_ATTACHMENT_ID, attachmentId, e);\n            throw new FileEndpointException("Unable to validate " + FORM_ATTACHMENT_ID + " " + attachmentId + " exists in DB", HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        }\n\n    }\n\n    private ChunkedFile getChunkedFile(File fileToChunk) throws FileEndpointException {\n        try {\n            LOG.debug("Chunking file {}. Total space of file = {}", fileToChunk.getAbsolutePath(), fileToChunk.getTotalSpace());\n            return new ChunkedFile(fileToChunk);\n        } catch (IOException e) {\n            LOG.error("Unable to chunk file {}", fileToChunk.getAbsoluteFile(), e);\n            throw new FileEndpointException("Unable to convert original file to send", HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    private int validateAttachmentId(String attachmentId) throws FileEndpointException {\n        if (attachmentId == null || attachmentId.isEmpty()) {\n            LOG.error("Received no {} parameter", FORM_ATTACHMENT_ID);\n            throw new FileEndpointException("No " + FORM_ATTACHMENT_ID + " supplied", HttpResponseStatus.BAD_REQUEST);\n        }\n        try {\n            return Integer.parseInt(attachmentId);\n        } catch (NumberFormatException e) {\n            LOG.error("Received invalid format for {} parameter - {} - must be an int", FORM_ATTACHMENT_ID, attachmentId);\n            throw new FileEndpointException("No " + FORM_ATTACHMENT_ID + " supplied", HttpResponseStatus.BAD_REQUEST);\n        }\n    }\n\n    private static void setContentTypeHeader(HttpResponse response, File file) {\n        MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap();\n        response.headers().set(CONTENT_TYPE, mimeTypesMap.getContentType(file.getPath()));\n        response.headers().set("Content-disposition", "attachment; filename=" + file.getName());\n        response.headers().set("Access-Control-Expose-Headers", "Content-disposition, Content-Type, Accept, X-Requested-With");\n    }\n}\n')))),(0,s.kt)("h3",{id:"attachmentuploadendpoint"},"AttachmentUploadEndpoint"),(0,s.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,s.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Module\nclass AttachmentUploadEndpoint\n@Inject constructor(\n    private val registry: WebEndpointRegistry,\n    private val attachmentCommon: AttachmentCommon,\n    private val db: RxEntityDb,\n) : WebEndpoint {\n    @PostConstruct\n    fun init() {\n        registry.registerEndpoint(AttachmentCommon.ATTACHMENT_PATH, this)\n    }\n\n    override fun allowedMethods(): Set<RequestType> {\n        return ALLOWED_HTTP_METHODS\n    }\n\n    override fun name(): String {\n        return "upload"\n    }\n\n    override fun process(method: String, request: FullHttpRequest, conn: Channel): Any {\n        try {\n            //Get user from session token\n            val username = attachmentCommon.getValidatedUserName(request.headers()["SESSION_AUTH_TOKEN"])\n\n            //Get and validate request input\n            var requestId: Int? = null\n            var requestApprovalId: Int? = null\n            var isRccFinalAction = false\n            val uploadedFiles: MutableList<MemoryFileUpload> = ArrayList()\n            val uploadedFilesDescriptions: MutableList<String> = ArrayList()\n            val uploadedAttachmentTypes: MutableList<AttachmentType> = ArrayList()\n            val dataFactory = DefaultHttpDataFactory(false)\n            dataFactory.setMaxLimit(attachmentCommon.maxFileSize)\n            try {\n                val postDecoder = HttpPostRequestDecoder(dataFactory, request)\n                val postData = postDecoder.bodyHttpDatas\n\n                //Parse out all the data we need\n                for (data in postData) {\n                    // General Post Content\n                    if (data.httpDataType == InterfaceHttpData.HttpDataType.Attribute) {\n                        val attribute = data as MemoryAttribute\n                        LOG.debug("attribute {}", attribute)\n                        LOG.debug("attribute.getName() {}", attribute.name)\n                        LOG.debug("attribute.getValue() {}", attribute.value)\n                        when (attribute.name) {\n                            FORM_REQUEST_ID -> {\n                                requestId = attribute.value.toInt()\n                                LOG.debug("requestId : $requestId")\n                            }\n                            FORM_REQUEST_APPROVAL_ID -> {\n                                requestApprovalId = attribute.value.toInt()\n                                LOG.debug("approvalId : $requestApprovalId")\n                            }\n                            FORM_FILE_DESCRIPTION -> {\n                                val fileDescription = attribute.value\n                                uploadedFilesDescriptions.add(fileDescription)\n                                LOG.debug("File-{} description : {}", uploadedFilesDescriptions.size, fileDescription)\n                            }\n                            FORM_ATTACHMENT_TYPE -> {\n                                val attachmentType = attribute.value\n                                uploadedAttachmentTypes.add(AttachmentType.valueOf(attachmentType))\n                                LOG.debug("File-{} attachment-type : {}", uploadedAttachmentTypes.size, attachmentType)\n                            }\n                            IS_RCC_FINAL_ACTION -> {\n                                val rccFinalAction = attribute.value\n                                LOG.debug("rccFinalAction {}", rccFinalAction)\n                                if ("true" == rccFinalAction) {\n                                    isRccFinalAction = true\n                                    LOG.debug("IS rccFinalAction {}", isRccFinalAction)\n                                }\n                            }\n                            else -> LOG.debug("Ignoring unknown form attribute {} : {}",\n                                attribute.name,\n                                attribute.value)\n                        }\n                    } else if (data.httpDataType == InterfaceHttpData.HttpDataType.FileUpload) {\n                        // File Uploaded\n                        val fileUpload = data as MemoryFileUpload\n                        uploadedFiles.add(fileUpload)\n                        LOG.debug("File-{} file-name : {}", uploadedFiles.size, fileUpload.name)\n                    }\n                }\n                if (uploadedFiles.size == 0) {\n                    LOG.error("No file uploaded with request")\n                    throw FileEndpointException("No file uploaded", HttpResponseStatus.BAD_REQUEST)\n                }\n\n                // Check if the request is valid\n                if (!isRccFinalAction) {\n                    isValidRequest(requestId!!)\n                }\n                val uploadTime = DateTime()\n                for ((currentIndex, uploadedFile) in uploadedFiles.withIndex()) {\n                    val fileDescription = uploadedFilesDescriptions[currentIndex]\n                    val attachmentType = uploadedAttachmentTypes[currentIndex]\n                    val requestAttachmentRecord: RequestAttachment = getRequestAttachment(requestId!!,\n                        requestApprovalId,\n                        uploadedFile.filename,\n                        fileDescription,\n                        attachmentType,\n                        uploadTime,\n                        username)\n                    saveFile(requestAttachmentRecord, uploadedFile)\n                    updateDb(requestAttachmentRecord)\n                }\n            } catch (ex: ErrorDataDecoderException) {\n                LOG.error("Error decoding file", ex)\n                throw FileEndpointException(ex.message, HttpResponseStatus.BAD_REQUEST)\n            } catch (e: FileEndpointException) {\n                throw e\n            } catch (e: java.lang.Exception) {\n                LOG.error("File upload failed to process!", e)\n                throw FileEndpointException("File upload failed", HttpResponseStatus.BAD_REQUEST)\n            }\n        } catch (e: FileEndpointException) {\n            return attachmentCommon.errorResponse(e)\n        }\n        return attachmentCommon.successResponse("Request attachment(s) added successfully")\n    }\n\n    @Throws(FileEndpointException::class)\n    private fun saveFile(requestAttachmentRecord: RequestAttachment, uploadFile: MemoryFileUpload) {\n        LOG.debug("Saving uploaded file with details: {}", requestAttachmentRecord)\n        val newFileFullName: Path\n        var filePath = attachmentCommon.getFullPathToRequestAttachmentFolder(requestAttachmentRecord.requestId)\n        if (requestAttachmentRecord.requestApprovalId != null) {\n            newFileFullName = attachmentCommon.getFullPathToFile(requestAttachmentRecord.requestId,\n                "approval_" + requestAttachmentRecord.requestApprovalId,\n                requestAttachmentRecord.fileName)\n            filePath = attachmentCommon.getFullPathToApprovalAttachmentFolder(requestAttachmentRecord.requestId,\n                requestAttachmentRecord.requestApprovalId!!)\n        } else {\n            newFileFullName =\n                attachmentCommon.getFullPathToFile(requestAttachmentRecord.requestId, requestAttachmentRecord.fileName)\n        }\n        try {\n            Files.createDirectories(filePath)\n            Files.createFile(newFileFullName)\n            Files.write(newFileFullName, uploadFile.get())\n            LOG.debug("Uploaded file {} written", newFileFullName)\n        } catch (e: FileAlreadyExistsException) {\n            val errorMsg = "File " + requestAttachmentRecord.fileName + " already exists against this request."\n            LOG.error(errorMsg, e)\n            throw FileEndpointException(errorMsg, HttpResponseStatus.INTERNAL_SERVER_ERROR)\n        } catch (e: IOException) {\n            val errorMsg = "Error handling uploaded file " + e.message\n            LOG.error(errorMsg, e)\n            throw FileEndpointException(errorMsg, HttpResponseStatus.INTERNAL_SERVER_ERROR)\n        }\n    }\n\n    private fun updateDb(requestAttachment: RequestAttachment) {\n        db.insert(requestAttachment).subscribe()\n    }\n\n    private fun getRequestAttachment(\n        requestId: Int, requestApprovalId: Int?, fileName: String,\n        fileDescription: String, attachmentType: AttachmentType, uploadTime: DateTime, userName: String,\n    ): RequestAttachment {\n        val requestAttachment: Builder = RequestAttachment.builder()\n            .setRequestId(requestId)\n            .setFileName(fileName)\n            .setFileDescription(fileDescription)\n            .setAttachmentType(attachmentType)\n            .setLastUpdatedBy(userName)\n            .setLastUpdatedAt(uploadTime)\n        if (requestApprovalId != null) {\n            requestAttachment.setRequestApprovalId(requestApprovalId)\n        }\n        return requestAttachment.build()\n    }\n\n    private fun isValidRequest(requestId: Int) {\n        val request = db.get(Request.byId(requestId)).blockingGet()\n        if (request != null) {\n            if (request.requestState == RequestState.CLOSED || request.requestState == RequestState.APPROVED_PENDING_IMPLEMENTATION) {\n                throw FileEndpointException("Request ID $requestId not in valid state to attach files",\n                    HttpResponseStatus.BAD_REQUEST)\n            }\n        } else {\n            throw FileEndpointException("Request ID $requestId not found", HttpResponseStatus.BAD_REQUEST)\n        }\n    }\n\n    companion object {\n        private val LOG = LoggerFactory.getLogger(AttachmentUploadEndpoint::class.java)\n        private val ALLOWED_HTTP_METHODS: Set<RequestType> = setOf(RequestType.POST)\n        private const val FORM_REQUEST_ID = "request-id"\n        private const val FORM_REQUEST_APPROVAL_ID = "request-approval-id"\n        private const val FORM_FILE_DESCRIPTION = "file-description"\n        private const val FORM_ATTACHMENT_TYPE = "attachment-type"\n        private const val IS_RCC_FINAL_ACTION = "is_rcc_final_action"\n    }\n}\n'))),(0,s.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'@Module\npublic class AttachmentUploadEndpoint implements WebEndpoint {\n\n    private static final Logger LOG = LoggerFactory.getLogger(AttachmentUploadEndpoint.class);\n    private static final Set<RequestType> ALLOWED_HTTP_METHODS = ImmutableSet.of(RequestType.POST);\n    private static final String FORM_REQUEST_ID = "request-id";\n    private static final String FORM_REQUEST_APPROVAL_ID = "request-approval-id";\n    private static final String FORM_FILE_DESCRIPTION = "file-description";\n    private static final String FORM_ATTACHMENT_TYPE = "attachment-type";\n    private static final String IS_RCC_FINAL_ACTION = "is_rcc_final_action";\n\n    private final WebEndpointRegistry registry;\n    private final AttachmentCommon attachmentCommon;\n    private final RxEntityDb db;\n\n    @Inject\n    public AttachmentUploadEndpoint(final WebEndpointRegistry registry,\n                                    final RxEntityDb db,\n                                    final AttachmentCommon attachmentCommon) {\n        this.registry = registry;\n        this.db = db;\n        this.attachmentCommon = attachmentCommon;\n    }\n\n    @PostConstruct\n    public void init() {\n        this.registry.registerEndpoint(AttachmentCommon.ATTACHMENT_PATH, this);\n    }\n\n    @NotNull\n    @Override\n    public String name() {\n        return "upload";\n    }\n\n    @NotNull\n    @Override\n    public Set<RequestType> allowedMethods() {\n        return ALLOWED_HTTP_METHODS;\n    }\n\n    @NotNull\n    @Override\n    public Object process(@NotNull String s, @NotNull FullHttpRequest fullHttpRequest, @NotNull Channel channel) {\n        try {\n            //Get user from session token\n            String username = attachmentCommon.getValidatedUserName(fullHttpRequest.headers().get("SESSION_AUTH_TOKEN"));\n\n            //Get and validate request input\n            Integer requestId = null;\n            Integer requestApprovalId = null;\n            Boolean isRccFinalAction = false;\n\n            List<MemoryFileUpload> uploadedFiles = new ArrayList<>();\n            List<String> uploadedFilesDescriptions = new ArrayList<>();\n            List<AttachmentType> uploadedAttachmentTypes = new ArrayList<>();\n            DefaultHttpDataFactory dataFactory = new DefaultHttpDataFactory(false);\n            dataFactory.setMaxLimit(attachmentCommon.getMaxFileSize());\n            try {\n                HttpPostRequestDecoder postDecoder = new HttpPostRequestDecoder(dataFactory, fullHttpRequest);\n                List<InterfaceHttpData> postData = postDecoder.getBodyHttpDatas();\n\n                //Parse out all the data we need\n                for (InterfaceHttpData data : postData) {\n                    // General Post Content\n                    if (data.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) {\n                        MemoryAttribute attribute = (MemoryAttribute) data;\n\n                        LOG.debug("attribute {}", attribute);\n                        LOG.debug("attribute.getName() {}", attribute.getName());\n                        LOG.debug("attribute.getValue() {}", attribute.getValue());\n\n                        switch (attribute.getName()) {\n                            case FORM_REQUEST_ID:\n                                requestId = Integer.parseInt(attribute.getValue());\n                                LOG.debug("requestId : " + requestId);\n                                break;\n                            case FORM_REQUEST_APPROVAL_ID:\n                                requestApprovalId = Integer.parseInt(attribute.getValue());\n                                LOG.debug("approvalId : " + requestApprovalId);\n                                break;\n                            case FORM_FILE_DESCRIPTION:\n                                String fileDescription = attribute.getValue();\n                                uploadedFilesDescriptions.add(fileDescription);\n                                LOG.debug("File-{} description : {}", uploadedFilesDescriptions.size(), fileDescription);\n                                break;\n                            case FORM_ATTACHMENT_TYPE:\n                                String attachmentType = attribute.getValue();\n                                uploadedAttachmentTypes.add(AttachmentType.valueOf(attachmentType));\n                                LOG.debug("File-{} attachment-type : {}", uploadedAttachmentTypes.size(), attachmentType);\n                                break;\n                            case IS_RCC_FINAL_ACTION:\n                                String rccFinalAction = attribute.getValue();\n                                LOG.debug("rccFinalAction {}", rccFinalAction);\n                                if("true".equals(rccFinalAction)){\n                                    isRccFinalAction = true;\n                                    LOG.debug("IS rccFinalAction {}", isRccFinalAction);\n                                }\n                                break;\n                            default:\n                                LOG.debug("Ignoring unknown form attribute {} : {}", attribute.getName(), attribute.getValue());\n                                break;\n                        }\n                    } else if (data.getHttpDataType() == InterfaceHttpData.HttpDataType.FileUpload) {\n                        // File Uploaded\n                        MemoryFileUpload fileUpload = (MemoryFileUpload) data;\n                        uploadedFiles.add(fileUpload);\n                        LOG.debug("File-{} file-name : {}", uploadedFiles.size(), fileUpload.getName());\n                    }\n                }\n                if (uploadedFiles.size() == 0) {\n                    LOG.error("No file uploaded with request");\n                    throw new FileEndpointException("No file uploaded", HttpResponseStatus.BAD_REQUEST);\n                }\n\n                // Check if the request is valid\n                if(!isRccFinalAction){\n                    isValidRequest(requestId);\n                }\n\n                DateTime uploadTime = new DateTime();\n                int currentIndex = 0;\n                for (MemoryFileUpload uploadedFile : uploadedFiles) {\n\n                    String fileDescription = uploadedFilesDescriptions.get(currentIndex);\n                    AttachmentType attachmentType = uploadedAttachmentTypes.get(currentIndex);\n\n                    RequestAttachment requestAttachmentRecord = getRequestAttachment(requestId, requestApprovalId, uploadedFile.getFilename(),fileDescription, attachmentType, uploadTime, username);\n\n                    saveFile(requestAttachmentRecord, uploadedFile);\n                    updateDb(requestAttachmentRecord);\n\n                    currentIndex++;\n                }\n            } catch (HttpPostRequestDecoder.ErrorDataDecoderException ex) {\n                LOG.error("Error decoding file", ex);\n                throw new FileEndpointException(ex.getMessage(), HttpResponseStatus.BAD_REQUEST);\n            } catch (FileEndpointException e) {\n                throw e;\n            } catch (Exception e) {\n                LOG.error("File upload failed to process!", e);\n                throw new FileEndpointException("File upload failed", HttpResponseStatus.BAD_REQUEST);\n            }\n        } catch (FileEndpointException e) {\n            return attachmentCommon.errorResponse(e);\n        }\n        return attachmentCommon.successResponse("Request attachment(s) added successfully");\n    }\n\n    private void saveFile(RequestAttachment requestAttachmentRecord, MemoryFileUpload uploadFile) throws FileEndpointException {\n\n        LOG.debug("Saving uploaded file with details: {}", requestAttachmentRecord);\n\n        Path newFileFullName;\n        Path filePath = attachmentCommon.getFullPathToRequestAttachmentFolder(requestAttachmentRecord.getRequestId());\n\n        if (requestAttachmentRecord.getRequestApprovalId() != null) {\n            newFileFullName = attachmentCommon.getFullPathToFile(requestAttachmentRecord.getRequestId(), "approval_" + requestAttachmentRecord.getRequestApprovalId(), requestAttachmentRecord.getFileName());\n            filePath = attachmentCommon.getFullPathToApprovalAttachmentFolder(requestAttachmentRecord.getRequestId(), requestAttachmentRecord.getRequestApprovalId());\n\n        } else {\n            newFileFullName = attachmentCommon.getFullPathToFile(requestAttachmentRecord.getRequestId(), requestAttachmentRecord.getFileName());\n        }\n\n        try {\n\n            Files.createDirectories(filePath);\n            Files.createFile(newFileFullName);\n            Files.write(newFileFullName, uploadFile.get());\n            LOG.debug("Uploaded file {} written", newFileFullName);\n\n        } catch (FileAlreadyExistsException e) {\n\n            String errorMsg = "File " + requestAttachmentRecord.getFileName() + " already exists against this request.";\n            LOG.error(errorMsg, e);\n            throw new FileEndpointException(errorMsg, HttpResponseStatus.INTERNAL_SERVER_ERROR);\n\n        } catch (IOException e) {\n\n            String errorMsg = "Error handling uploaded file " + e.getMessage();\n            LOG.error(errorMsg, e);\n            throw new FileEndpointException(errorMsg, HttpResponseStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n\n    private void updateDb(RequestAttachment requestAttachment) {\n        db.insert(requestAttachment).subscribe();\n    }\n\n    // Turn the received request meta into a dao DB record for writing\n    private RequestAttachment getRequestAttachment(Integer requestId, Integer requestApprovalId, String fileName,\n                                                   String fileDescription, AttachmentType attachmentType, DateTime uploadTime, String userName) {\n        RequestAttachment.Builder requestAttachment =\n                RequestAttachment.builder()\n                        .setRequestId(requestId)\n                        .setFileName(fileName)\n                        .setFileDescription(fileDescription)\n                        .setAttachmentType(attachmentType)\n                        .setLastUpdatedBy(userName)\n                        .setLastUpdatedAt(uploadTime);\n\n        if (requestApprovalId != null) {\n            requestAttachment.setRequestApprovalId(requestApprovalId);\n        }\n        return requestAttachment.build();\n    }\n\n    private void isValidRequest(Integer requestId) throws FileEndpointException {\n        @Nullable Request request = db.get(new Request.ById(requestId)).blockingGet();\n        if (request != null) {\n            if (request.getRequestState().equals(RequestState.CLOSED) ||\n                request.getRequestState().equals(RequestState.APPROVED_PENDING_IMPLEMENTATION)\n            ) {\n                throw new FileEndpointException("Request ID " + requestId + " not in valid state to attach files", HttpResponseStatus.BAD_REQUEST);\n            }\n        } else {\n            throw new FileEndpointException("Request ID " + requestId + " not found", HttpResponseStatus.BAD_REQUEST);\n        }\n    }\n}\n')))))}T.isMDXComponent=!0}}]);