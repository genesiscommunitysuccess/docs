"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[84526],{76828:function(e,n,a){a.r(n),a.d(n,{assets:function(){return p},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return c}});var t=a(87462),i=a(63366),r=(a(67294),a(3905)),o=(a(61839),["components"]),l={title:"Event Handler - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","event handler","advanced"],tags:["server","event handler","advanced"]},s=void 0,d={unversionedId:"server/event-handler/advanced",id:"version-2022.3/server/event-handler/advanced",title:"Event Handler - Advanced",description:"Custom reply message type",source:"@site/versioned_docs/version-2022.3/03_server/04_event-handler/03_advanced.md",sourceDirName:"03_server/04_event-handler",slug:"/server/event-handler/advanced",permalink:"/server/event-handler/advanced",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"event handler",permalink:"/tags/event-handler"},{label:"advanced",permalink:"/tags/advanced"}],version:"2022.3",sidebarPosition:3,frontMatter:{title:"Event Handler - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","event handler","advanced"],tags:["server","event handler","advanced"]},sidebar:"serverModulesSidebar",previous:{title:"Basics",permalink:"/server/event-handler/basics"},next:{title:"Examples",permalink:"/server/event-handler/examples"}},p={},c=[{value:"Custom reply message type",id:"custom-reply-message-type",level:2},{value:"onException",id:"onexception",level:3},{value:"Permissioning and permissionCodes",id:"permissioning-and-permissioncodes",level:2},{value:"Dynamic permissions",id:"dynamic-permissions",level:3},{value:"Permission codes",id:"permission-codes",level:3},{value:"Auto auditing",id:"auto-auditing",level:2},{value:"Defining state machines",id:"defining-state-machines",level:2},{value:"Pending approvals",id:"pending-approvals",level:2},{value:"Set an event to require approval",id:"set-an-event-to-require-approval",level:3},{value:"Configuring allowed approvers",id:"configuring-allowed-approvers",level:3},{value:"Defining an Event Handler in GPAL",id:"defining-an-event-handler-in-gpal",level:2},{value:"Automatic import",id:"automatic-import",level:3}],m={toc:c};function u(e){var n=e.components,a=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,t.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"custom-reply-message-type"},"Custom reply message type"),(0,r.kt)("p",null,"If you use a custom reply message type, you won\u2019t be able to use the default ",(0,r.kt)("inlineCode",{parentName:"p"},"ack()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"validationAck()")," functions.  The custom message type needs to be returned from the method."),(0,r.kt)("p",null,"For a custom message type called ",(0,r.kt)("inlineCode",{parentName:"p"},"TradeEvent")," defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class TradeEvent(\n    val price: Double,\n    val quantity: Int,\n){\n    init{\n        require(price > 0) { "Price cannot be negative "}\n        require(quantity > 0) { "Quantity cannot be negative "}\n    }\n}\n')),(0,r.kt)("p",null,"...and a custom message reply type called ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomTradeEventReply")," defined as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed class CustomTradeEventReply : Outbound() {\n    class TradeEventValidateAck : CustomTradeEventReply()\n    data class TradeEventAck(val tradeId: String) : CustomTradeEventReply()\n    data class TradeEventNack(val error: String) : CustomTradeEventReply()\n}\n")),(0,r.kt)("p",null,"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomTradeEventReply")," under ",(0,r.kt)("strong",{parentName:"p"},"{app-name}-messages")," and assemble. Once you have built, add ",(0,r.kt)("inlineCode",{parentName:"p"},'api(project(":alpha-messages"))')," to your build.gradle.kts file under ",(0,r.kt)("strong",{parentName:"p"},"{app-name}-script-config/build.gradle.kts"),"."),(0,r.kt)("p",null,"...you can now use the following example Event Handler below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'    eventHandler<TradeEvent, CustomTradeEventReply>(name = "CUSTOM_TRADE_EVENT") {\n        onException { event, throwable ->\n            CustomTradeEventReply.TradeEventNack(throwable.message!!)\n        }\n        onValidate {\n            val tradeEvent = it.details\n            val notional = tradeEvent.price?.times(tradeEvent.quantity!!.toDouble())\n            \n            require(notional!! < 1_000_000) { "Trade notional is too high" }\n            CustomTradeEventReply.TradeEventValidateAck()\n        }\n        onCommit { event ->\n            val trade = event.details\n            val result = entityDb.insert(trade)\n            CustomTradeEventReply.TradeEventAck(result.record.tradeId)\n        }\n    }\n')),(0,r.kt)("p",null,"The following code assumes you have built your fields and tables after you created your ",(0,r.kt)("inlineCode",{parentName:"p"},"TradeEvent")," under ",(0,r.kt)("strong",{parentName:"p"},"jvm/{app-name}-config")," with a primary key of ",(0,r.kt)("inlineCode",{parentName:"p"},"tradeId"),". If intelliJ can't find you ",(0,r.kt)("inlineCode",{parentName:"p"},"TradeEvent"),", go back and build your fields and tables as per the ",(0,r.kt)("a",{parentName:"p",href:"/getting-started/learn-the-basics/data-model/"},"Data Model Training"),"."),(0,r.kt)("h3",{id:"onexception"},"onException"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onException")," block can capture any exceptions thrown by the ",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"onCommit")," blocks and returns the expected reply message type (as shown in the last example). This function is particularly useful if you are using a custom message type; by default, Event Handlers will attempt to translate exceptions automatically to an ",(0,r.kt)("inlineCode",{parentName:"p"},"EventNack")," message, which might cause compatibility problems if you are using custom replies."),(0,r.kt)("h2",{id:"permissioning-and-permissioncodes"},"Permissioning and permissionCodes"),(0,r.kt)("p",null,"As with other GPAL files (e.g. Request Server and Data Server), you can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"permissioning")," block to define both dynamic permissions (AUTH) and fixed permissions (based on RIGHT_SUMMARY rights) on Event Handlers."),(0,r.kt)("h3",{id:"dynamic-permissions"},"Dynamic permissions"),(0,r.kt)("p",null,"For Event Handlers you need to use any class as event message type instead of table/view, which is similar to custom request-replies.\nIn the below example we use a generated database entity called ",(0,r.kt)("inlineCode",{parentName:"p"},"Company")," as message type of event ",(0,r.kt)("inlineCode",{parentName:"p"},"EVENT_AUTH_COMPANY_INSERT")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'    eventHandler<Company>(name = "AUTH_COMPANY_INSERT") {\n        permissioning {\n            auth(mapName = "COMPANY"){\n                field { companyName } \n            }\n        }\n\n        onCommit { event ->\n            val company = event.details\n            val result = entityDb.insert(company)\n            ack(listOf(mapOf("VALUE" to result.record.companyId)))\n        }\n    }\n')),(0,r.kt)("p",null,"If you use custom class instead of generated database entities as message-type of events, we recommend that you locate your classes within the messages module of your application. This is where we place all the custom message types for our application. You need to ensure that the ",(0,r.kt)("em",{parentName:"p"},"app-name"),(0,r.kt)("strong",{parentName:"p"},"-script-config")," module has a dependency on the messages module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'    api(project(":{app-name}-messages"))\n')),(0,r.kt)("h3",{id:"permission-codes"},"Permission codes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'    eventHandler<Company>(name = "AUTH_COMPANY_INSERT") {\n        permissionCodes = listOf("INSERT_TRADE")\n        onCommit { event ->\n            val company = event.details\n            val result = entityDb.insert(company)\n            ack(listOf(mapOf("VALUE" to result.record.companyId)))\n        }\n    }\n')),(0,r.kt)("p",null,"You can find out more details in our section on ",(0,r.kt)("a",{parentName:"p",href:"/server/access-control/authorisation-overview/"},"authorisation"),"."),(0,r.kt)("h2",{id:"auto-auditing"},"Auto auditing"),(0,r.kt)("p",null,"If the Event Handler message type is a database-generated entity that is auditable, Genesis automatically creates an audit record to the corresponding audit table for each database write operation. The audit fields are filled with the following values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"AUDIT_EVENT_TYPE: Event name"),(0,r.kt)("li",{parentName:"ul"},"AUDIT_EVENT_DATETIME: Autogenerated"),(0,r.kt)("li",{parentName:"ul"},"AUDIT_EVENT_TEXT: Optional \u201cREASON\u201d value sent as part of the event message"),(0,r.kt)("li",{parentName:"ul"},"AUDIT_EVENT_USER: Extracted from the event message")),(0,r.kt)("h2",{id:"defining-state-machines"},"Defining state machines"),(0,r.kt)("p",null,"State machines, which define the conditions for moving from one state to another, are defined within your Event Handler files. See more details about these in the section on ",(0,r.kt)("a",{parentName:"p",href:"/server/state-machine/introduction/"},"Defining your state machines"),"."),(0,r.kt)("h2",{id:"pending-approvals"},"Pending approvals"),(0,r.kt)("p",null,'The Genesis low-code platform has an in-built pending approval mechanism that can be used with Event Handlers. This is useful where particular events require a second user to approve them in order to take effect. Genesis Pending Approvals works with the concepts of \u201cdelayed\u201d events and "4-eyes check". '),(0,r.kt)("h3",{id:"set-an-event-to-require-approval"},"Set an event to require approval"),(0,r.kt)("p",null,'Any event can be marked to "require approval" as long as the ',(0,r.kt)("inlineCode",{parentName:"p"},"REQUIRES_APPROVAL")," flag is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," in the incoming message. "),(0,r.kt)("p",null,"To configure an event for a mandatory ",(0,r.kt)("inlineCode",{parentName:"p"},"REQUIRES_APPROVAL")," flag check, either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Override the ",(0,r.kt)("inlineCode",{parentName:"li"},"requiresPendingApproval")," method to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," in the custom Event Handler definitions.\nor"),(0,r.kt)("li",{parentName:"ul"},"Set the ",(0,r.kt)("inlineCode",{parentName:"li"},"requiresPendingApproval")," property to ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," in a GPAL Event Handler.")),(0,r.kt)("p",null,"Here is an example of a custom Event Handler definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'import global.genesis.commons.annotation.Module\nimport global.genesis.eventhandler.typed.async.AsyncValidatingEventHandler\nimport global.genesis.message.core.event.Event\nimport global.genesis.message.core.event.EventReply\n\n@Module\nclass TestCompanyHandlerAsync : AsyncValidatingEventHandler<Company, EventReply> {\n    // Override requiresPendingApproval here to make the "pending approval" flow mandatory.\n    override fun requiresPendingApproval(): Boolean = true\n    \n    override suspend fun onValidate(message: Event<Company>): EventReply {\n        val company = message.details\n        // custom code block..\n        return ack()\n    }\n\n    override suspend fun onCommit(message: Event<Company>): EventReply {\n        val company = message.details\n        // custom code block..\n        return ack()\n    }\n}\n')),(0,r.kt)("p",null,"or in a GPAL definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"\neventHandler {\n    eventHandler<Company> {\n        requiresPendingApproval = true\n        onCommit { event ->\n            val company = event.details\n            // custom code block..\n            ack()\n        }\n    }\n}\n")),(0,r.kt)("p",null,"Events submitted with a ",(0,r.kt)("inlineCode",{parentName:"p"},"REQUIRES_APPROVAL")," flag set to true are validated as usual (i.e. the ",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate")," method is run) and, if the validation is successful, the \u201cdelayed\u201d event is stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL")," table in a JSON format. "),(0,r.kt)("p",null,"Assuming the event is inserting, updating or deleting a target database record, it is possible to have multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL")," records associated with a single database entity. Use the event ",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate")," method to check for pre-existing approvals against the entities related to the event if you need to ensure there is only one pending approval per record. "),(0,r.kt)("p",null,"The validate method can also be used to determine if the incoming event needs approval e.g. checking if a particular field has been amended, or checking the tier on an incoming EVENT_ADD_CLIENT. If it does, then you can add the ",(0,r.kt)("inlineCode",{parentName:"p"},"REQUIRES_APPROVAL")," flag to the event message."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL")," record is keyed on an auto-generated ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ID")," and does not have a direct link to the original record. You have to create a link by adding \u201capproval entity\u201d details to the payload returned on an event ack in the ",(0,r.kt)("inlineCode",{parentName:"p"},"onValidate")," method. These details include the ",(0,r.kt)("inlineCode",{parentName:"p"},"ENTITY_TABLE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ENTITY_KEY"),". This allows you to decide how to identify the original record (e.g. creating a compound key in the case of multi-field keys). When the approval entity details are provided, the platform creates a record in the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ENTITY")," table and populates it with the details provided, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ID")," of the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL")," record. There is also an ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ENTITY_COUNTER"),", which is populated by the AUTH_CONSOLIDATOR process by default; this can be handy in order to easily know how many approvals are pending for a given entity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'    override suspend fun onValidate(message: Event<Company>): EventReply {\n        val company = message.details\n        // custom code block..\n        return ack(listOf(mapOf("ENTITY_TABLE" to "COMPANY", "ENTITY_ID" to company.companyId)))\n    }\n')),(0,r.kt)("p",null,"In order to display pending approvals against the original record in the GUI, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ENTITY")," table to join to the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL_ENTITY")," records in a view. You can then display the information using a Data Server or Request Server. The details of the pending event are stored in json format."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example APPROVAL DB record")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-DbM"},'TIMESTAMP          2018-09-19 09:29:51.111951844              NANO_TIMESTAMP\nAPPROVAL_ID        000000000000002APLO1                       STRING\nAPPROVAL_KEY       8a178f41-24c6-4cb3-b4e0-1996ae59bcddA...   STRING\nAPPROVAL_MESSAGE   Please approve this amendment              STRING\nAPPROVAL_STATUS    PENDING                                    ENUM[PENDING APPROVED CANCELLED REJECTED_BY_USER REJECTED_BY_SERVICE]\nDESTINATION        EEP_INTENT_SERVICE                         STRING\nMESSAGE_TYPE       EVENT_OPS_INTENT                           STRING\nEVENT_DETAILS      TRADE_ID = LCH20180917.18500000098 DE...   STRING\nEVENT_MESSAGE      {"MESSAGE_TYPE":"EVENT_OPS_INTENT","VAL... STRING\nUSER_NAME          CdsTest                                    STRING\n')),(0,r.kt)("h3",{id:"configuring-allowed-approvers"},"Configuring allowed approvers"),(0,r.kt)("p",null,"Once in the ",(0,r.kt)("inlineCode",{parentName:"p"},"APPROVAL")," table, the pending event can be cancelled, rejected or accepted by sending the following event messages to GENESIS_CLUSTER: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"EVENT_PENDING_APPROVAL_ACCEPT"),(0,r.kt)("li",{parentName:"ul"},"EVENT_PENDING_APPROVAL_CANCEL"),(0,r.kt)("li",{parentName:"ul"},"EVENT_PENDING_APPROVAL_REJECT")),(0,r.kt)("p",null,"All messages accept a ",(0,r.kt)("inlineCode",{parentName:"p"},"REASON_CODE")," in their metadata."),(0,r.kt)("p",null,"The platform ensures that users cannot approve their own events. Additional levels of control (e.g. based on user groups) can be added to the front end, to the event validate method, or can be specified in server-side configuration."),(0,r.kt)("p",null,"To configure the allowed approvers in a server-side configuration, you need to create a new xml file with the following content. You need to add the file name to the GENESIS_CLUSTER ",(0,r.kt)("inlineCode",{parentName:"p"},"<config></config>")," element in the site-specific version of the ",(0,r.kt)("strong",{parentName:"p"},"genesis-processes.xml"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},"<genesisCluster>\n    <preExpression>\n        <![CDATA[\n\n        ]]>\n    </preExpression>\n\n    <pendingApproval>\n        <insertPendingApproval>\n            <![CDATA[\n               true\n            ]]>\n        </insertPendingApproval>\n        <acceptPendingApproval>\n            <![CDATA[\n               true\n            ]]>\n        </acceptPendingApproval>\n        <rejectPendingApproval>\n            <![CDATA[\n               true\n            ]]>\n        </rejectPendingApproval>\n        <cancelPendingApproval>\n            <![CDATA[\n               true\n            ]]>\n        </cancelPendingApproval>\n    </pendingApproval>\n</genesisCluster>\n")),(0,r.kt)("p",null,'You can replace the "true" return value with Groovy code in each ',(0,r.kt)("inlineCode",{parentName:"p"},"pendingApproval")," block. The platform makes the following objects accessible to your code:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"userName")," - a string property containing the user name who triggered the event (insert, accept, reject or cancel)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"db")," - an RxDb property so you can access the database layer and do appropriate checks."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pendingApproval")," - the pending approval record stored in the database (only available in accept, reject or cancel events).")),(0,r.kt)("p",null,"With this xml configuration, you can look up the user's rights in the database and return ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),' only if the necessary rights are in place. For example, if your system has the concept of internal and external users and you only want to allow internal users to accept pending events, then you could check your custom user "ACCESS_TYPE" field as follows:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-xml"},'        ...\n        <acceptPendingApproval>\n            <![CDATA[\n               def searchRecord = new DbRecord("USER_ATTRIBUTES")\n               def userAttributes = db.get(searchRecord, "USER_ATTRIBUTES_BY_USER_NAME")\n               userAttributes?.getString("ACCESS_TYPE") == "INTERNAL"\n            ]]>\n        </acceptPendingApproval>\n        ...\n')),(0,r.kt)("h2",{id:"defining-an-event-handler-in-gpal"},"Defining an Event Handler in GPAL"),(0,r.kt)("p",null,"The following imports are automatically available inside GPAL Event Handlers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"import CodeBlock from '@theme/CodeBlock';\nimport Imports from '!!raw-loader!/examples/server/java/event-handlers/imports.java';\n\n<CodeBlock className=\"language-java\">{Imports}</CodeBlock>\n")),(0,r.kt)("h3",{id:"automatic-import"},"Automatic import"),(0,r.kt)("p",null,"The following properties are automatically available inside GPAL Event Handlers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val systemDefinition: SystemDefinitionService\nval rxDb: RxDb\nval entityDb: AsyncEntityDb\nval metaData: MetaDataRegistry\nval evaluatorPool: EvaluatorPool\nval messageDelegator: MessageDelegator\nval networkConfiguration: NetworkConfiguration\nval serviceDetailProvider: ServiceDetailProvider\nval genesisHFT: GenesisHFT\nval injector: Injector\nval clientConnectionsManager: ClientConnectionsManager\nval typedEventManager: TypedEventManager\n")))}u.isMDXComponent=!0}}]);