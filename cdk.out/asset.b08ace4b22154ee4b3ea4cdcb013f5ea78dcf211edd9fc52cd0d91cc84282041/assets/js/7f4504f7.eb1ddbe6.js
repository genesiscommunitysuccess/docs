"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[89017],{67371:function(e,n,a){a.r(n),a.d(n,{assets:function(){return p},contentTitle:function(){return r},default:function(){return N},frontMatter:function(){return d},metadata:function(){return o},toc:function(){return u}});var t=a(87462),i=a(63366),l=(a(67294),a(3905)),s=(a(61839),["components"]),d={title:"Views - advanced",sidebar_label:"Views - advanced",id:"views-advanced",keywords:["database","views","advanced"],tags:["database","views","advanced"]},r=void 0,o={unversionedId:"database/fields-tables-views/views/views-advanced",id:"database/fields-tables-views/views/views-advanced",title:"Views - advanced",description:"Fields",source:"@site/docs/02_database/01_fields-tables-views/03_views/02_views-advanced.md",sourceDirName:"02_database/01_fields-tables-views/03_views",slug:"/database/fields-tables-views/views/views-advanced",permalink:"/next/database/fields-tables-views/views/views-advanced",draft:!1,tags:[{label:"database",permalink:"/next/tags/database"},{label:"views",permalink:"/next/tags/views"},{label:"advanced",permalink:"/next/tags/advanced"}],version:"current",sidebarPosition:2,frontMatter:{title:"Views - advanced",sidebar_label:"Views - advanced",id:"views-advanced",keywords:["database","views","advanced"],tags:["database","views","advanced"]},sidebar:"databaseSidebar",previous:{title:"Views - basics",permalink:"/next/database/fields-tables-views/views/views-basics"},next:{title:"Views - examples",permalink:"/next/database/fields-tables-views/views/views-examples"}},p={},u=[{value:"Fields",id:"fields",level:2},{value:"Derived fields",id:"derived-fields",level:3},{value:"Joins",id:"joins",level:2},{value:"INNER vs OUTER joins",id:"inner-vs-outer-joins",level:3},{value:"Dictionary-joined tables",id:"dictionary-joined-tables",level:3},{value:"Parameterised joins",id:"parameterised-joins",level:3},{value:"Dynamic joins",id:"dynamic-joins",level:3},{value:"Examples",id:"examples",level:3},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4}],c={toc:u};function N(e){var n=e.components,a=(0,i.Z)(e,s);return(0,l.kt)("wrapper",(0,t.Z)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"fields"},"Fields"),(0,l.kt)("h3",{id:"derived-fields"},"Derived fields"),(0,l.kt)("p",null,"Derived fields are used to serve up fields that are not part of the tables that make up a given view. Their values are typically derived from fields in the tables."),(0,l.kt)("p",null,"It is possible to specify field inputs for derived fields as well as being able to specify a single entity as input. This has two main advantages:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"when a derived field has multiple inputs from a single table, only one input is required"),(0,l.kt)("li",{parentName:"ul"},"non-null fields on the entity will be non-null")),(0,l.kt)("p",null,"Syntax:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'derivedField("{field name}", FIELD_TYPE) {\n    withEntity(TABLE_NAME) { {optional parameter name} ->\n        {code}\n    }\n}\n')),(0,l.kt)("p",null,"With field input:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'derivedField("SPREAD", DOUBLE) {\n  withInput(INSTRUMENT_PRICE.BID_PRICE, INSTRUMENT_PRICE.ASK_PRICE) { bid, ask ->\n    if (ask == null || bid == null) null\n      else ask - bid\n    }\n}\n')),(0,l.kt)("p",null,"With entity input:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'derivedField("SPREAD", DOUBLE) {\n    withEntity(INSTRUMENT_PRICE) { price ->\n        price.askPrice - price.bidPrice\n    }\n}\n')),(0,l.kt)("p",null,"By default, all fields are populated in the entity. For larger tables, this might have a performance impact if many fields are loaded that are not used in the calculation or the final view. To mitigate this, you can specify to load either only non-null fields, or specify the fields to be populated. Non-null fields will always be populated. Let's look at an example of each."),(0,l.kt)("p",null,"Only load non-null fields:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'derivedField("SPREAD", DOUBLE) {\n    withEntity(INSTRUMENT_PRICE, onlyNonNullFields = true) { price ->\n        price.askPrice - price.bidPrice\n    }\n}\n')),(0,l.kt)("p",null,"Specify list of fields:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'derivedField("SPREAD", DOUBLE) {\n    withEntity(INSTRUMENT_PRICE, fields = listOf(INSTRUMENT_PRICE.ASK_PRICE, INSTRUMENT_PRICE.BID_PRICE)) { price ->\n        price.askPrice - price.bidPrice\n    }\n}\n')),(0,l.kt)("h2",{id:"joins"},"Joins"),(0,l.kt)("h3",{id:"inner-vs-outer-joins"},"INNER vs OUTER joins"),(0,l.kt)("p",null,"Available join types are INNER and OUTER. If you do not specify the type, it defaults to OUTER."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"INNER")," joins require all joins to match exactly; if one single join fails to match, the row will be discarded."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"OUTER")," joins provide null references for failed joins and will still allow the row to be built.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(INSTRUMENT, JoinType.INNER) {\n    on(TRADE { INSTRUMENT_ID } to INSTRUMENT { INSTRUMENT_ID })\n")),(0,l.kt)("h3",{id:"dictionary-joined-tables"},"Dictionary-joined tables"),(0,l.kt)("p",null,"When tables are joined in the dictionary, you are able to join to those tables in views directly, without having to specify the fields on which to join. This does not currently work with aliased tables."),(0,l.kt)("p",null,"Joining on fields:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(TRADE_TO_SIDE) {\n    on(TRADE { TRADE_ID } to TRADE_TO_SIDE { TRADE_ID })\n")),(0,l.kt)("p",null,"Joining using join:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(TRADE.JOIN_TRADE_TO_SIDE)\n")),(0,l.kt)("h3",{id:"parameterised-joins"},"Parameterised joins"),(0,l.kt)("p",null,"Some join operations require external parameters that are not available in the context of the table-join definition, but will be available when the view repository is accessed (e.g. client-enriched definitions), so an option exists to create parameterised joins."),(0,l.kt)("p",null,"These are typically used in Request Server queries:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'view("INSTRUMENT_PARAMETERS", INSTRUMENT) {\n    joins {\n        joining(ALT_INSTRUMENT_ID, JoinType.INNER) {\n            on(INSTRUMENT.ID to ALT_INSTRUMENT_ID.INSTRUMENT_ID)\n                .and(ALT_INSTRUMENT_ID.ALTERNATE_TYPE.asParameter())\n        }\n    }\n    fields {\n        ALT_INSTRUMENT_ID {\n            ALTERNATE_CODE withAlias "INSTRUMENT_CODE"\n        }\n        INSTRUMENT {\n            NAME withPrefix INSTRUMENT\n        }\n    }\n}\n')),(0,l.kt)("p",null,"So for the above, if we had a Request Server using the view, it would make ",(0,l.kt)("inlineCode",{parentName:"p"},"ALTERNATE_TYPE")," available as a field input parameter."),(0,l.kt)("h3",{id:"dynamic-joins"},"Dynamic joins"),(0,l.kt)("p",null,"These have a shared syntax with derived fields. However, rather than specifying a field name and type, it should always return an entity index type of the table you\u2019re joining on."),(0,l.kt)("admonition",{type:"warning"},(0,l.kt)("p",{parentName:"admonition"},"When using dynamic joins on aliased tables, the alias name should match the alias variable name. E.g.: ",(0,l.kt)("inlineCode",{parentName:"p"},'val fixCal = TRADE_CALENDAR withAlias "fixCal"'),", here it is ",(0,l.kt)("inlineCode",{parentName:"p"},"fixCal")," in both cases.")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Object Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Table"),(0,l.kt)("td",{parentName:"tr",align:null},"TRADE")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Entity"),(0,l.kt)("td",{parentName:"tr",align:null},"Trade")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Index"),(0,l.kt)("td",{parentName:"tr",align:null},"TRADE_BY_ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Entity Index"),(0,l.kt)("td",{parentName:"tr",align:null},"Trade.ById")))),(0,l.kt)("p",null,"As with derived fields, you can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"withEntity")," and the ",(0,l.kt)("inlineCode",{parentName:"p"},"withInput")," syntax. However, the lambda should always return an entity index object or null. Also, it should always return the same type. It is not possible to switch dynamically between indices, so it should always return the same type or null. It is possible to add further ",(0,l.kt)("inlineCode",{parentName:"p"},"and")," clauses afterwards."),(0,l.kt)("p",null,"Syntax:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining({usual join syntax}) {\n   on {  \n      // either\n      withEntity({table name}) {\n        // build index entity here\n      }\n      // or\n      withInput({field 1}, {field 2}, .., {field 9}) { a, b, .. ->\n        // build index entity here\n      }\n   }\n}\n")),(0,l.kt)("h3",{id:"examples"},"Examples"),(0,l.kt)("h4",{id:"example-1"},"Example 1"),(0,l.kt)("p",null,"Before:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(fix, backwardsJoin = true) {\n   on(TRADE_TO_SIDE { FIX_ID } to fix { SIDE_ID })\n      .and(fix { SIDE_TYPE } to SideType.FIX)\n      .joining(fixCal, JoinType.INNER, backwardsJoin = true) {\n        on(fix { CALENDAR_ID } to fixCal { CALENDAR_ID })\n      }\n")),(0,l.kt)("p",null,"After:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(fix, backwardsJoin = true) {\n   on {\n      withEntity(TRADE_TO_SIDE) { tradeToSide ->\n        TradeSide.BySideId(tradeToSide.fixId)\n      }\n   }\n   .and(fix { SIDE_TYPE } to SideType.FIX)\n   .joining(fixCal, JoinType.INNER, backwardsJoin = true)\n")),(0,l.kt)("h4",{id:"example-2"},"Example 2"),(0,l.kt)("p",null,"Before:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"joining(fixCal, JoinType.INNER, backwardsJoin = true) {\n    on(fix { CALENDAR_ID } to fixCal { CALENDAR_ID })\n}\n")),(0,l.kt)("p",null,"After:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},".joining(fixCal, JoinType.INNER, backwardsJoin = true) {\n   on {\n      withInput(fix { CALENDAR_ID }) { calendarId ->\n         when (calendarId) {\n            null -> null\n            else -> TradeCalendar.ByCalendarId(calendarId)\n         }\n      }\n   }\n}\n")))}N.isMDXComponent=!0}}]);