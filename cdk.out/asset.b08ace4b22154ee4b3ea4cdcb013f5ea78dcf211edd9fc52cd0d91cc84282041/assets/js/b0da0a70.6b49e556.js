"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[78585],{7889:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(87462),i=n(63366),r=(n(67294),n(3905)),s=(n(61839),["components"]),l={title:"Data Pipeline - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","integration","data pipeline","advanced"],tags:["server","integration","data pipeline","advanced"]},o=void 0,p={unversionedId:"server/integration/data-pipeline/advanced",id:"server/integration/data-pipeline/advanced",title:"Data Pipeline - Advanced",description:"Introduction  | Basics | Advanced | Examples | Configuring runtime | Testing",source:"@site/docs/03_server/10_integration/08_data-pipeline/03_advanced.md",sourceDirName:"03_server/10_integration/08_data-pipeline",slug:"/server/integration/data-pipeline/advanced",permalink:"/next/server/integration/data-pipeline/advanced",draft:!1,tags:[{label:"server",permalink:"/next/tags/server"},{label:"integration",permalink:"/next/tags/integration"},{label:"data pipeline",permalink:"/next/tags/data-pipeline"},{label:"advanced",permalink:"/next/tags/advanced"}],version:"current",sidebarPosition:3,frontMatter:{title:"Data Pipeline - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","integration","data pipeline","advanced"],tags:["server","integration","data pipeline","advanced"]},sidebar:"serverModulesSidebar",previous:{title:"Basics",permalink:"/next/server/integration/data-pipeline/basics"},next:{title:"Examples",permalink:"/next/server/integration/data-pipeline/examples"}},d={},u=[{value:"PostgreSQL",id:"postgresql",level:2},{value:"Interacting with the database",id:"interacting-with-the-database",level:3},{value:"System definition properties",id:"system-definition-properties",level:2},{value:"PostgreSQL configuration",id:"postgresql-configuration",level:2},{value:"Declaring multiple sources",id:"declaring-multiple-sources",level:2},{value:"Declaring multiple mappers",id:"declaring-multiple-mappers",level:2},{value:"Custom handler for the mapped entity",id:"custom-handler-for-the-mapped-entity",level:2}],m={toc:u};function c(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/introduction/"},"Introduction"),"  | ",(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/basics"},"Basics")," | ",(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/advanced"},"Advanced")," | ",(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/examples"},"Examples")," | ",(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/configuring-runtime"},"Configuring runtime")," | ",(0,r.kt)("a",{parentName:"p",href:"/server/integration/data-pipeline/testing"},"Testing")),(0,r.kt)("h2",{id:"postgresql"},"PostgreSQL"),(0,r.kt)("h3",{id:"interacting-with-the-database"},"Interacting with the database"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"transform")," function of the mappers has the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"entityDb"),", which can be used to interact with the Genesis database. It provides a CRUD interface and enables you to implement complex use cases, such as enriching data and inserting or updating missing data."),(0,r.kt)("p",null,"The example below shows mapping a value from the source data to the Genesis database. In this example, if a value is missing, it gets created on the fly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n\n  postgres("cdc-test") {\n    hostname = "localhost"\n    port = 5432\n    username = "postgres"\n    password = "docker"\n    databaseName = "postgres"\n\n    table {\n      "public.trades" to mapper("e2e-test", TRADE) {\n\n        val instrument = stringValue("inst")\n\n        TRADE {\n          INSTRUMENT_ID {\n            transform {\n              val code: String = input.get(instrument) // The instrument code from the source row\n              val instrumentType = "RIC"\n              val altInstrumentId: AltInstrumentId? =\n              entityDb.get(AltInstrumentId.byCode(code, instrumentType)) // Lookup of the instrument id from the database\n              if (altInstrumentId != null) { //if the instrument id exists return it\n                altInstrumentId.instrumentCode\n              } else { //otherwise create a new one and return it\'s id\n                val newInstrumentId = entityDb.insert(Instrument {\n                  instrumentName = ""\n                }).record.instrumentId\n\n                entityDb.insert(AltInstrumentId {\n                  alternateType = instrumentType\n                  instrumentCode = code\n                  instrumentId = newInstrumentId\n                })\n\n                newInstrumentId\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n')),(0,r.kt)("h2",{id:"system-definition-properties"},"System definition properties"),(0,r.kt)("p",null,"System definition variables can be used as part of the source configuration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n\n  postgres("cdc-test") {\n    hostname = POSTGRES_HOST\n    port = POSTGRES_PORT\n    username = DB_USERNAME\n    password = DB_PASSWORD\n    databaseName = DB_DATABASE_NAME\n  }\n}\n')),(0,r.kt)("p",null,"Alternatively, you can access ",(0,r.kt)("inlineCode",{parentName:"p"},"systemDefinition"),"s in a programmatic way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n\n  postgres("cdc-test") {\n    hostname = systemDefinition["db_host"].orElse("localhost")\n  }\n}\n')),(0,r.kt)("p",null,"It is vital to ensure that any system definition variables that are used by the configuration definition are properly defined in your ",(0,r.kt)("em",{parentName:"p"},"application"),(0,r.kt)("strong",{parentName:"p"},"-system-definition.kts")," file."),(0,r.kt)("h2",{id:"postgresql-configuration"},"PostgreSQL configuration"),(0,r.kt)("p",null,"To capture changes from PostgreSQL, the following configuration has to be in place:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Setting"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"wal_level"),(0,r.kt)("td",{parentName:"tr",align:null},"logical")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_wal_senders"),(0,r.kt)("td",{parentName:"tr",align:null},"greater than 1 (default value is 10)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"max_replication_slots"),(0,r.kt)("td",{parentName:"tr",align:null},"greater than 1 (default value is 10)")))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/runtime-config-replication.html"},"Here")," you can find more information about these settings."),(0,r.kt)("h2",{id:"declaring-multiple-sources"},"Declaring multiple sources"),(0,r.kt)("p",null,"You may declare multiple sources in the same kts file. All sources should be placed within a single ",(0,r.kt)("inlineCode",{parentName:"p"},"sources")," block."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    postgres("cdc-postgres") {\n        hostname = "localhost"\n        port = 5432\n        username = "postgres"\n        password = "docker"\n        databaseName = "postgres"\n\n        table {\n            // table to mapper definition pairs\n        }\n    }\n\n    csv("cdc-csv") {\n        location = "file://some/directory?fileName=example.xml"\n\n        // mapper definition\n    }\n}\n')),(0,r.kt)("h2",{id:"declaring-multiple-mappers"},"Declaring multiple mappers"),(0,r.kt)("p",null,"If you would like to perform different mapping operations over the same data source, you can use multiple mappers.\nYou can also optionally use a ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clause to conditionally map rows from your data source. Should the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clause be false, no mapping will be performed. These conditional mappers allow you to create more complex and powerful data ingestion pipelines."),(0,r.kt)("p",null,"For example, if you want to map over a trades source, you could map and transform your data in a different way, depending on the region the trade was made:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    csv("cdc-csv") {\n\n        location = "file://some/directory?fileName=example.xml"\n\n        mapper("EMEA-order", TABLE_OBJECT) {\n            where { input.get(stringValue("region") == "emea") }\n\n            FIELD {}\n            ...\n        }\n\n        mapper("NAM-order", TABLE_OBJECT) {\n            where { input.get(stringValue("region") == "nam") }\n\n            FIELD {}\n            ...\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"custom-handler-for-the-mapped-entity"},"Custom handler for the mapped entity"),(0,r.kt)("p",null,"The default behaviour of a data pipeline is to store the mapped ",(0,r.kt)("a",{parentName:"p",href:"/database/fields-tables-views/tables/"},"Table")," object to the Genesis database. However, there are cases when you might want to actually delete or modify that entity, or do other conditional operations. For those cases, the ",(0,r.kt)("inlineCode",{parentName:"p"},"sink")," function can be used. The function has two parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"entityDb")," - object to access the underlying Genesis database"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mappedEntity")," - the mapped Table object")),(0,r.kt)("p",null,"Recognising that inserting, modifying or deleting mapped entities will be the most commonly used operations, those are already defined under ",(0,r.kt)("inlineCode",{parentName:"p"},"SinkOperations"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SinkOperations.INSERT")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SinkOperations.MODIFY")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SinkOperations.DELETE"))),(0,r.kt)("p",null,"They can be used like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    postgres("cdc-postgres") {\n\n        ...\n\n        mapper("EMEA-order", TABLE_OBJECT) {\n            sink(SinkOperations.DELETE)\n\n            FIELD {}\n            ...\n        }\n\n    }\n}\n')),(0,r.kt)("p",null,"This can be combined with the ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," function from the previous paragraph and give you the ability to delete or modify certain records without mapping each one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    postgres("cdc-postgres") {\n\n        ...\n\n        mapper("EMEA-order", TABLE_OBJECT) {\n            sink(SinkOperations.DELETE)\n\n            where { input.get(stringValue("side") == "sell") }\n\n            FIELD {}\n            ...\n        }\n\n    }\n}\n')),(0,r.kt)("p",null,"In other cases when you want to act based on the state of the mapped entity, you can declare a custom sink method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    postgres("cdc-postgres") {\n\n        ...\n\n        mapper("EMEA-order", TABLE_OBJECT) {\n            sink {\n                if (mappedEntity.tradeType == "sell") {\n                    entityDb.delete(mappedEntity)\n                } else {\n                    entityDb.insert(mappedEntity)\n                }\n            }\n\n            FIELD {}\n            ...\n        }\n\n    }\n}\n')),(0,r.kt)("p",null,"Note that all database operations are audited if the table is declared as ",(0,r.kt)("a",{parentName:"p",href:"/database/data-types/table-entities/#auditable-tables"},"auditable"),". Each sink operation is then stored to the audit table with the default event type of ",(0,r.kt)("inlineCode",{parentName:"p"},"custom-sink-operation"),". However, you can change this by passing another type as argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"sink")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'sources {\n    postgres("cdc-postgres") {\n\n        ...\n\n        mapper("EMEA-order", TABLE_OBJECT) {\n            sink("delete-sell-trades") {\n                if (mappedEntity.tradeType == "sell") {\n                    entityDb.delete(mappedEntity)\n                } else {\n                    entityDb.insert(mappedEntity)\n                }\n            }\n\n            FIELD {}\n            ...\n        }\n\n    }\n}\n')))}c.isMDXComponent=!0}}]);