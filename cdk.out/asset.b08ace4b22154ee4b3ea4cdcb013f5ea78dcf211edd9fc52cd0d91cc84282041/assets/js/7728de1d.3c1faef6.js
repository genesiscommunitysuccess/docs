"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[29561],{69291:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return p}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),s=(n(61839),["components"]),o={title:"Access Control - Authorisation",sidebar_label:"Authorisation",id:"authorisation",keywords:["server","access control","authorisation"],tags:["server","access control","authorisation"]},l=void 0,u={unversionedId:"server/access-control/authorisation",id:"version-2022.3/server/access-control/authorisation",title:"Access Control - Authorisation",description:"Introduction  | Authentication overview | Username and Password | SSO | Authorisation overview | Authorisation",source:"@site/versioned_docs/version-2022.3/03_server/05_access-control/06_authorisation.md",sourceDirName:"03_server/05_access-control",slug:"/server/access-control/authorisation",permalink:"/server/access-control/authorisation",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"access control",permalink:"/tags/access-control"},{label:"authorisation",permalink:"/tags/authorisation"}],version:"2022.3",sidebarPosition:6,frontMatter:{title:"Access Control - Authorisation",sidebar_label:"Authorisation",id:"authorisation",keywords:["server","access control","authorisation"],tags:["server","access control","authorisation"]},sidebar:"serverModulesSidebar",previous:{title:"Authorisation Overview",permalink:"/server/access-control/authorisation-overview"},next:{title:"Introduction",permalink:"/server/state-machine/introduction"}},d={},p=[{value:"Types of control",id:"types-of-control",level:3},{value:"High-level",id:"high-level",level:4},{value:"Entity-level",id:"entity-level",level:4},{value:"Users, profiles and right codes",id:"users-profiles-and-right-codes",level:3},{value:"Sample explanation",id:"sample-explanation",level:4},{value:"Good design practice",id:"good-design-practice",level:4},{value:"Entity-level (row-level)",id:"entity-level-row-level",level:3},{value:"General approach",id:"general-approach",level:2},{value:"Generic permissions",id:"generic-permissions",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Adding authorisation to the data server and request server",id:"adding-authorisation-to-the-data-server-and-request-server",level:3},{value:"Grouping",id:"grouping",level:4},{value:"Where clauses",id:"where-clauses",level:4},{value:"hideFields",id:"hidefields",level:4},{value:"enrichedAuth",id:"enrichedauth",level:4},{value:"Dynamic permissioning",id:"dynamic-permissioning",level:2},{value:"Full example file",id:"full-example-file",level:3},{value:"Defining a permission rule",id:"defining-a-permission-rule",level:2},{value:"Data server snippet",id:"data-server-snippet",level:3},{value:"Request server snippet",id:"request-server-snippet",level:3}],c={toc:p};function h(e){var t=e.components,o=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/server/access-control/introduction"},"Introduction"),"  | ",(0,i.kt)("a",{parentName:"p",href:"/server/access-control/authentication-overview"},"Authentication overview")," | ",(0,i.kt)("a",{parentName:"p",href:"/server/access-control/password-authentication"},"Username and Password")," | ",(0,i.kt)("a",{parentName:"p",href:"/server/access-control/sso-authentication"},"SSO")," | ",(0,i.kt)("a",{parentName:"p",href:"/server/access-control/authorisation-overview"},"Authorisation overview")," | ",(0,i.kt)("a",{parentName:"p",href:"/server/access-control/authorisation"},"Authorisation")),(0,i.kt)("h3",{id:"types-of-control"},"Types of control"),(0,i.kt)("p",null,"Authorisation is achieved by permissioning dynamically. This means you can control access to information in increasingly precise ways, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An entire grid from the UI"),(0,i.kt)("li",{parentName:"ul"},"An entire data server"),(0,i.kt)("li",{parentName:"ul"},"Specific rows and columns")),(0,i.kt)("p",null,"Effectively, you have two levels of control."),(0,i.kt)("h4",{id:"high-level"},"High-level"),(0,i.kt)("p",null,"You could hide an entire grid from the UI. So one group of users could view reference data, but other groups would not see this. Or, you could hide an entire data server. To achieve this, you use ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_CODE"),". This is like a switch \u2013 you can either see it or not, depending on whether the code is ",(0,i.kt)("strong",{parentName:"p"},"TRUE")," or ",(0,i.kt)("strong",{parentName:"p"},"FALSE"),"."),(0,i.kt)("h4",{id:"entity-level"},"Entity-level"),(0,i.kt)("p",null,"This is row or column level access to information. Different users can all view the same grid, but each one sees different data. This is best explained with these simple scenarios:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can have user A, user B and user C all having the RIGHT_CODE to view a specific grid, but each one sees different trades in that grid. This enables you to separate different trading desks."),(0,i.kt)("li",{parentName:"ul"},"Each user might only have access to trades for specific clients.")),(0,i.kt)("h3",{id:"users-profiles-and-right-codes"},"Users, profiles and right codes"),(0,i.kt)("p",null,"Genesis has the concept of users, profiles and right codes. For each one, there is a table to store the related entity data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"USER"),(0,i.kt)("li",{parentName:"ul"},"PROFILE"),(0,i.kt)("li",{parentName:"ul"},"RIGHT")),(0,i.kt)("p",null,"Users gain rights via profiles. So we have tables to determine which users and rights belong to each given profile. Note that you cannot allocate right codes directly to a specific user. However, a user can have multiple profiles."),(0,i.kt)("p",null,"A profile can have zero or more rights and zero or more users."),(0,i.kt)("p",null,"These relationships are held in the following tables:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PROFILE_RIGHT"),(0,i.kt)("li",{parentName:"ul"},"PROFILE_USER")),(0,i.kt)("p",null,"Related to these tables, we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")," table, which contains the superset of rights any given user has. These are based on the profiles assigned to them. This is the key table used when checking rights, and it exists to allow the efficient checking of a user's rights."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(43340).Z,width:"931",height:"207"})),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")," table entries are automatically maintained by the system in real time. In this way, the rights are easily accessible at speed. The ",(0,i.kt)("inlineCode",{parentName:"p"},"GENESIS_AUTH_MANAGER")," process manages this table's entries automatically. So if you add a new user or you update a profile with new rights, the ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")," table is updated immediately and all the users in that profile receive the new right automatically."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"This table is only automatically maintained when profile user/right entries are maintained via ",(0,i.kt)("inlineCode",{parentName:"p"},"GENESIS_AUTH_MANAGER")," business events. If you update the data in the tables PROFILE_USER or PROFILE_RIGHT via other means (e.g. ",(0,i.kt)("strong",{parentName:"p"},"DbMon")," or ",(0,i.kt)("strong",{parentName:"p"},"SendIt"),") then the ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")," table will not be maintained automatically.\nIn such situations (e.g. setting up a brand new environemnt and bulk loading data into the tables) then the ",(0,i.kt)("inlineCode",{parentName:"p"},"~/run/auth/scripts/ConsolidateRights.sh")," script must be run. This scans all entries in ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE_USER")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE_RIGHT")," and populates ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")," withe the correct data.")),(0,i.kt)("h4",{id:"sample-explanation"},"Sample explanation"),(0,i.kt)("p",null,"See the following simple system set-up. We have a set of entities (our user, rights and profiles), a set of profile mappings (to users and rights) and, finally, the resultant set of right entries we would see in ",(0,i.kt)("inlineCode",{parentName:"p"},"RIGHT_SUMMARY")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(69860).Z,width:"1182",height:"581"})),(0,i.kt)("p",null,"The above image shows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"3 profiles, each with particular rights assigned"),(0,i.kt)("li",{parentName:"ul"},"4 users, 3 of which have one profile assigned to each and 1 of which, Jenny.Super, is assigned to have all rights.")),(0,i.kt)("p",null,"Another way of achieving this same set-up would be to have a fourth profile, say ",(0,i.kt)("strong",{parentName:"p"},"SUPER"),", as per below, and to have all rights assigned to it, and Jenny.Super assigned just to the one profile:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(50056).Z,width:"1182",height:"581"})),(0,i.kt)("p",null,"Note how we now have an extra profile, and edits to the ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE_USER")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PROFILE_RIGHT")," entries, but still see the same resulting rights."),(0,i.kt)("p",null,"As you can tell, this enables you to build powerful combinations, and since ",(0,i.kt)("strong",{parentName:"p"},"Users"),", ",(0,i.kt)("strong",{parentName:"p"},"Profiles"),", ",(0,i.kt)("strong",{parentName:"p"},"Profile_Users")," and ",(0,i.kt)("strong",{parentName:"p"},"Profile_Rights")," are all editable by system administrators, they can build their own set-up that makes sense for their organisation."),(0,i.kt)("h4",{id:"good-design-practice"},"Good design practice"),(0,i.kt)("p",null,"Having profiles as an intemediary between users and rights enables admin users of the system to create complex permission models with no code change. Rights codes generally need to be added to the code.  Although this is simple to do, it requires a code change. Our advice is to design applications with enough granularity in the rights to ensure that code changes aren't required."),(0,i.kt)("h3",{id:"entity-level-row-level"},"Entity-level (row-level)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GENESIS_AUTH_PERMS")," process runs automatically on start-up and creates a memory-mapped file that acts as a big key-value pair.\nFor example, User A has access to Counterparty 1, User B has access to Counterparty 2, User C has access to Counterparty 1, User D has access to Counterparty 4, etc. If there is no appropriate entry in the file, the user won\u2019t have access."),(0,i.kt)("p",null,"You must keep the ",(0,i.kt)("inlineCode",{parentName:"p"},"GENESIS_AUTH_PERMS")," process running, as it maintains itself automatically whenever any permissions change. When a permission is changed, then it is automatically reflected on screen. If I have a grid on screen with 4 trades from Counterparty 1 and my permission to view that counterparty is withdrawn, those 4 trades disappear from my screen immediately."),(0,i.kt)("p",null,"In many cases, you want different people to have access to different functions and different information, based on their roles. In Genesis, users are not permissioned individually for these purposes. Instead, permissioning is based on roles. You define what information and functions are available to a role, and then you allocate users to these roles. We refer to this as dynamic authorisation. There is nothing to stop you creating a role that has only one user, of course."),(0,i.kt)("h2",{id:"general-approach"},"General approach"),(0,i.kt)("p",null,"On startup, the ",(0,i.kt)("inlineCode",{parentName:"p"},"GENESIS_AUTH_PERMS")," process performs an initial scan of all entities. For each entity found, it performs authorisation against every user in the system. This builds a full map of permissioned users."),(0,i.kt)("p",null,"By default, any updates to the entity and the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER")," table will be automatically processed to permission new entities as they are entered into the database."),(0,i.kt)("p",null,"Entries are stored in a memory-mapped file located in ",(0,i.kt)("strong",{parentName:"p"},"$GENESIS_HOME/runtime/authCache"),"."),(0,i.kt)("p",null,"If you need to clear out the entries by hand, simply delete everything in that directory and restart GENESIS_AUTH_PERMS."),(0,i.kt)("p",null,"More than one permission map per table can be created."),(0,i.kt)("h2",{id:"generic-permissions"},"Generic permissions"),(0,i.kt)("p",null,"The generic permissions model available in auth automatically builds ",(0,i.kt)("strong",{parentName:"p"},"auth-perms")," maps and also ensures all the admin transactions, dataservers and request reply resources are authorised correctly on a multi-tenant basis. This generic approach might not work for every use case, but it should be good enough for many development scenarios and therefore should cover all the basics out of the box."),(0,i.kt)("h3",{id:"configuration"},"Configuration"),(0,i.kt)("p",null,"There is a field called ",(0,i.kt)("inlineCode",{parentName:"p"},"ACCESS_TYPE")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES")," table. This determines the authorisation method to be applied for a particular user."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'field(name = "ACCESS_TYPE", type = ENUM("ALL", "ENTITY", "MULTI_ENTITY", default = "ALL")) \n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Only ",(0,i.kt)("inlineCode",{parentName:"p"},"ALL")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTITY")," are in working condition at the moment.")),(0,i.kt)("p",null,"Users with ",(0,i.kt)("inlineCode",{parentName:"p"},"ACCESS_TYPE")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTITY")," (e.g. the entity could be represented by COUNTERPARTY_ID) will be permissioned only to see data relating to the value stored in the x field in the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES")," table. The name of x field is set in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ADMIN_PERMISSION_ENTITY_FIELD")," in the system definition file, as you can see in the example below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'systemDefinition {\n    global {\n        item(name = "ADMIN_PERMISSION_ENTITY_TABLE", value = "COUNTERPARTY")\n        item(name = "ADMIN_PERMISSION_ENTITY_FIELD", value = "COUNTERPARTY_ID")\n    }\n}\n')),(0,i.kt)("p",null,"These two items change the structure of ",(0,i.kt)("strong",{parentName:"p"},"auth-tables-dictionary.kts")," and ",(0,i.kt)("strong",{parentName:"p"},"auth-permissions.templt.xml")," to accomodate the defined table and field, and ensure that the table/permission data structure is built correctly."),(0,i.kt)("p",null,"Here is the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES")," table definition in ",(0,i.kt)("strong",{parentName:"p"},"auth-tables-dictionary.kts"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val permissionsField = SysDef.systemDefinition["ADMIN_PERMISSION_ENTITY_FIELD"].orElse(null)\n\ntable(name = "USER_ATTRIBUTES", id = 1007, audit = details(1052, "AA")) {\n    USER_NAME\n    USER_TYPE\n    ACCESS_TYPE\n    if (permissionsField != null) {\n        Fields[permissionsField]\n    }\n    ADDRESS_LINE1\n    ADDRESS_LINE2\n    ADDRESS_LINE3\n    ADDRESS_LINE4\n    CITY\n    REGION\n    POSTAL_CODE\n    COUNTRY\n    TITLE\n    WEBSITE\n    MOBILE_NUMBER\n    TELEPHONE_NUMBER_DIRECT\n    TELEPHONE_NUMBER_OFFICE\n    primaryKey {\n        USER_NAME\n    }\n}\n')),(0,i.kt)("p",null,"The permissions field will be added dynamically to ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES"),", so it can be used in auth transactions to control entitlements."),(0,i.kt)("p",null,"The following table will be created as well (ignore ",(0,i.kt)("inlineCode",{parentName:"p"},"MULTI_ENTITY")," setup for now; this is in development). It is used by the Genesis low-code platform to manage ",(0,i.kt)("inlineCode",{parentName:"p"},"AUTH_PERMS")," results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val permissionsTable = SysDef.systemDefinition["ADMIN_PERMISSION_ENTITY_TABLE"].orElse(null)\n\nif (permissionsTable != null && permissionsField != null) {\n\n    table(name = "USER_${permissionsTable}_MAP", id = 1012) {\n        USER_NAME\n        Fields[permissionsField]\n        primaryKey {\n            USER_NAME\n        }\n        indices {\n            nonUnique(name = "USER_${permissionsTable}_MAP_BY_${permissionsField}") {\n                Fields[permissionsField]\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",null,"There are two auth maps in ",(0,i.kt)("strong",{parentName:"p"},"auth-permissions.templt.xml")," to control how users have visibility of rows (in auth dataserver and auth request reply) and also the generic entities. See below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<entity name="USER_VISIBILITY"\n        tableName="USER"\n        maxEntries="2000"\n        idField="USER_NAME">\n    <updateOn tableName="USER_ATTRIBUTES">\n        <entities>\n            <![CDATA[\n                getUserRecord(rxDb, genericRecord.getString("USER_NAME")).toFlowable()\n            ]]>\n        </entities>\n        <users>\n            <![CDATA[\n                getUserRecord(rxDb, genericRecord.getString("USER_NAME")).toList()\n            ]]>\n        </users>\n    </updateOn>\n        <![CDATA[\n            final DbRecord targetUser = user\n            return Flowable.fromIterable(users).map { permissionedUser ->\n                final String userName = permissionedUser.getString("USER_NAME")\n                if(user.getString("ACCESS_TYPE") == "ALL"){\n                    new AuthEntry(userName, entityId, true)\n                } else {\n                    new AuthEntry(userName, entityId, targetUser.getString("{{ADMIN_PERMISSION_ENTITY_FIELD}}") == permissionedUser.getString("{{ADMIN_PERMISSION_ENTITY_FIELD}}"))\n                }\n            }\n        ]]>\n</entity>\n\n<entity name="ENTITY_VISIBILITY"\n        tableName="USER_{{ADMIN_PERMISSION_ENTITY_TABLE}}_MAP"\n        maxEntries="20000"\n        idField="{{ADMIN_PERMISSION_ENTITY_FIELD}}" >\n        <![CDATA[\n            final Set<String> validUsers = getUsernamesForEntity(rxDb, entityId, null)\n            return Flowable.fromIterable(users).map { user ->\n                final String userName = user.getString("USER_NAME")\n                if(user.getString("ACCESS_TYPE") == "ALL"){\n                    new AuthEntry(userName, entityId, true)\n                } else {\n                    new AuthEntry(userName, entityId, userName in validUsers)\n                }\n            }\n        ]]>\n</entity>\n')),(0,i.kt)("p",null,"Here is an example of using ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTITY_VISIBILITY")," in a data server or request server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'query("ALL_BID_OFFER_SELLER_DEALER", BID_OFFER_SELLER_VIEW) {\n    permissioning {\n        auth(mapName = "ENTITY_VISIBILITY") {\n            BID_OFFER_SELLER_VIEW.SELLER_DEALER_ID\n        }\n        config {\n            backwardsJoins = true\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"adding-authorisation-to-the-data-server-and-request-server"},"Adding authorisation to the data server and request server"),(0,i.kt)("p",null,"The code for permissioning specific queries must be inserted into your data servers and request servers."),(0,i.kt)("p",null,"The dynamic authorisation definition in a GPAL data server or request server has 4 settings, which can be used in any combination:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"grouping (and/or)"),(0,i.kt)("li",{parentName:"ul"},"where clauses"),(0,i.kt)("li",{parentName:"ul"},"hideFields"),(0,i.kt)("li",{parentName:"ul"},"enrichedAuth")),(0,i.kt)("h4",{id:"grouping"},"Grouping"),(0,i.kt)("p",null,"Auth definitions can be grouped with \u201cand\u201d or \u201cor\u201d operators."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You could have two simple permission maps, for example: one by counterparty and another one for forbidden symbols. If the user wants to see a specific row, they need to have both permissions at once."),(0,i.kt)("li",{parentName:"ul"},"You could have two permission maps: one for buyer and one for seller. A user would be allowed to see a row if they have a seller or buyer profile, but users without one of the those profiles would be denied access.")),(0,i.kt)("p",null,"This example shows an AND grouping:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'permissioning {\n    auth(mapName = "ENTITY_VISIBILITY") {\n        TRADE.COUNTERPARTY_ID\n    } and auth(mapName = "SYMBOL_RESTRICTED") {\n        TRADE.SYMBOL\n    }\n}\n')),(0,i.kt)("p",null,"This example shows OR grouping:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'permissioning {\n    auth(mapName = "ENTITY_VISIBILITY") {\n        BID_OFFER.BUYER_ID\n    } or auth(mapName = "ENTITY_VISIBILITY") {\n        BID_OFFER.SELLER_ID\n    }\n}\n')),(0,i.kt)("h4",{id:"where-clauses"},"Where clauses"),(0,i.kt)("p",null,"You can define a where clause if you only want to show a row in specific cases. These authorisation definitions first evaluate the where clause against the permission map. This functionality on its own is not that useful, because for a single auth permissions map, the content of the where clause could be moved to the query where clause instead. However, it shines when using auth grouping, because you can filter rows based on individual user permissions."),(0,i.kt)("p",null,"The example below shows permissioning where authorisation is successful if the user satisifies one of two code blocks:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first block has a where clause that prevents the user (a permissioned buying countparty) from viewing cancelled trades."),(0,i.kt)("li",{parentName:"ul"},"The second block makes the information visible to any permissioned selling counterparty - so they can view cancelled trades.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'permissioning {\n    auth(mapName = "ENTITY_VISIBILITY") {\n        TRADE.BUYING_COUNTERPARTY\n        where { trade ->\n            TradeState.CANCELLED != trade.tradeState\n        }\n        //Only visible to users with entity access to SELLING_COUNTERPARTY ID on the trade WHERE trade state is not CANCELLED (so buyer can\'t see cancelled trades effectively)\n    } or\n    auth(mapName = "ENTITY_VISIBILITY") {\n        TRADE.SELLING_COUNTERPARTY\n        //No where clause, so always visible to users with entity access to SELLING_COUNTERPARTY ID on the trade\n    }\n}\n')),(0,i.kt)("h4",{id:"hidefields"},"hideFields"),(0,i.kt)("p",null,"You can also have different column visibility levels based on user authorisation and row content."),(0,i.kt)("p",null,"The example below hides the LAST_TRADED_PRICE column value for a particular instrument code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'permissioning {\n    auth(mapName = "EXCHANGE") {\n        INSTRUMENT_DETAILS.EXCHANGE_ID\n        hideField { userName, rowData ->\n            if(rowData.instrumentCode == "ALLL3") LAST_TRADED_PRICE\n            else null\n        }\n    }\n}\n')),(0,i.kt)("h4",{id:"enrichedauth"},"enrichedAuth"),(0,i.kt)("p",null,"Our permission model could require access to client-enriched data, so data servers have an additional level of auth functionality which takes this data into account."),(0,i.kt)("p",null,"Here is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'query("ALL_TRADES_WITH_ENRICHED_AUTH", TRADE_VIEW) {\n    permissioning {\n        enrichedAuth(mapName = "TRADE_VISIBILITY", enrichedEntity = FAVOURITE_TRADES) {\n            TRADE_VIEW.TRADE_ID\n            FAVOURITE_TRADES.USER_NAME\n        }\n    }\n    enrich(FAVOURITE_TRADES){\n        join { userName, row ->\n            FavouriteTrades.ByTradeIdAndUserName(\n                userName = userName,\n                tradeId = row.tradeId\n            )\n        }\n        fields {\n            derivedField("FAVOURITE", BOOLEAN) { row, userData ->\n                userData != null\n            }\n        }\n    }\n    config {\n        compression = true\n    }\n}\n')),(0,i.kt)("h2",{id:"dynamic-permissioning"},"Dynamic permissioning"),(0,i.kt)("p",null,"Here\u2019s the scenario; we want to permission by checking the ",(0,i.kt)("inlineCode",{parentName:"p"},"ACCOUNT")," table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'table(name = "ACCOUNT", id = 1000) {\n    ID\n    DISTRIBUTOR_ID\n    OFFICER_ID\n    ASSET_MANAGER_ID\n    INVESTOR_ID\n    NAME\n    primaryKey(name = "ACCOUNT_BY_ID", id = 1) {\n        ID\n    }\n}\n')),(0,i.kt)("p",null,"We want to allow a user to view an account if one of the following is true:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The user is a sales officer, and is the sales officer for the given account"),(0,i.kt)("li",{parentName:"ul"},"The user is an asset manager, and is the asset manager for the given account.")),(0,i.kt)("p",null,"The first thing we want to do is find out what type of user we're currently dealing with. We do this by checking the ",(0,i.kt)("inlineCode",{parentName:"p"},"TAG")," table, and getting the ",(0,i.kt)("inlineCode",{parentName:"p"},"PERSON_TYPE")," record for the given user. We can wrap this logic into a simple function and place it into the preExpression block:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-groovy"},"<preExpression>\n        <![CDATA[\n\n            import java.util.Collections\n            import io.reactivex.rxjava3.core.SingleEmitter\n            import io.reactivex.rxjava3.core.Flowable\n            import io.reactivex.rxjava3.core.Single\n            import io.reactivex.rxjava3.core.Maybe\n            import static global.genesis.auth.perms.processor.PermsProcessorUtils.*\n            \n            static Flowable<DbRecord> getUserRecord(RxDb rxDb, String userName){\n                final DbRecord userRecord = new DbRecord(\"USER\")\n                userRecord.setString(\"USER_NAME\", userName)\n                return Flowable.fromIterable(rxDb.get(userRecord, \"USER_BY_NAME\"))\n            }\n            \n            /*\n             * Get user type based on tag value\n             */\n            static Flowable<Boolean> getUserType(String userName) {\n                def tagRec = new DbRecord('TAG')\n                tagRec.setString('CODE', 'PERSON_TYPE')\n                tagRec.setString('ENTITY_ID', userName)\n                return Flowable.fromIterable(rxDb.get(tagRec, 'TAG_BY_CODE'))\n            }\n        ]]>\n</preExpression>\n")),(0,i.kt)("p",null,"Here, we're simply creating a TAG record and attempting to find the ",(0,i.kt)("inlineCode",{parentName:"p"},"PERSON_TYPE")," record. Once this call has returned, we can perform our logic, which looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-groovy"},"<entity name=\"ACCOUNT\" maxEntries=\"10000\" idField=\"ID\">\n        <updateOn table=\"TAG\">\n        \x3c!-- Entities is expected to return a Flowable<DbRecord> or 'null' to force a full refresh of entity table --\x3e\n        <entities>\n            <![CDATA[\n                // If the TAG record does not contain a PERSON_TYPE change, then we don't need to process it\n                if(genericRecord.getString('CODE') != 'PERSON_TYPE'){\n                    return Flowable.empty()\n                } else {\n                    // If the TAG record contained a PERSON_TYPE change, we need to re-evaluate all ACCOUNT records against this user,\n                    // therefore return \"null\" to force a full table refresh.\n                return null\n            }\n            ]]>\n        </entities>\n        \x3c!-- Users block is expected to return an FLowable<List<DbRecord>> or 'null' to force a full refresh of user table --\x3e\n        <users>\n            <![CDATA[\n                def userObs = getUserRecord(db, genericRecord.getString('ENTITY_ID'))\n                return userObs.filter{it != null}.toList()\n            ]]>\n        </users>\n        </updateOn>\n\n    <![CDATA[\n        // \"users\" is a Groovy expression binding which contains all the users that need to be updated against an entity\n        def entityCode = account.getString('ID')\n        return Flowable.fromIterable(users).flatMap{ user ->\n            def userName = user.getString('USER_NAME')\n    \n            return getUserType(userName).flatMap{ tagRec ->\n                def allowed = false\n                def entityType = tagRec?.getString('TAG_VALUE')\n        \n                if(entityType == 'SALES_OFFICER') {\n                    if(account.getString('OFFICER_ID') == userName) {\n                        allowed = true\n                    }\n                }\n        \n                if(entityType == 'ASSET_MANAGER') {\n                    if(account.getString('ASSET_MANAGER_ID') == userName) {\n                        allowed = true\n                    }\n                }\n                return Flowable.just(new AuthEntry(userName, entityCode, allowed))\n            }\n        }\n    ]]>\n</entity>\n")),(0,i.kt)("p",null,"As you can see, we first get the ",(0,i.kt)("strong",{parentName:"p"},"entityType")," (note the inline null check to handle the fact the tag record may not exist). We can then check if the current user is stored against the account as either the sales officer, or the asset manager."),(0,i.kt)("p",null,"We always emit an ",(0,i.kt)("strong",{parentName:"p"},"AuthEntry")," object within our returned Flowable, which specifies whether the user is permissioned or not."),(0,i.kt)("p",null,"Also note the fact we're using Flowable. We wrap the users list to be a Flowable, then we ",(0,i.kt)("strong",{parentName:"p"},"flatMap")," the ",(0,i.kt)("strong",{parentName:"p"},"getUserType")," call and return a Flowable in the form of an ",(0,i.kt)("strong",{parentName:"p"},"AuthEntry"),"."),(0,i.kt)("p",null,"We also define several items on the entity element:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"name")," - The entity (and table name) we're dealing with"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"maxEntries")," - Max number of entries to read on initial scan"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"idField")," - The account ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"updateOn")," xml block - We want to re-evaluate the auth entries (entities and users) when the TAG table is updated, just in case we make a user sales officer/asset manager.")),(0,i.kt)("p",null,"As mentioned above, we will also refresh when either the ",(0,i.kt)("inlineCode",{parentName:"p"},"ENTITY"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"USER")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES")," tables are updated. You will need to define ",(0,i.kt)("inlineCode",{parentName:"p"},"updateOnUserFields")," (see further down) to ensure user data updates are triggered."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," handle readily available will contain all fields and their values from the ",(0,i.kt)("inlineCode",{parentName:"p"},"USER")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES")," tables, meaning if you add a custom string field ",(0,i.kt)("inlineCode",{parentName:"p"},"FOO")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"USER_ATTRIBUTES"),", ",(0,i.kt)("inlineCode",{parentName:"p"},'user.getString("FOO")')," can be used to access it.)")),(0,i.kt)("h3",{id:"full-example-file"},"Full example file"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-groovy"},"<dynamicPermissions>\n\n    <preExpression>\n        <![CDATA[\n\n            import java.util.Collections\n            import io.reactivex.rxjava3.core.SingleEmitter\n            import io.reactivex.rxjava3.core.Flowable\n            import io.reactivex.rxjava3.core.Single\n            import io.reactivex.rxjava3.core.Maybe\n            import static global.genesis.auth.perms.processor.PermsProcessorUtils.*\n\n            static Flowable<DbRecord> getUserRecord(RxDb rxDb, String userName){\n                final DbRecord userRecord = new DbRecord(\"USER\")\n                userRecord.setString(\"USER_NAME\", userName)\n                return Flowable.fromIterable(rxDb.get(userRecord, \"USER_BY_NAME\"))\n            }\n            \n            /*\n             * Get user type based on tag value\n             */\n            static Flowable<Boolean> getUserType(String userName) {\n                def tagRec = new DbRecord('TAG')\n                tagRec.setString('CODE', 'PERSON_TYPE')\n                tagRec.setString('ENTITY_ID', userName)\n                return Flowable.fromIterable(rxDb.get(tagRec, 'TAG_BY_CODE'))\n            }\n\n        ]]>\n    </preExpression>\n\n    \x3c!-- USER updates are assumed --\x3e\n    <entity name=\"ACCOUNT\" maxEntries=\"10000\" idField=\"ID\">\n        <updateOn table=\"TAG\">\n            \x3c!-- Entities is expected to return an Flowable<DbRecord> or 'null' to force a full refresh of entity table --\x3e\n            <entities>\n            <![CDATA[\n                // If the TAG record does not contain a PERSON_TYPE change, then we don't need to process it\n                if(genericRecord.getString('CODE') != 'PERSON_TYPE'){\n                    return Flowable.empty()\n                } else {\n                    // If the TAG record contained a PERSON_TYPE change, we need to re-evaluate all ACCOUNT records against this user,\n                    // therefore return \"null\" to force a full table refresh.\n                    return null\n                }\n            ]]>\n            </entities>\n            \x3c!-- Users block is expected to return an Flowable<List<DbRecord>> or 'null' to force a full refresh of user table --\x3e\n            <users>\n            <![CDATA[\n                def userObs = getUserRecord(db, genericRecord.getString('ENTITY_ID'))\n                return userObs.filter{it != null}.toList()\n            ]]>\n            </users>\n        </updateOn>\n\n        <![CDATA[\n            // \"users\" is a Groovy expression binding which contains all the users that need to be updated against an entity\n            def entityCode = account.getString('ID')\n            return Flowable.fromIterable(users).flatMap{ user ->\n                def userName = user.getString('USER_NAME')\n                \n                return getUserType(userName).flatMap{ tagRec ->\n                    def allowed = false\n                    def entityType = tagRec?.getString('TAG_VALUE')\n    \n                    if(entityType == 'SALES_OFFICER') {\n                        if(account.getString('OFFICER_ID') == userName) {\n                            allowed = true\n                        }\n                    }\n    \n                    if(entityType == 'ASSET_MANAGER') {\n                        if(account.getString('ASSET_MANAGER_ID') == userName) {\n                            allowed = true\n                        }\n                    }\n                    return Flowable.just(new AuthEntry(userName, entityCode, allowed))\n                }\n            }\n        ]]>\n    </entity>\n\n</dynamicPermissions>\n")),(0,i.kt)("h2",{id:"defining-a-permission-rule"},"Defining a permission rule"),(0,i.kt)("p",null,"All permission rules are held in the file ",(0,i.kt)("strong",{parentName:"p"},"auth-permissions.xml"),".  In this file, you define rules against a specific entity, and each entity is defined against a database table."),(0,i.kt)("p",null,"We have a preExpression block inside our file, which is applied to all entities. This makes the definition ",(0,i.kt)("inlineCode",{parentName:"p"},"isUserEnabled")," available to all entities."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<preExpression>\n    <![CDATA[\n\n        /*\n         * Check user status\n         */\n         def static isUserEnabled(user) {\n            return user.getString('STATUS') == 'ENABLED'\n         }\n    ]]>\n</preExpression>\n")),(0,i.kt)("p",null,"We can now call ",(0,i.kt)("inlineCode",{parentName:"p"},"isUserEnabled")," from any entity block."),(0,i.kt)("p",null,"You must define an entity block for every entity you want to authorise.  Each block can have the following attributes:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"),(0,i.kt)("th",{parentName:"tr",align:null},"Mandatory"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null},"The name of the entity you want to authorise."),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"maxEntries"),(0,i.kt)("td",{parentName:"tr",align:null},"The maximum number of entries that the authorisation map will contain."),(0,i.kt)("td",{parentName:"tr",align:null},"No. Default  =5,000.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"tableName"),(0,i.kt)("td",{parentName:"tr",align:null},"The root table to you are giving access to."),(0,i.kt)("td",{parentName:"tr",align:null},"No. Default = the same value as name.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"idField"),(0,i.kt)("td",{parentName:"tr",align:null},"Field(s) to use for keying internal collection (should be unique). Multiple fields must be separated with the ","|"," symbol."),(0,i.kt)("td",{parentName:"tr",align:null},"Yes")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"updateOnUserFields"),(0,i.kt)("td",{parentName:"tr",align:null},"Specify the list of USER and USER_ATTRIBUTE fields to which an update to the field should trigger a re-check of this entities permissions"),(0,i.kt)("td",{parentName:"tr",align:null},"No. Left undefined permissions checks will only be re-triggered on updates to USER.STATUS field, and no others. As such STATUS does not need to be included in this field list, it is assumed.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"averageUserNameChars"),(0,i.kt)("td",{parentName:"tr",align:null},"Average number of characters in each username. This setting helps to fine-tune the backing data structure for the authorisation map."),(0,i.kt)("td",{parentName:"tr",align:null},"No. Default = 20")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"averageEntityChars"),(0,i.kt)("td",{parentName:"tr",align:null},"Average number of characters of each entity. This setting helps to fine-tune the backing data structure for the authorisation map."),(0,i.kt)("td",{parentName:"tr",align:null},"No. Default = 7")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"averageUsers"),(0,i.kt)("td",{parentName:"tr",align:null},"Average number of users on the system. This setting helps to fine-tune the backing data structure for the authorisation map."),(0,i.kt)("td",{parentName:"tr",align:null},"No. Default = 1,000")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"updateOn"),(0,i.kt)("td",{parentName:"tr",align:null},"Custom logic to trigger authorisation updates in specific scenarios. When tables defined in this section are modified, the authorisation map is refreshed following the configuration logic. See the example."),(0,i.kt)("td",{parentName:"tr",align:null},"No")))),(0,i.kt)("h3",{id:"data-server-snippet"},"Data server snippet"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'dataServer {\n\n  query(FUND) {\n    permissioning {\n      auth(mapName = "ENTITY_VISIBILITY") {\n        FUND.FUND_ID\n      }\n    }\n  }\n}\n')),(0,i.kt)("h3",{id:"request-server-snippet"},"Request server snippet"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n\n  requestReply(FUND) {\n    permissioning {\n      auth(mapName = "ENTITY_VISIBILITY") {\n        FUND.FUND_ID\n      }\n    }\n  }\n}\n')))}h.isMDXComponent=!0},69860:function(e,t,n){t.Z=n.p+"assets/images/user-profile-rights-example-simple-77f9456bd5039c7114589f0232e7d34c.png"},50056:function(e,t,n){t.Z=n.p+"assets/images/user-profile-rights-example-super-d84f9faccc5056d9b56f45aa303d2a11.png"},43340:function(e,t,n){t.Z=n.p+"assets/images/user-profile-rights-setup-3dacd0ceee33f5777ecffe47e3a4b162.png"}}]);