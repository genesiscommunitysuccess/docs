"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[53514],{73269:function(e,a,t){t.r(a),t.d(a,{assets:function(){return d},contentTitle:function(){return r},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var s=t(87462),n=t(63366),l=(t(67294),t(3905)),i=(t(61839),["components"]),o={title:"Inter-process messages - type-safe messages",sidebar_label:"Type-safe messages",id:"type-safe-messages",keywords:["server","inter-process messages","type-safe messages"],tags:["server","inter-process messages","type-safe messages"]},r=void 0,p={unversionedId:"server/inter-process-messages/type-safe-messages",id:"version-2022.3/server/inter-process-messages/type-safe-messages",title:"Inter-process messages - type-safe messages",description:"The Genesis low-code platform uses type-safe messages to perform message serialisation and deserialisation. In addition to this, it automatically extracts relevant metadata to expose this to the front end. These type-safe messages are most commonly used in Request Servers, GPAL Event Handlers and Event Handlers that have been implemented as a set of classes.",source:"@site/versioned_docs/version-2022.3/03_server/09_inter-process-messages/03_type-safe-messages.md",sourceDirName:"03_server/09_inter-process-messages",slug:"/server/inter-process-messages/type-safe-messages",permalink:"/server/inter-process-messages/type-safe-messages",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"inter-process messages",permalink:"/tags/inter-process-messages"},{label:"type-safe messages",permalink:"/tags/type-safe-messages"}],version:"2022.3",sidebarPosition:3,frontMatter:{title:"Inter-process messages - type-safe messages",sidebar_label:"Type-safe messages",id:"type-safe-messages",keywords:["server","inter-process messages","type-safe messages"],tags:["server","inter-process messages","type-safe messages"]},sidebar:"serverModulesSidebar",previous:{title:"GenesisSet",permalink:"/server/inter-process-messages/genesisSet"},next:{title:"Metadata annotations",permalink:"/server/inter-process-messages/metadata-annotations"}},d={},m=[{value:"Input messages",id:"input-messages",level:2},{value:"Read-only values",id:"read-only-values",level:2},{value:"Deserialised fields",id:"deserialised-fields",level:2},{value:"Output messages",id:"output-messages",level:2},{value:"Event Handler examples",id:"event-handler-examples",level:3}],u={toc:m};function c(e){var a=e.components,t=(0,n.Z)(e,i);return(0,l.kt)("wrapper",(0,s.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"The Genesis low-code platform uses type-safe messages to perform message serialisation and deserialisation. In addition to this, it automatically extracts relevant metadata to expose this to the front end. These type-safe messages are most commonly used in Request Servers, GPAL Event Handlers and Event Handlers that have been ",(0,l.kt)("a",{parentName:"p",href:"/database/api-reference/event-handler-api/"},"implemented as a set of classes"),"."),(0,l.kt)("h2",{id:"input-messages"},"Input messages"),(0,l.kt)("p",null,"The input message type ",(0,l.kt)("inlineCode",{parentName:"p"},"I")," is defined as a Kotlin data class, which specifies all the necessary information to parse the incoming message and to expose it as metadata. Take a look at this example, which we shall discuss below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'enum class LogLevel {\n    TRACE, DEBUG, INFO, WARN, ERROR\n}\n\ndata class SetLogLevel(\n    @Title("Process name")\n    val processName: String,\n    @Description("Represents the target logging level")\n    val logLevel: LogLevel? = null,\n    val datadump: Boolean = false,\n    val expiration: Int = 0\n)\n')),(0,l.kt)("p",null,"In this example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"SetLogLevel")," data class has a single constructor that also defines the data class properties. Also note:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"Mandatory metadata field"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"processName")," does not have a default value associated with it; therefore, a value is mandatory to construct this message. So, it will be exposed as a ",(0,l.kt)("em",{parentName:"p"},"mandatory")," metadata field. ")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"optional metadata fields"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"logLevel"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"datadump")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"expiration")," all have default values; they will therefore be exposed as optional metadata fields."),(0,l.kt)("p",{parentName:"li"},"You are free to use all the following types as long as they are composed using the same elements: ")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Genesis metadata field basic types (Boolean, Short, Int, Long, Double, String, BigDecimal or Joda DateTime)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"enumerated types (as you can see defined in ",(0,l.kt)("inlineCode",{parentName:"p"},"LogLevel")," above)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"basic collection types (List, Set and Map)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"other Kotlin data classes "))),(0,l.kt)("p",null,"All these different types will be understood by the metadata system and exposed accordingly. Kotlin also has nullable and non-nullable types, and the metadata system will expose this information too."),(0,l.kt)("p",null,"Annotations such as ",(0,l.kt)("inlineCode",{parentName:"p"},"@Title")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"@Description")," can be used to provide extra information to the front end."),(0,l.kt)("p",null,"For example:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"@Title")," could be used to provide a human-readable name for a metadata field to be displayed in a grid column."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"@Description")," could be used to provide tooltip information when hovering over that column header. ")),(0,l.kt)("p",null,"You can find more information on our page about ",(0,l.kt)("a",{parentName:"p",href:"/server/inter-process-messages/metadata-annotations/"},"metadata annotations"),"."),(0,l.kt)("h2",{id:"read-only-values"},"Read-only values"),(0,l.kt)("p",null,"Read-only values can be exposed inside a Kotlin companion object and can be as complex as any other metadata field definition. In the example below, the enhanced ",(0,l.kt)("inlineCode",{parentName:"p"},"SetLogLevel")," class provides information about the default LogLevel:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class SetLogLevel(\n    @Title("Process name")\n    val processName: String,\n    @Description("Represents the target logging level")\n    val logLevel: LogLevel? = null,\n    val datadump: Boolean = false,\n    val expiration: Int = 0\n) {\n    companion object ReadOnly {\n        val defaultLogLevel: LogLevel = LogLevel.INFO\n    }\n}\n')),(0,l.kt)("h2",{id:"deserialised-fields"},"Deserialised fields"),(0,l.kt)("p",null,"There is a significant disadvantage in using type-safe messages with support for default values; once the message has been deserialised, you don't know what the original payload contained."),(0,l.kt)("p",null,"Following the previous example with the ",(0,l.kt)("inlineCode",{parentName:"p"},"SetLogLevel")," data class, it is possible to receive a message with just a ",(0,l.kt)("inlineCode",{parentName:"p"},"processName")," value; you will still have default values for all the other fields due to the automatic defaulting mechanism. This might present a problem where you have business logic where those fields were part of the original payload. For example, if you receive a value for the field ",(0,l.kt)("inlineCode",{parentName:"p"},"expiration")," set as 0, you might want to define different business logic than if the value was never sent in the first place - even though 0 is the same value as the default value."),(0,l.kt)("p",null,"In order to solve this problem, there is a class called ",(0,l.kt)("inlineCode",{parentName:"p"},"DeserializedFieldsSupport"),". This class can be extended by any type-safe data class. It is available for both Event Handler definitions and Request Server definitions. The previous ",(0,l.kt)("inlineCode",{parentName:"p"},"SetLogLevel")," data class would now look like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class SetLogLevel(\n    @Title("Process name")\n    val processName: String,\n    @Description("Represents the target logging level")\n    val logLevel: LogLevel? = null,\n    val datadump: Boolean = false,\n    val expiration: Int = 0\n) : DeserializedFieldsSupport() {\n    companion object ReadOnly {\n        val defaultLogLevel: LogLevel = LogLevel.INFO\n    }\n}\n')),(0,l.kt)("p",null,"Any message extending this class will have access to a property called ",(0,l.kt)("inlineCode",{parentName:"p"},"deserializedFields")," of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Map<String, DeserializedField>"),", which will provide enough information to reconstruct the values that were part of the original payload."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"DeserializedField")," sealed class definition looks like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed class DeserializedField {\n    object Simple : DeserializedField()\n    data class Array(val fields: List<DeserializedField>) : DeserializedField()\n    data class Object(val fields: Map<String, DeserializedField>) : DeserializedField()\n}\n")),(0,l.kt)("p",null,"So, if we revisit a real-life example for ",(0,l.kt)("inlineCode",{parentName:"p"},"SetLogLevel")," in which we only receive field values for ",(0,l.kt)("inlineCode",{parentName:"p"},"processName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"datadump"),", the content of ",(0,l.kt)("inlineCode",{parentName:"p"},"deserializedFields")," will be a ",(0,l.kt)("inlineCode",{parentName:"p"},"Map")," with the following key-values:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'{\n  "PROCESS_NAME" : DeserializedField.Simple\n  "DATADUMP" : DeserializedField.Simple\n}\n')),(0,l.kt)("p",null,"If your message has nested arrays or objects, the ",(0,l.kt)("inlineCode",{parentName:"p"},"deserializedFields")," property will also contain nested structures in the shape of ",(0,l.kt)("inlineCode",{parentName:"p"},"DeserializedField.Array")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"DeserializedField.Object")," types."),(0,l.kt)("h2",{id:"output-messages"},"Output messages"),(0,l.kt)("p",null,"The output message type ",(0,l.kt)("inlineCode",{parentName:"p"},"O")," can be defined as a single Kotlin data class or sealed class with multiple Kotlin data classes defined as subtypes. For multiple subtypes, the Genesis low-code platform is able to extract information for all the possible messages and expose it as metadata."),(0,l.kt)("p",null,"As an example, we shall look at ",(0,l.kt)("inlineCode",{parentName:"p"},"EventReply")," and how Event Handlers work with output types in real life."),(0,l.kt)("h3",{id:"event-handler-examples"},"Event Handler examples"),(0,l.kt)("p",null,"The default output message type to use in Event Handlers is ",(0,l.kt)("inlineCode",{parentName:"p"},"EventReply"),". This is a Kotlin sealed class, which is most commonly represented by two subtypes: ",(0,l.kt)("inlineCode",{parentName:"p"},"EventAck")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"EventNack"),". See their Kotlin definitions below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class EventAck(val generated: List<Map<String, Any>> = emptyList()) : EventReply()\ndata class EventNack(\n    val warning: List<GenesisError> = emptyList(),\n    val error: List<GenesisError> = emptyList()\n) : EventReply()\n")),(0,l.kt)("p",null,"Alternatively, you can create your own reply type using a normal Kotlin data class or sealed class. The example below defines ",(0,l.kt)("inlineCode",{parentName:"p"},"EventSetLogLevelReply"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed class EventSetLogLevelReply : Outbound() {\n    class EventSetLogLevelAck : EventSetLogLevelReply()\n    data class EventSetLogLevelNack(val error: String) : EventSetLogLevelReply()\n}\n")),(0,l.kt)("p",null,"These custom reply types allow a predetermined number of customised replies for a single ",(0,l.kt)("inlineCode",{parentName:"p"},"eventHandler")," codeblock, with their type information exposed in the metadata system. However, they need to be handled carefully, as the internal error-handling mechanism for the Event Handler is only able to handle ",(0,l.kt)("inlineCode",{parentName:"p"},"EventReply")," messages. Therefore, non-captured exceptions and errors will break the type-safety guarantees of the reply. "),(0,l.kt)("admonition",{type:"warning"},(0,l.kt)("p",{parentName:"admonition"},"IMPORTANT! The success message should always end in ",(0,l.kt)("inlineCode",{parentName:"p"},"Ack")," in order for the internal ",(0,l.kt)("inlineCode",{parentName:"p"},"eventandler")," logic to handle validation correctly.")))}c.isMDXComponent=!0}}]);