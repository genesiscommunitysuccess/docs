"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[79632],{85162:function(e,t,a){a.d(t,{Z:function(){return r}});var n=a(67294),l=a(86010),i="tabItem_Ymn6";function r(e){var t=e.children,a=e.hidden,r=e.className;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(i,r),hidden:a},t)}},65488:function(e,t,a){a.d(t,{Z:function(){return m}});var n=a(87462),l=a(67294),i=a(86010),r=a(72389),d=a(67392),o=a(7094),s=a(12466),u="tabList__CuJ",p="tabItem_LNqP";function k(e){var t,a,r=e.lazy,k=e.block,m=e.defaultValue,b=e.values,c=e.groupId,y=e.className,N=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=b?b:N.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),g=(0,d.l)(h,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var f=null===m?m:null!=(t=null!=m?m:null==(a=N.find((function(e){return e.props.default})))?void 0:a.props.value)?t:N[0].props.value;if(null!==f&&!h.some((function(e){return e.value===f})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+f+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,o.U)(),E=v.tabGroupChoices,w=v.setTabGroupChoices,T=(0,l.useState)(f),C=T[0],x=T[1],I=[],R=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=c){var A=E[c];null!=A&&A!==C&&h.some((function(e){return e.value===A}))&&x(A)}var F=function(e){var t=e.currentTarget,a=I.indexOf(t),n=h[a].value;n!==C&&(R(t),x(n),null!=c&&w(c,String(n)))},D=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n,l=I.indexOf(e.currentTarget)+1;a=null!=(n=I[l])?n:I[0];break;case"ArrowLeft":var i,r=I.indexOf(e.currentTarget)-1;a=null!=(i=I[r])?i:I[I.length-1]}null==(t=a)||t.focus()};return l.createElement("div",{className:(0,i.Z)("tabs-container",u)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":k},y)},h.map((function(e){var t=e.value,a=e.label,r=e.attributes;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return I.push(e)},onKeyDown:D,onFocus:F,onClick:F},r,{className:(0,i.Z)("tabs__item",p,null==r?void 0:r.className,{"tabs__item--active":C===t})}),null!=a?a:t)}))),r?(0,l.cloneElement)(N.filter((function(e){return e.props.value===C}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},N.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function m(e){var t=(0,r.Z)();return l.createElement(k,(0,n.Z)({key:String(t)},e))}},18904:function(e,t,a){a.r(t),a.d(t,{assets:function(){return k},contentTitle:function(){return u},default:function(){return c},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return m}});var n=a(87462),l=a(63366),i=(a(67294),a(3905)),r=(a(61839),a(65488)),d=a(85162),o=["components"],s={title:"Database interface - Entity Db",sidebar_label:"Entity Db",id:"entity-db",keywords:["database","database interface","entity db"],tags:["database","database interface","entity db"]},u=void 0,p={unversionedId:"database/database-interface/entity-db",id:"database/database-interface/entity-db",title:"Database interface - Entity Db",description:"Introduction  | EntityDb |  Generated repositories | RxDb",source:"@site/docs/02_database/05_database-interface/01_entitydb.md",sourceDirName:"02_database/05_database-interface",slug:"/database/database-interface/entity-db",permalink:"/next/database/database-interface/entity-db",draft:!1,tags:[{label:"database",permalink:"/next/tags/database"},{label:"database interface",permalink:"/next/tags/database-interface"},{label:"entity db",permalink:"/next/tags/entity-db"}],version:"current",sidebarPosition:1,frontMatter:{title:"Database interface - Entity Db",sidebar_label:"Entity Db",id:"entity-db",keywords:["database","database interface","entity db"],tags:["database","database interface","entity db"]},sidebar:"databaseSidebar",previous:{title:"Database interface",permalink:"/next/database/database-interface/database-interface"},next:{title:"Generated repositories",permalink:"/next/database/database-interface/generated-repositories"}},k={},m=[{value:"Type convention",id:"type-convention",level:2},{value:"Read Operations",id:"read-operations",level:2},{value:"get",id:"get",level:3},{value:"Syntax",id:"syntax",level:4},{value:"getAll",id:"getall",level:3},{value:"Overloads",id:"overloads",level:4},{value:"getAllAsList",id:"getallaslist",level:3},{value:"Overloads",id:"overloads-1",level:4},{value:"getBulk",id:"getbulk",level:3},{value:"Overloads",id:"overloads-2",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"getRange",id:"getrange",level:3},{value:"Overloads",id:"overloads-3",level:4},{value:"Write operations",id:"write-operations",level:2},{value:"Default and generated values",id:"default-and-generated-values",level:3},{value:"Default values",id:"default-values",level:4},{value:"Generated properties",id:"generated-properties",level:4},{value:"Columns in indices or are not null explicitly",id:"columns-in-indices-or-are-not-null-explicitly",level:4},{value:"Insert",id:"insert",level:3},{value:"Overloads",id:"overloads-4",level:4},{value:"Modify",id:"modify",level:3},{value:"Overloads",id:"overloads-5",level:4},{value:"Upsert",id:"upsert",level:3},{value:"Overloads",id:"overloads-6",level:4},{value:"Delete",id:"delete",level:3},{value:"Overloads",id:"overloads-7",level:4},{value:"Update",id:"update",level:3},{value:"Transactions",id:"transactions",level:2},{value:"Read transactions",id:"read-transactions",level:3},{value:"Write transactions",id:"write-transactions",level:3},{value:"Subscribe operations",id:"subscribe-operations",level:2},{value:"Subscribe",id:"subscribe",level:3},{value:"Subscribe parameters",id:"subscribe-parameters",level:3},{value:"Overloads",id:"overloads-8",level:4},{value:"Bulk subscribe",id:"bulk-subscribe",level:3},{value:"Overloads",id:"overloads-9",level:4},{value:"Range subscribe",id:"range-subscribe",level:3},{value:"Overloads",id:"overloads-10",level:4},{value:"Static range",id:"static-range",level:4}],b={toc:m};function c(e){var t=e.components,a=(0,l.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},b,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/database/database-interface/database-interface/"},"Introduction"),"  | ",(0,i.kt)("a",{parentName:"p",href:"/database/database-interface/entity-db/"},"EntityDb")," |  ",(0,i.kt)("a",{parentName:"p",href:"/database/database-interface/generated-repositories/"},"Generated repositories")," | ",(0,i.kt)("a",{parentName:"p",href:"/database/database-interface/rxdb/"},"RxDb")),(0,i.kt)("p",null,"The entity db enables you to interact with the database layer; you can use any generated type-safe entities for\ntables and views. The interface supports the same operations as the generated repositories, but will accept any\nentity. It supports read operations for views and tables and write operations for tables only."),(0,i.kt)("p",null,"The entity db differs from the generated repositories in that it can handle any table and most view entities. It differs from ",(0,i.kt)("inlineCode",{parentName:"p"},"RxDb")," in that all operations are type-safe."),(0,i.kt)("p",null,"The entity db is available in the kotlin Event Handler. It can be injected in Kotlin using ",(0,i.kt)("inlineCode",{parentName:"p"},"AsyncEntityDb")," and in Java using ",(0,i.kt)("inlineCode",{parentName:"p"},"RxEntityDb"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"th",href:"/database/database-interface/entity-db/"},"EntityDb")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/fields-tables-views/tables/tables-basics/"},"Supports tables")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/fields-tables-views/views/views-basics/"},"Supports views")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Supports any data type"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Class to import"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"AsyncEntityDb")," ",(0,i.kt)("br",null)," ",(0,i.kt)("inlineCode",{parentName:"td"},"RxEntityDb"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Type-safe read and write"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Type-safe write result"),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Returns data as"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/data-types/table-entities/"},"table")," or ",(0,i.kt)("a",{parentName:"td",href:"/database/data-types/views-entities/"},"view")," entities")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Writes data as"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/data-types/table-entities/"},"table")," or ",(0,i.kt)("a",{parentName:"td",href:"/database/data-types/views-entities/"},"view")," entities")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"References indexes as"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/data-types/index-entities/"},"index entities"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Programming interface"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/types-of-api/async/"},"Async")," or ",(0,i.kt)("a",{parentName:"td",href:"/database/types-of-api/rxjava/"},"RxJava"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Write (input)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/helper-classes/modify-details/#entity-modify-details"},"Modify Details"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Write (output)"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/helper-classes/write-result/#entity-write-result"},"Write Result"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/helper-classes/subscription/record-update/"},"Record Update")," of entity")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bulk or Range Subscribe"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/database/helper-classes/subscription/bulk/"},"Bulk")," of entity")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Available in ",(0,i.kt)("a",{parentName:"td",href:"/database/api-reference/event-handler-api/"},"Custom Event Handlers")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Available in ",(0,i.kt)("a",{parentName:"td",href:"/server/request-server/advanced/#custom-request-servers"},"Custom Request Servers")),(0,i.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")))),(0,i.kt)("p",null,"When referring to indices in the database operations, the database accepts ",(0,i.kt)("em",{parentName:"p"},"index classes")," or ",(0,i.kt)("em",{parentName:"p"},"entity class"),"\nin combination with ",(0,i.kt)("em",{parentName:"p"},"index references"),". For comparison:"),(0,i.kt)("h2",{id:"type-convention"},"Type convention"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Meaning"),(0,i.kt)("th",{parentName:"tr",align:null},"Example"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"E")),(0,i.kt)("td",{parentName:"tr",align:null},"A table or view entity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"T")),(0,i.kt)("td",{parentName:"tr",align:null},"A table entity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"V")),(0,i.kt)("td",{parentName:"tr",align:null},"A view entity"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TradeView"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"EntityIndex<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"An index of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ById"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UniqueEntityIndex<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"A unique index of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ById"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"NonUniqueEntityIndex<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"A non unique index of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ByDate"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"EntityIndexReference<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"An index reference of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ById"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"UniqueEntityIndexReference<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"A unique index reference of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ById"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"NonUniqueEntityIndexReference<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"A non unique index reference of E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.ByDate"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"F<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"The full table /view name for E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"TRADE"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Class<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"The class reference for E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade.class"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"KClass<E>")),(0,i.kt)("td",{parentName:"tr",align:null},"The Kotlin class reference for E"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Trade::class"))))),(0,i.kt)("h2",{id:"read-operations"},"Read Operations"),(0,i.kt)("h3",{id:"get"},"get"),(0,i.kt)("p",null,"Get is a simple lookup on the database; it will return a single entity if a match is found, or no records if none is\nfound."),(0,i.kt)("p",null,"The following overloads exist for get; ",(0,i.kt)("inlineCode",{parentName:"p"},"fields")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set<String>"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(E, EntityIndexReference<E>, fields) : E?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(E, fields) : E?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(E, EntityIndexReference<E>) : E?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(UniqueEntityIndex<E>, fields) : E?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"get(UniqueEntityIndex<E>) : E?"))),(0,i.kt)("h4",{id:"syntax"},"Syntax"),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'// we can look up trades by passing in a unique index class:\nval trade = db.get(Trade.byId("TRADE_1"))\n\n// a trade object with the primary key set \nval trade = db.get(trade)\n\n// a trade object and a reference to unique index\nval trade = db.get(trade, Trade.ByTypeId)\n\n// or you can access the index class from the entity\nval trade = db.get(trade.byTypeId())\n'))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// we can look up trades by passing in a unique index class:\nfinal var trade = db.get(Trade.byId("TRADE_1"))\n        .blockingGet();\n\n// a trade object with the primary key set \nfinal var trade = db.get(trade)\n        .blockingGet();\n\n// a trade object and a reference to unique index\nfinal var trade = db.get(trade,Trade.ByTypeId.Companion)\n        .blockingGet();\n\n// or you can access the index class from the entity\nfinal var trade = db.get(trade.byTypeId())\n        .blockingGet();\n')))),(0,i.kt)("h3",{id:"getall"},"getAll"),(0,i.kt)("p",null,"Get all will take multiple ",(0,i.kt)("em",{parentName:"p"},"unique")," index class instances and return the type entity type for the record. It takes\na ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Pair<String, NonUniqueEntityIndex<E>>>"),", where the ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," is a unique reference to each request."),(0,i.kt)("h4",{id:"overloads"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAll(requestDetails: Flow<Pair<String, UI<E>>): Map<String, E?>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAll(requestDetails: List<Pair<String, UI<E>>): Map<String, E?>"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val map = db.getAll(listOf("A" to Trade.byId("TRADE_A"), "B" to Trade.byId("TRADE_B")))\n\nval recordA = map["A"]\nval recordB = map["B"]\n')),(0,i.kt)("h3",{id:"getallaslist"},"getAllAsList"),(0,i.kt)("p",null,"This operation is similar to the one above, but takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"List<NonUniqueEntityIndex<E>>"),", and will return a ",(0,i.kt)("inlineCode",{parentName:"p"},"List<E?>"),".\nThe results are returned in the order they were requested and will be ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," if no record was found. The result\nlist is guaranteed to be the same count as the input."),(0,i.kt)("h4",{id:"overloads-1"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAllAsList(Flow<UI<E>>): List<E?>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAllAsList(List<UI<E>>): List<E?>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getAllAsList(vararg UI<E>): List<E?>"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val list = db.getAllAsList(Trade.byId("TRADE_A"), Trade.byId("TRADE_B"))\n\nval recordA = list[0]\nval recordB = list[1]\n')),(0,i.kt)("h3",{id:"getbulk"},"getBulk"),(0,i.kt)("p",null,"This will create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Flowable")," of the whole table. If the database layer supports it, these will be\nsorted in ascending order by the index provided, or by the primary key if none is provided. "),(0,i.kt)("p",null,"Currently, only FoundationDb and Postgres support an ordered ",(0,i.kt)("inlineCode",{parentName:"p"},"getBulk"),". There is also the ",(0,i.kt)("inlineCode",{parentName:"p"},"getBulkFromEnd")," function, which will return records in descending order. "),(0,i.kt)("p",null,"There are also a number of continuation operations, which will return the whole table after the provided record. These methods are deprecated and should not be used going forwards."),(0,i.kt)("h4",{id:"overloads-2"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulk<E>(): Flow<E>")," (Kotlin only)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulk([Class<E> /  KClass<E>]): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulk(UR<E>): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulk(UR<E>, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulk(UR<E>, E, fields): Flow<E>")," (continuation) (Deprecated)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(UR<E>): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(UR<E>, E), E: Flow<E>")," (continuation) (Deprecated)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(UR<E>, E, fields), E: Flow<E>")," (continuation) (Deprecated)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(UR<E>, fields): Flow<E>"))),(0,i.kt)("h4",{id:"syntax-1"},"Syntax"),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// we can pass in Trade as a type parameter\nval flow = db.getBulk<Trade>()\n// we can pass in the TRADE object\nval flow = db.getBulk(TRADE)\n// or we can pass in an index reference\nval flow = db.getBulk(Trade.ByTypeId)\n"))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// we can pass in Trade as a type parameter\nfinal var flowable = db.getBulk(Trade.class);\n// we can pass in the TRADE object\nfinal var flowable = db.getBulk(TRADE.INSTACE);\n// or we can pass in an index reference\nfinal var flowable = db.getBulk(Trade.ById.Companion);\n")))),(0,i.kt)("h3",{id:"getrange"},"getRange"),(0,i.kt)("p",null,"Whereas a ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," operation selects a single entry from a unique index, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"getBulk")," operation selects the whole table, ",(0,i.kt)("inlineCode",{parentName:"p"},"getRange")," selects a range within an index. For example, to select all trades by a single currency, there are a number of ways a range can be specified:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A non-unique index entry."),(0,i.kt)("li",{parentName:"ul"},"A range between two index entries."),(0,i.kt)("li",{parentName:"ul"},"When an index has more than one column, part of the index starting from the first column.")),(0,i.kt)("p",null,"When selecting on part of an index, the number of columns can be specified using the ",(0,i.kt)("inlineCode",{parentName:"p"},"numKeyFields")," parameter. The fields are always selected in the order they are specified in the index."),(0,i.kt)("p",null,"There are 15 different get range functions. The records will be returned in ascending order, apart from when using the ",(0,i.kt)("inlineCode",{parentName:"p"},"fromEnd")," functions, in which case the records will be returned in descending order. "),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"numKeyFields")," property\nspecifies the number of fields to use from an index. For example, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"TRADE")," example, there is the ",(0,i.kt)("inlineCode",{parentName:"p"},"TRADE_BY_TYPE_ID"),"\nindex. If we pass 1 for ",(0,i.kt)("inlineCode",{parentName:"p"},"numKeyFields"),", the range will return records by ",(0,i.kt)("inlineCode",{parentName:"p"},"TRADE_TYPE"),", which is the first column in that index."),(0,i.kt)("h4",{id:"overloads-3"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(E, EntityIndexReference<E>, numKeyFields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(E, EntityIndexReference<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(E, E?, EntityIndexReference<E>, numKeyFields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(E, E?, EntityIndexReference<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(EntityIndex<E>, numKeyFields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(EntityIndex<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(NonUniqueEntityIndex<E>, NonUniqueEntityIndex<E>): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(NonUniqueEntityIndex<E>): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(NonUniqueEntityIndex<E>, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(EntityIndex<E>, EntityIndex<E>, numKeyFields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRange(EntityIndex<E>, EntityIndex<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRangeFromEnd(E, E, EntityIndexReference<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRangeFromEnd(E, E, EntityIndexReference<E>, numKeyFields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRangeFromEnd(EntityIndex<E>, EntityIndex<E>, numKeyFields, fields): Flow<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getRangeFromEnd(EntityIndex<E>, EntityIndex<E>, numKeyFields): Flow<E>"))),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'// there are multiple ways to get a range of records, either for some fields\n// of a unique index or some or all fields of a non unique index:\ndb.getRange(Trade.byTypeId("typeA"))\ndb.getRange(trade.byTypeId(), 1)\ndb.getRange(trade, Trade.ByTypeId, 1)\n\n// or by setting a start and an end range:\ndb.getRange(Trade.byTypeId("tradeType1"), Trade.byTypeId("tradeType2"))\ndb.getRange(trade1.byTypeId(), trade2.byTypeId(), 1).toList()\ndb.getRange(trade1, trade2, Trade.ByTypeId, 1).toList()\n'))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// there are multiple ways to get a range of records, either for some fields\n// of a unique index or some or all fields of a non unique index:\ndb.getRange(Trade.byTypeId("typeA"));\ndb.getRange(trade.byTypeId(),1);\ndb.getRange(trade,Trade.ByTypeId.Companion,1);\n\n// or by setting a start and an end range:\ndb.getRange(Trade.byTypeId("tradeType1"),Trade.byTypeId("tradeType2"));\ndb.getRange(trade1.byTypeId(),trade2.byTypeId(),1).toList();\ndb.getRange(trade1,trade2,Trade.ByTypeId.Companion,1).toList();\n')))),(0,i.kt)("h2",{id:"write-operations"},"Write operations"),(0,i.kt)("p",null,"All write operations have versions that take a single entity and versions that take multiple entries. "),(0,i.kt)("p",null,"The return values for these operations are type-safe (see details below), provided all entries are of the same type. For example, when inserting multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"Trade")," entries, the return type will be ",(0,i.kt)("inlineCode",{parentName:"p"},"List<InsertResult<Trade>>"),". Different entity types can be inserted in the same operation; however, the return type will be ",(0,i.kt)("inlineCode",{parentName:"p"},"List<InsertResult<Entity>>"),". Also, modify operations\nonly accept table entities."),(0,i.kt)("h3",{id:"default-and-generated-values"},"Default and generated values"),(0,i.kt)("p",null,"When writing a record to the database, typically all non-null properties should be set on the entity. An entity property\nbecomes non-nullable if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it has a default value"),(0,i.kt)("li",{parentName:"ul"},"it is generated by the database, i.e. sequence or auto increment fields"),(0,i.kt)("li",{parentName:"ul"},"the column is included in an index or is specifically declared not null in the schema")),(0,i.kt)("h4",{id:"default-values"},"Default values"),(0,i.kt)("p",null,"Properties with a default value will have the value set by default, unless set explicitly in the builder."),(0,i.kt)("h4",{id:"generated-properties"},"Generated properties"),(0,i.kt)("p",null,"Generated properties will be left in an indeterminate state if not set in the builder. When writing to the\ndatabase, this indeterminate state will be set in the return value. Trying to read the property while it is\nin this state will result in an ",(0,i.kt)("inlineCode",{parentName:"p"},"IllegalArugmentException"),". Each generated property will have two read-only\nassociated properties to access these properties in a safe manner. These are an ",(0,i.kt)("inlineCode",{parentName:"p"},"is[FieldName]Generated"),"\nboolean property and a ",(0,i.kt)("inlineCode",{parentName:"p"},"[fieldName]OrNull")," property."),(0,i.kt)("p",null,"For example:"),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// tradeId is generated\ntrade.tradeId                   // will cause an exception if not initialised\ntrade.tradeIdOrNull             // will return the tradeId if set, or else null\ntrade.isTradeIdInitialised      // will return true if set\n"))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// tradeId is generated\ntrade.getTradeId();             // will cause an exception if not initialised\ntrade.getTradeIdOrNull();       // will return the tradeId if set, or else null\ntrade.isTradeIdInitialised();   // will return true if set\n")))),(0,i.kt)("h4",{id:"columns-in-indices-or-are-not-null-explicitly"},"Columns in indices or are not null explicitly"),(0,i.kt)("p",null,"Columns in indices or declared not null should always be set in a builder, unless it has a default value or is a\ngenerated column. In all other instances, a ",(0,i.kt)("inlineCode",{parentName:"p"},"NullPointerException")," will be thrown when building the object."),(0,i.kt)("h3",{id:"insert"},"Insert"),(0,i.kt)("p",null,"This will insert a new record into the database. The ",(0,i.kt)("inlineCode",{parentName:"p"},"insert")," function takes a single table entity. The ",(0,i.kt)("inlineCode",{parentName:"p"},"insertAll"),"\nfunction takes multiple records, and has several overloads:"),(0,i.kt)("h4",{id:"overloads-4"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"insert(E): InsertResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"insertAll(vararg E): List<InsertResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"insertAll(List<E>): List<InsertResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"insertAll(Flow<E>): List<InsertResult<E>>"))),(0,i.kt)("h3",{id:"modify"},"Modify"),(0,i.kt)("p",null,"This will try to modify a record in the database. If the record does not exist, an error will be thrown."),(0,i.kt)("h4",{id:"overloads-5"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modify(EntityModifyDetails<E>): ModifyResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modify(E): ModifyResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modify(E, UniqueEntityIndexReference<E>): ModifyResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modifyAll(vararg E): List<ModifyResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modifyAll(vararg EntityModifyDetails<E>): List<ModifyResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modifyAll(List<EntityModifyDetails<E>>): List<ModifyResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"modifyAll(Flow<EntityModifyDetails<E>>): List<ModifyResult<E>>"))),(0,i.kt)("h3",{id:"upsert"},"Upsert"),(0,i.kt)("p",null,"This will try to modify a record in the database. If the record does not exist, the record will be inserted instead."),(0,i.kt)("h4",{id:"overloads-6"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsert(EntityModifyDetails<E>): UpsertResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsert(E): UpsertResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsertAll(vararg E): List<UpsertResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsertAll(vararg EntityModifyDetails<E>): List<UpsertResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsertAll(List<EntityModifyDetails<E>>): List<UpsertResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"upsertAll(Flow<EntityModifyDetails<E>>): List<UpsertResult<E>>"))),(0,i.kt)("h3",{id:"delete"},"Delete"),(0,i.kt)("p",null,"This will try to delete a record."),(0,i.kt)("h4",{id:"overloads-7"},"Overloads"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delete(E): DeleteResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delete(UniqueEntityIndex<E>): DeleteResult<E>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deleteAll(vararg E): List<DeleteResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deleteAll(vararg UniqueEntityIndex<E>): List<DeleteResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deleteAll(List<E>): List<DeleteResult<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deleteAll(Flow<E>): List<DeleteResult<E>>"))),(0,i.kt)("h3",{id:"update"},"Update"),(0,i.kt)("p",null,"The update operation is a condensed syntax for modifying data in the database. It works by providing a scope and a\ntransformation. The scope could be one of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateBy")," - a unique index"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateRangeBy")," - an index range"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateAll")," - a whole table")),(0,i.kt)("p",null,"The transformation is a lambda, where the rows that are in scope are provided one by one. The rows are provided as in\nthe database, and can be modified in place, with the changes applied to the database. All update calls will use the\n",(0,i.kt)("inlineCode",{parentName:"p"},"safeWriteTransaction")," and will be transactional if the database supports it."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the async entity db, the lambda will be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"E.() -> Unit"),". The entity will be the receiver and in the lambda,\n",(0,i.kt)("inlineCode",{parentName:"p"},"this")," will refer to the row, which should be modified in place.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the rx entity db, the lambda will be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Consumer<E>"),". The lambda will have a single parameter, the entity.\nSimilar to the async version, the row should be modified in place."))),(0,i.kt)("p",null,"In both cases, the full record will be provided, and values can be read as well as updated. The operations return\n",(0,i.kt)("inlineCode",{parentName:"p"},"List<ModifyResult<E>>")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"updateAll")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updateRangeBy")," methods and ",(0,i.kt)("inlineCode",{parentName:"p"},"ModifyResult<E>")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"updateBy")," operation."),(0,i.kt)("p",null,"For example:"),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'db.updateBy(Trade.byId("xxxxx")) {\n    price = 15.0\n}\n\ndb.updateByRange(Trade.byOrderId("xxxx")) {\n    orderStatus = OrderStatus.CANCELLED\n}\n\ndb.updateByRange(Trade.byOrderId("xxxx"), Trade.byOrderId("yyyy") {\n    orderStatus = OrderStatus.CANCELLED\n}\n\ndb.updateAll<Trade> {\n    orderStatus = OrderStatus.CANCELLED\n}\n'))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'db.updateBy(Trade.byId("xxx"), trade -> {\n    trade.setPrice(15.0);\n}).blockingGet();\n\ndb.updateByRange(Trade.byOrderId("xxxx"), trade -> {\n    trade.setTradeType(OrderStatus.CANCELLED);\n}).blockingGet();\n\ndb.updateByRange(Trade.byOrderId("xxxx"), Trade.byOrderId("yyyy"), trade -> {\n    trade.setTradeType(OrderStatus.CANCELLED);\n}).blockingGet();\n\ndb.updateAll(Trade.class, trade -> {\n    trade.setTradeType(OrderStatus.CANCELLED);\n}).blockingGet();\n')))),(0,i.kt)("h2",{id:"transactions"},"Transactions"),(0,i.kt)("p",null,"If the underlying database supports transactions, then the entity db provides type-safe access to these. A read transaction will support the same read operations as the entity db, and a write transaction will support the same read and write operations. If a write transaction fails, all operations will be reverted. Subscribe operations are not supported within transactions."),(0,i.kt)("p",null,"Currently, transactions are supported on ",(0,i.kt)("strong",{parentName:"p"},"FoundationDb")," and ",(0,i.kt)("strong",{parentName:"p"},"Postgresql"),". Using transaction on ",(0,i.kt)("strong",{parentName:"p"},"Aerospike")," will result in a failure."),(0,i.kt)("p",null,"When code is expected to run on multiple database types, transactions should be used when available. You can use ",(0,i.kt)("inlineCode",{parentName:"p"},"safeReadTransaction")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"safeWriteTransaction"),". These will run operations in the block in a single transaction, if supported."),(0,i.kt)("p",null,"There is a distinction between using Kotlin and Java here."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When using Kotlin, the transaction is the receiver in the ",(0,i.kt)("inlineCode",{parentName:"li"},"readTransaction")," call. This means that within the block, ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," refers to the transaction. "),(0,i.kt)("li",{parentName:"ul"},"When using Java, the transaction is the first parameter of the lambda.")),(0,i.kt)("h3",{id:"read-transactions"},"Read transactions"),(0,i.kt)("p",null,"Read transactions ensure all read operations are consistent. Intervening writes will not affect reads within the\ntransaction. The return value in the transaction will also be returned from the transaction. For the ",(0,i.kt)("inlineCode",{parentName:"p"},"RxEntityDb"),", it\nwill be a ",(0,i.kt)("inlineCode",{parentName:"p"},"Single<*>"),"."),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val orderTrade = db.readTransaction {\n    val trade = get(Trade.byId("TR_123"))\n    val order = get(Order.byId(trade.orderId))\n    buildOrderTrade(order, trade)\n}\n'))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Single<OrderTrade> oderTrade = db.readTransaction(transaction -> {\n    final var trade = transaction.get(Trade.byId("TR_123")).blockingGet();\n    final var order = transaction.get(Order.byId(trade.orderId)).blockingGet();\n    return buildOrderTrade(order, trade);\n});\n')))),(0,i.kt)("h3",{id:"write-transactions"},"Write transactions"),(0,i.kt)("p",null,"Write transactions ensure all read and write operations are consistent. If any exception reaches the\ntransaction level, all writes are rolled back. The ",(0,i.kt)("inlineCode",{parentName:"p"},"writeTransaction")," will return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pair<T, List<EntityWriteResult<*>>>"),",\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," is the value returned in the ",(0,i.kt)("inlineCode",{parentName:"p"},"writeTransaction")," lambda."),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val (orderId, writeResults) = db.writeTransaction {\n    insert(trade)\n    val orderInsert = insert(order)\n    orderInsert.record.orderId\n}\n"))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"final var pair = db.writeTransaction(transaction -> {\n    insert(trade).blockingGet();\n    final var orderInsert = insert(order).blockingGet();\n    return orderInsert.getRecord.getOrderId();\n}).blockingGet();\nfinal var orderId = pair.getFirst();\nfinal var writeResults = pair.getSecond();\n")))),(0,i.kt)("h2",{id:"subscribe-operations"},"Subscribe operations"),(0,i.kt)("h3",{id:"subscribe"},"Subscribe"),(0,i.kt)("p",null,"Subscribe starts a database listener that receives updates to tables or views. When subscribing to view updates,\nonly updates to the root table will be published. "),(0,i.kt)("p",null,"If the view has any inner joins, these are handled in a range of different ways."),(0,i.kt)("p",null,"For tables, this works in the standard way. You subscribe to updates, and:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"when a record is inserted, you get an insert update"),(0,i.kt)("li",{parentName:"ul"},"when a record is modified you get a modify update "),(0,i.kt)("li",{parentName:"ul"},"when a record is deleted you get a delete update ")),(0,i.kt)("p",null,"For views, when a record is inserted to the root table, you get an insert update. Modify and delete work the same way. "),(0,i.kt)("p",null,"However, if there is an inner join, there is a range of outcomes."),(0,i.kt)("p",null,"For example, if you join onto counterparty, and you only return records for which you have a valid counterparty:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if there is an insert with no valid counterparty, the listener to view will not receive the insert"),(0,i.kt)("li",{parentName:"ul"},"if there is a delete with no valid counterparty, the listener to view will not receive the delete")),(0,i.kt)("p",null,"And if there is a modify:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if both the previous record and the new record link to an existing counterparty, nothing changes"),(0,i.kt)("li",{parentName:"ul"},"if the previous record was linked to an invalid counterparty and the new record links to a valid counterparty, it will transform the modify to an insert \u2013 because the record has moved into the view"),(0,i.kt)("li",{parentName:"ul"},"if the previous record linked to a valid counterparty, but no longer does after the update, it becomes a delete")),(0,i.kt)("h3",{id:"subscribe-parameters"},"Subscribe parameters"),(0,i.kt)("p",null,"Subscribe supports the following parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delay"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Int")," the listener will batch updates every x milliseconds"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fields"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Set<String>")," filters ",(0,i.kt)("inlineCode",{parentName:"li"},"ModifyResult")," on fields"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribeLocally"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Boolean")," only publish updates that are local to the node")),(0,i.kt)("h4",{id:"overloads-8"},"Overloads"),(0,i.kt)("p",null,"The rx entity db takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<E>"),", whereas the async entity db takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"KClass<E>"),".\nParameters marked with an asterisk(*) are optional."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribe([KClass<E> / Class<E>], delay*, fields*, subscribeLocally*): Flow<E>"))),(0,i.kt)("p",null,"These functions are available in kotlin only:"),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribe<E>(delay*, fields*, subscribeLocally*): Flow<E>"))),(0,i.kt)(r.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val subscription = launch {\n    db.subscribe<Trade>()\n        .collect { update ->\n            println("Received a trade update! $update")\n        }\n}\n'))),(0,i.kt)(d.Z,{value:"java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'final var subscription = db.subscribe(Trade.class)\n        .subscribe(update -> {\n            System.out.println("Received a trade update! " + update);\n        });\n')))),(0,i.kt)("h3",{id:"bulk-subscribe"},"Bulk subscribe"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"bulkSubscribe")," combines a ",(0,i.kt)("inlineCode",{parentName:"p"},"getBulk")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," call into a single function. This operation is useful when\na class needs to read a full table and then receive updates of changes to the underlying table or view. "),(0,i.kt)("p",null,"This operation supports backward joins for views. This means that it can receive updates to the\nroot table and the joined tables. The view needs to support this in the definition, and it must be enabled\non the ",(0,i.kt)("inlineCode",{parentName:"p"},"bulkSubscribe")," call."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"bulkSubscribe")," supports the following parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delay"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Int")," the listener will batch updates every x milliseconds"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fields"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Set<String>")," filters ",(0,i.kt)("inlineCode",{parentName:"li"},"ModifyResult")," on fields"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"index"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"UniqueEntityIndex<E>")," the index to use for the ",(0,i.kt)("inlineCode",{parentName:"li"},"getBulk")," part of the call"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribeLocally"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Boolean")," only publish updates local to the node"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"backwardJoins"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Boolean")," enable backward joins in views")),(0,i.kt)("h4",{id:"overloads-9"},"Overloads"),(0,i.kt)("p",null,"Parameters marked with an asterisk(*) are optional."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"bulkSubscribe([Class<E> / KClass<E>], fields*, delay*, index*, subscribeLocally*, backwardJoins*) : Flow<Bulk<E>>"))),(0,i.kt)("p",null,"These functions are available in Kotlin only:"),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"bulkSubscribe<E>(fields*, delay*, index*, subscribeLocally*, backwardJoins*) : Flow<Bulk<E>>"))),(0,i.kt)("h3",{id:"range-subscribe"},"Range subscribe"),(0,i.kt)("p",null,"Range subscribe is like bulk subscribe, but it combines a ",(0,i.kt)("inlineCode",{parentName:"p"},"getRange")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe"),". This operation is useful when\na class needs to read part of a table or view and then keep updated of any changes. The range will be applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe")," as well. As such, the update type will reflect whether a row comes into the range or moves out of the range, rather\nthan what happened in the database. This means that a ",(0,i.kt)("inlineCode",{parentName:"p"},"ModifyResult<E>")," might be converted to an ",(0,i.kt)("inlineCode",{parentName:"p"},"InsertResult<E>")," or a\n",(0,i.kt)("inlineCode",{parentName:"p"},"DeleteResult<E>"),"."),(0,i.kt)("p",null,"Furthermore, ",(0,i.kt)("inlineCode",{parentName:"p"},"rangeSubscribe")," can take a static range (for example, all USD trades) or a dynamic range (for example, all trades booked within the last 2 hours). The dynamic range will be updated on a schedule, either at an interval or at a time."),(0,i.kt)("h4",{id:"overloads-10"},"Overloads"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rangeSubscribe")," supports the following parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"delay"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Int")," the listener will batch updates every x milliseconds"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"numKeyFields"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Int")," the number of key fields to take into account for the range"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fields"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Set<String>")," filters ",(0,i.kt)("inlineCode",{parentName:"li"},"ModifyResult")," on fields"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"index"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"UniqueEntityIndex<E>")," the index to use for the ",(0,i.kt)("inlineCode",{parentName:"li"},"getBulk")," part of the call"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"subscribeLocally"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Boolean")," only publish updates local to the node"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"backwardJoins"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Boolean")," enable backward joins in views"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateFrequency"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"PalDuration")," a schedule for updating dynamic ranges"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rangeProvider"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"() -> EntityIndex<E>")," a lambda providing a ",(0,i.kt)("inlineCode",{parentName:"li"},"EntityIndex<E>"),", for use in dynamic ranges")),(0,i.kt)("h4",{id:"static-range"},"Static range"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rangeSubscribe(from: EntityIndex<E>, to: EntityIndex<E>, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rangeSubscribe(EntityIndex<E>, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rangeSubscribe(rangeProvider, rangeProvider, updateFrequency, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rangeSubscribe(rangeProvider, updateFrequency, numKeyFields*, delay*, fields*, subscribeLocally*, backwardJoins*): Flow<Bulk<E>>"))))}c.isMDXComponent=!0}}]);