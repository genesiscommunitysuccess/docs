"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[66819],{85162:function(e,t,a){a.d(t,{Z:function(){return i}});var n=a(67294),l=a(86010),r="tabItem_Ymn6";function i(e){var t=e.children,a=e.hidden,i=e.className;return n.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:a},t)}},65488:function(e,t,a){a.d(t,{Z:function(){return b}});var n=a(87462),l=a(67294),r=a(86010),i=a(72389),o=a(67392),d=a(7094),s=a(12466),u="tabList__CuJ",p="tabItem_LNqP";function c(e){var t,a,i=e.lazy,c=e.block,b=e.defaultValue,m=e.values,k=e.groupId,g=e.className,h=l.Children.map(e.children,(function(e){if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=m?m:h.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),R=(0,o.l)(f,(function(e,t){return e.value===t.value}));if(R.length>0)throw new Error('Docusaurus error: Duplicate values "'+R.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var D=null===b?b:null!=(t=null!=b?b:null==(a=h.find((function(e){return e.props.default})))?void 0:a.props.value)?t:h[0].props.value;if(null!==D&&!f.some((function(e){return e.value===D})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+D+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,d.U)(),N=v.tabGroupChoices,y=v.setTabGroupChoices,S=(0,l.useState)(D),T=S[0],w=S[1],x=[],I=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=k){var C=N[k];null!=C&&C!==T&&f.some((function(e){return e.value===C}))&&w(C)}var E=function(e){var t=e.currentTarget,a=x.indexOf(t),n=f[a].value;n!==T&&(I(t),w(n),null!=k&&y(k,String(n)))},A=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n,l=x.indexOf(e.currentTarget)+1;a=null!=(n=x[l])?n:x[0];break;case"ArrowLeft":var r,i=x.indexOf(e.currentTarget)-1;a=null!=(r=x[i])?r:x[x.length-1]}null==(t=a)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",u)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":c},g)},f.map((function(e){var t=e.value,a=e.label,i=e.attributes;return l.createElement("li",(0,n.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:function(e){return x.push(e)},onKeyDown:A,onFocus:E,onClick:E},i,{className:(0,r.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":T===t})}),null!=a?a:t)}))),i?(0,l.cloneElement)(h.filter((function(e){return e.props.value===T}))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map((function(e,t){return(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==T})}))))}function b(e){var t=(0,i.Z)();return l.createElement(c,(0,n.Z)({key:String(t)},e))}},98014:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return u},default:function(){return k},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return b}});var n=a(87462),l=a(63366),r=(a(67294),a(3905)),i=(a(61839),a(65488)),o=a(85162),d=["components"],s={title:"Database interface - RxDb",sidebar_label:"RxDb",id:"rxdb",keywords:["database","database interface","rxdb"],tags:["database","database interface","rxdb"]},u=void 0,p={unversionedId:"database/database-interface/rxdb",id:"version-2022.3/database/database-interface/rxdb",title:"Database interface - RxDb",description:"Introduction  | EntityDb |  Generated repositories | RxDb",source:"@site/versioned_docs/version-2022.3/02_database/05_database-interface/03_rxdb.md",sourceDirName:"02_database/05_database-interface",slug:"/database/database-interface/rxdb",permalink:"/database/database-interface/rxdb",draft:!1,tags:[{label:"database",permalink:"/tags/database"},{label:"database interface",permalink:"/tags/database-interface"},{label:"rxdb",permalink:"/tags/rxdb"}],version:"2022.3",sidebarPosition:3,frontMatter:{title:"Database interface - RxDb",sidebar_label:"RxDb",id:"rxdb",keywords:["database","database interface","rxdb"],tags:["database","database interface","rxdb"]},sidebar:"databaseSidebar",previous:{title:"Generated repositories",permalink:"/database/database-interface/generated-repositories"},next:{title:"Helper classes",permalink:"/database/helper-classes/helper-classes"}},c={},b=[{value:"Read operations",id:"read-operations",level:2},{value:"get",id:"get",level:3},{value:"Syntax",id:"syntax",level:4},{value:"getAll",id:"getall",level:3},{value:"Overloads",id:"overloads",level:4},{value:"getAllAsList",id:"getallaslist",level:3},{value:"Overloads",id:"overloads-1",level:4},{value:"getBulk",id:"getbulk",level:3},{value:"Overloads",id:"overloads-2",level:4},{value:"Syntax",id:"syntax-1",level:4},{value:"getBulkFromEnd",id:"getbulkfromend",level:3},{value:"Overloads",id:"overloads-3",level:4},{value:"Syntax",id:"syntax-2",level:4},{value:"getRange",id:"getrange",level:3},{value:"Overloads",id:"overloads-4",level:4},{value:"getRangeFromEnd",id:"getrangefromend",level:3},{value:"Overloads",id:"overloads-5",level:4},{value:"Write Operations",id:"write-operations",level:2},{value:"Insert",id:"insert",level:3},{value:"Default values",id:"default-values",level:4},{value:"Modify",id:"modify",level:3},{value:"Overloads",id:"overloads-6",level:4},{value:"Upsert",id:"upsert",level:3},{value:"Overloads",id:"overloads-7",level:4},{value:"Delete",id:"delete",level:3},{value:"Overloads",id:"overloads-8",level:4},{value:"Recover",id:"recover",level:3},{value:"Overloads",id:"overloads-9",level:4},{value:"Transactional Operations",id:"transactional-operations",level:2},{value:"Read transactions",id:"read-transactions",level:3},{value:"Write transactions",id:"write-transactions",level:3},{value:"Subscribe Operations",id:"subscribe-operations",level:2},{value:"Bulk subscribe",id:"bulk-subscribe",level:3},{value:"Overloads",id:"overloads-10",level:4},{value:"Range subscribe",id:"range-subscribe",level:3},{value:"Overloads",id:"overloads-11",level:4}],m={toc:b};function k(e){var t=e.components,a=(0,l.Z)(e,d);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/database-interface/"},"Introduction"),"  | ",(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/entity-db/"},"EntityDb")," |  ",(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/generated-repositories/"},"Generated repositories")," | ",(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/rxdb/"},"RxDb")," "),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"RxDb")," instead of ",(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/entity-db/"},"entityDb")," or ",(0,r.kt)("a",{parentName:"p",href:"/database/database-interface/generated-repositories/"},"generated repositories")," will circumvent compile-time validation of database interactions. This means that errors might not appear until runtime or might lead to unexpected results.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RxDb")," enables you to interact with the database layer, but you do not have any level of type-safety when doing so, as it uses ",(0,r.kt)("a",{parentName:"p",href:"/database/data-types/dbrecord/"},"DbRecord"),". "),(0,r.kt)("p",null,"The interface supports the same operations as the generated repositories, but will accept any entity represented as ",(0,r.kt)("inlineCode",{parentName:"p"},"DbRecord"),". It supports read and write operations for tables only."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"RxDb")," can be injected in Kotlin and Java using ",(0,r.kt)("inlineCode",{parentName:"p"},"RxDb"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"th",href:"/database/database-interface/rxdb/"},"RxDb")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/fields-tables-views/tables/tables-basics/"},"Supports tables")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/fields-tables-views/views/views-basics/"},"Supports views")),(0,r.kt)("td",{parentName:"tr",align:null},"\u274c\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Supports any data type"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Class to import"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RxDb"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type-safe read and write"),(0,r.kt)("td",{parentName:"tr",align:null},"\u274c\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Type-safe write result"),(0,r.kt)("td",{parentName:"tr",align:null},"\u274c\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Returns data as"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/types-of-api/rxjava/#rxjava-return-types"},"RxJava return type")," of ",(0,r.kt)("a",{parentName:"td",href:"/database/data-types/dbrecord/"},"DbRecord")," entities")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Writes data as"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/data-types/dbrecord/"},"DbRecord")," entities")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"References indexes as"),(0,r.kt)("td",{parentName:"tr",align:null},"Strings")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Programming interface"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/types-of-api/rxjava/"},"RxJava"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write (input)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/helper-classes/modify-details/#entity-modify-details"},"Modify Details"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Write (output)"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/helper-classes/write-result/#entity-write-result"},"Write Result"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Subscribe"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/helper-classes/subscription/record-update/"},"Record Update")," of entity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bulk or Range Subscribe"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/database/types-of-api/rxjava/#flowable"},"Flowable")," of ",(0,r.kt)("a",{parentName:"td",href:"/database/helper-classes/subscription/bulk/"},"Bulk")," of entity")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Available in ",(0,r.kt)("a",{parentName:"td",href:"/database/api-reference/event-handler-api/"},"Custom Event Handlers")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2714\ufe0f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Available in ",(0,r.kt)("a",{parentName:"td",href:"/server/request-server/advanced/#custom-request-servers"},"Custom Request Servers")),(0,r.kt)("td",{parentName:"tr",align:null},"\u274c\ufe0f")))),(0,r.kt)("h2",{id:"read-operations"},"Read operations"),(0,r.kt)("h3",{id:"get"},"get"),(0,r.kt)("p",null,"Get is a simple lookup on the database; it will return a single entity if a match is found, or no records if none is\nfound."),(0,r.kt)("p",null,"The following overloads exist for get; fields is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<String>"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get(DbRecord, U, fields) : Maybe<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get(DbRecord, U) : Maybe<DbRecord>"))),(0,r.kt)("h4",{id:"syntax"},"Syntax"),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'// we can look up trades by passing in just an index, this will load all the fields:\nval findRec = DbRecord("TRADE")\nfindRec.setString("ID", "00001")\nval trade = rxDb.get(findRec, "TRADE_BY_ID")\n\n// or we can provide which fields we are looking for, by passing in a set:\nval fields = setOf("ID", "CLIENT_ID")\nval trade =  rxDb.get(findRec, "TRADE_BY_ID", fields)\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// we can look up trades by passing in just an index, this will load all the fields:\nDbRecord findRec = new DbRecord("TRADE");\nfindRec.setString("ID", "00001");\nMaybe<DbRecord> trade = rxDb.get(findRec, "TRADE_BY_ID");\n\n// or we can provide which fields we are looking for, by passing in a set:\nSet<String> fields = Set.of("ID", "CLIENT_ID");\nMaybe<DbRecord> trade = rxDb.get(findRec, "TRADE_BY_ID", fields);\n')))),(0,r.kt)("h3",{id:"getall"},"getAll"),(0,r.kt)("p",null,"Get all will take multiple DbRecords and return a single containing a map of the ",(0,r.kt)("inlineCode",{parentName:"p"},"RecordMapSearchDetails.mapAlias")," to a record if found.\nIt takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<RecordMapSearchDetails>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Flowable<RecordMapSearchDetails>"),", where the ",(0,r.kt)("inlineCode",{parentName:"p"},"RecordMapSearchDetails")," is an entity created to contain:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The search ",(0,r.kt)("inlineCode",{parentName:"li"},"DbRecord")),(0,r.kt)("li",{parentName:"ul"},"The index name as a ",(0,r.kt)("inlineCode",{parentName:"li"},"String")),(0,r.kt)("li",{parentName:"ul"},"The alias for the search, to use to label the result for this query, as a ",(0,r.kt)("inlineCode",{parentName:"li"},"String")),(0,r.kt)("li",{parentName:"ul"},"The fields to be returned, as a ",(0,r.kt)("inlineCode",{parentName:"li"},"Set<String>")," entity. If null, every field is returned.")),(0,r.kt)("h4",{id:"overloads"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getAll(requestDetails: Flowable<RecordMapSearchDetails>): Single<Map<String, DbRecord?>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getAll(requestDetails: List<RecordMapSearchDetails>): Single<Map<String, DbRecord?>>"))),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val findKey = "TRADE_BY_ID"\n\nval record1 = DbRecord("TRADE")\nrecord1.setString("ID", "00001")\n\nval details1: RecordMapSearchDetails = RecordMapSearchDetails.newInstance(record1, findKey, "FirstTrade")\n\nval rec2 = DbRecord("TRADE")\nrec2.setString("ID", "Trade2")\n\nval details2: RecordMapSearchDetails = RecordMapSearchDetails.newInstance(rec2, findKey, "SecondTrade")\n\nval resultsMapFromList = rxDb.getAll(listOf(details1, details2))\nval resultsMapFromFlowable = rxDb.getAll(Flowable.just(details1, details2))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'String findKey = "TRADE_BY_ID";\n\nDbRecord record1 = new DbRecord("TRADE");\nrecord1.setString("ID", "00001");\n\nRecordMapSearchDetails details1 = RecordMapSearchDetails.newInstance(record1, findKey, "FirstTrade");\n\nDbRecord rec2 = new DbRecord("TRADE");\nrec2.setString("ID", "Trade2");\n\nRecordMapSearchDetails details2 = RecordMapSearchDetails.newInstance(rec2, findKey, "SecondTrade");\n\nSingle<Map<String, DbRecord>> resultsMapFromList = getRxDb().getAll(List.of(details1, details2));\nSingle<Map<String, DbRecord>> resultsMapFromFlowable = getRxDb().getAll(Flowable.just(details1, details2));\n')))),(0,r.kt)("h3",{id:"getallaslist"},"getAllAsList"),(0,r.kt)("p",null,"This operation is similar to the one above, but will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<DbRecord?>"),". The results are returned in the order they were requested and will be ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if no record was found.\nThe result list is guaranteed to be the same count as the input."),(0,r.kt)("h4",{id:"overloads-1"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getAllAsList(requestDetails: Flowable<RecordListSearchDetails>): Single<List<DbRecord?>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getAllAsList(requestDetails: List<RecordListSearchDetails>): Single<List<DbRecord?>>"))),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val findKey = "TRADE_BY_ID"\nval record1 = DbRecord("TRADE")\nrecord1.setString("ID", "00001")\n\nval details1 = RecordMapSearchDetails.newInstance(record1, findKey, "FirstTrade")\n\nval rec2 = DbRecord("TRADE")\nrec2.setString("ID", "00002")\n\nval details2 = RecordMapSearchDetails.newInstance(rec2, findKey, "SecondTrade")\n\n// Get by providing list\nval resultsMapFromList = rxDb.getAllAsList(listOf(details1, details2))\n\n// Get by providing flowable\nval resultsMapFromFlowable = rxDb.getAllAsList(Flowable.just(details1, details2))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'String findKey = "TRADE_BY_ID";\n\nDbRecord record1 = new DbRecord("TRADE");\n        record1.setString("ID", "00001");\n\nRecordMapSearchDetails details1 = RecordMapSearchDetails.newInstance(record1, findKey, "FirstTrade");\n\nDbRecord rec2 = new DbRecord("TRADE");\n        rec2.setString("ID", "00002");\n\nRecordMapSearchDetails details2 = RecordMapSearchDetails.newInstance(rec2, findKey, "SecondTrade");\n\n// Get by providing list\nSingle<Map<String, DbRecord>> resultsMapFromList = getRxDb().getAll(List.of(details1, details2));\n\n// Get by providing flowable\nSingle<Map<String, DbRecord>> resultsMapFromFlowable = getRxDb().getAll(Flowable.just(details1, details2));\n')))),(0,r.kt)("h3",{id:"getbulk"},"getBulk"),(0,r.kt)("p",null,"This will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Flowable")," of the whole table. If the database layer supports it, these will be sorted in ascending order by the index provided, or by the primary key if none is provided.\nThere is also the ",(0,r.kt)("inlineCode",{parentName:"p"},"getBulkFromEnd")," function, which will return records in descending order. There are also a number of continuation operations, which will return the whole table after the provided record."),(0,r.kt)("h4",{id:"overloads-2"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String, index: String? ): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String, fields: Set<String>): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String, index: String?, fields: Set<String>): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String, index: String?, record: DbRecord?): Flowable<DbRecord>")," (continuation) (Deprecated)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulk(table: String, index: String?, record: DbRecord?, fields: Set<String>): Flowable<DbRecord>")," (continuation) (Deprecated)")),(0,r.kt)("h4",{id:"syntax-1"},"Syntax"),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'// we can pass in the table name, to get it sorted by primary key\nval tradeByPrimaryKeyEveryField = rxDb.getBulk("TRADE")\n// or with an index name to get it sorted by that\nval tradeByIDEveryField = rxDb.getBulk("TRADE", "TRADE_BY_ID")\n// or with a set of fields to select\nval tradeByPrimaryKeyIDAndPrice = rxDb.getBulk("TRADE", setOf("ID", "PRICE"))\n// or both!\nval tradeByIDIDAndPrice = rxDb.getBulk("TRADE", "TRADE_BY_ID", setOf("ID", "PRICE"))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// we can pass in the table name, to get it sorted by primary key\nFlowable<DbRecord> tradeByPrimaryKeyEveryField = rxDb.getBulk("TRADE");\n// or with an index name to get it sorted by that\nFlowable<DbRecord> tradeByIDEveryField = rxDb.getBulk("TRADE", "TRADE_BY_ID");\n// or with a set of fields to select\nFLowable<DbRecord> tradeByPrimaryKeyIDAndPrice = rxDb.getBulk("TRADE", Set.of("ID", "PRICE"));\n// or both!\nFLowable<DbRecord> tradeByIDIDAndPrice = rxDb.getBulk("TRADE", "TRADE_BY_ID", Set.of("ID", "PRICE"));\n')))),(0,r.kt)("h3",{id:"getbulkfromend"},"getBulkFromEnd"),(0,r.kt)("p",null,"This will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Flowable")," of the whole table. If the database layer supports it, these will be sorted in descending order by the index provided, or by the primary key if none is provided.\nThere is also the ",(0,r.kt)("inlineCode",{parentName:"p"},"getBulk")," function, which will return records in ascending order. There are also a number of continuation operations, which will return the whole table after the provided record."),(0,r.kt)("h4",{id:"overloads-3"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(table: String index: String): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(table: String index: String, fields: Set<String>): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(table: String index: String, startRecord: DbRecord? = null): Flowable<DbRecord>")," (continuation) (Deprecated)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getBulkFromEnd(table: String index: String startRecord: DbRecord? = null, fields: Set<String>): Flowable<DbRecord>")," (continuation) (Deprecated)")),(0,r.kt)("h4",{id:"syntax-2"},"Syntax"),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'// we can pass in the table name and index name, to sort by that descending\nval tradeByIDEveryField = rxDb.getBulkFromEnd("TRADE", "TRADE_BY_ID")\n// or with a set of fields to select\nval tradeByIDAndPrice = rxDb.getBulkFromEnd("TRADE", "TRADE_BY_ID", setOf("ID", "PRICE"))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// we can pass in the table name and index name, to sort by that descending\nFlowable<DbRecord> tradeByIDEveryField = rxDb.getBulkFromEnd("TRADE", "TRADE_BY_ID");\n// or with a set of fields to select\nFLowable<DbRecord> tradeByIDIDAndPrice = rxDb.getBulkFromEnd("TRADE", "TRADE_BY_ID", Set.of("ID", "PRICE"));\n')))),(0,r.kt)("h3",{id:"getrange"},"getRange"),(0,r.kt)("p",null,"Whereas a ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," operation selects a single entry from a unique index, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"getBulk")," operation selects the whole table, ",(0,r.kt)("inlineCode",{parentName:"p"},"getRange")," selects a range within an index. "),(0,r.kt)("p",null,"By providing different parameters, you can refine what information you are returned:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startRecord")," is needed in all cases, and defines where the range should start from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endRecord")," is an optional end record for where the range should end."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index")," is also needed in all cases, it is the String name of the Index upon which the range spans."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"numKeyFields")," is the number of key fields to take into account for the range."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fields")," is a set of Strings, that are the names of the fields to be returned. If not provided, or an empty set is provided, all fields will be returned.")),(0,r.kt)("h4",{id:"overloads-4"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getRange(startRecord: DbRecord, index: String, numKeyFields: Int): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getRange(startRecord: DbRecord, index: String, numKeyFields: Int, fields: Set<String>): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getRange(startRecord: DbRecord, endRecord: DbRecord?, index: String numKeyFields: Int): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getRange(startRecord: DbRecord, endRecord: DbRecord?, index: String numKeyFields: Int, fields: Set<String>): Flowable<DbRecord>"))),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val startRec = DbRecord("TRADE")\nstartRec.setString("TRADE_ID", "1")\n\nval endRec = DbRecord("TRADE")\nendRec.setString("TRADE_ID", "20")\n\nrxDb.getRange(startRec, "TRADE_BY_ID", 1)\nrxDb.getRange(startRec, "TRADE_BY_ID", 1, setOf("TRADE_PRICE", "TRADE_STATUS"))\nrxDb.getRange(startRec, endRec, "TRADE_BY_ID", 10)\nrxDb.getRange(startRec, endRec, "TRADE_BY_ID", 10, setOf("TRADE_PRICE", "TRADE_STATUS"))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'DbRecord startRec = new DbRecord("TRADE");\nstartRec.setString("TRADE_ID", "1");\n\nDbRecord endRec = new DbRecord("TRADE");\nendRec.setString("TRADE_ID", "20");\n\ngetRxDb().getRange(startRec, "TRADE_BY_ID", 1);\ngetRxDb().getRange(startRec, "TRADE_BY_ID", 1, Set.of("TRADE_PRICE", "TRADE_STATUS"));\ngetRxDb().getRange(startRec, endRec, "TRADE_BY_ID", 10);\ngetRxDb().getRange(startRec, endRec, "TRADE_BY_ID", 10, Set.of("TRADE_PRICE", "TRADE_STATUS"));\n')))),(0,r.kt)("h3",{id:"getrangefromend"},"getRangeFromEnd"),(0,r.kt)("p",null,"Works similiary to the ",(0,r.kt)("inlineCode",{parentName:"p"},"getRange")," operation but returns the range in reverse order."),(0,r.kt)("p",null,"By providing different parameters, you can refine what information you are returned:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startRecord")," is needed in all cases, and defines where the range should start from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endRecord")," is the end record for where the range should end."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index")," is also needed in all cases, it is the String name of the Index upon which the range spans."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"numKeyFields")," is the number of key fields to take into account for the range."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fields")," is a set of Strings, that are the names of the fields to be returned. If not provided, or an empty set is provided, all fields will be returned.")),(0,r.kt)("h4",{id:"overloads-5"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun getRangeFromEnd(startRecord: DbRecord, endRecord: DbRecord, index: I, numKeyFields: Int, fields: Set<String>,): Flowable<DbRecord>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun getRangeFromEnd(startRecord: DbRecord, endRecord: DbRecord, index: I, numKeyFields: Int,): Flowable<DbRecord>"))),(0,r.kt)(i.Z,{defaultValue:"kotlin",values:[{label:"Kotlin",value:"kotlin"},{label:"Java",value:"java"}],mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val startRec = DbRecord("TRADE")\nstartRec.setString("TRADE_ID", "1")\n\nval endRec = DbRecord("TRADE")\nendRec.setString("TRADE_ID", "20")\n\nrxDb.getRangeFromEnd(startRec, endRec, "TRADE_BY_ID", 10)\nrxDb.getRangeFromEnd(startRec, endRec, "TRADE_BY_ID", 10, setOf("TRADE_PRICE", "TRADE_STATUS"))\n'))),(0,r.kt)(o.Z,{value:"java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'DbRecord startRec = new DbRecord("TRADE");\nstartRec.setString("TRADE_ID", "1");\n\nDbRecord endRec = new DbRecord("TRADE");\nendRec.setString("TRADE_ID", "20");\n\ngetRxDb().getRangeFromEnd(startRec, endRec,"TRADE_BY_ID", 1);\ngetRxDb().getRangeFromEnd(startRec, endRec,"TRADE_BY_ID", 1, Set.of("TRADE_PRICE", "TRADE_STATUS"));\n')))),(0,r.kt)("h2",{id:"write-operations"},"Write Operations"),(0,r.kt)("h3",{id:"insert"},"Insert"),(0,r.kt)("p",null,"Single/Multiple records can be inserted into database at a time and returns ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/write-result/"},"WriteResult")),(0,r.kt)("h4",{id:"default-values"},"Default values"),(0,r.kt)("p",null,"When writing a record to the database, typically all non-null properties should be set on the DbRecord. An entity property\nbecomes non-nullable if:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"it has a default value"),(0,r.kt)("li",{parentName:"ul"},"it is generated by the database, i.e. sequence or auto increment fields"),(0,r.kt)("li",{parentName:"ul"},"the column is included in an index or is specifically declared not null in the schema")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"insert")," : This will insert a new record into the database, accepts parameter in the form of DbRecord. Has the following signature: ",(0,r.kt)("inlineCode",{parentName:"p"},"fun insert(record: DbRecord): Single<WriteResult>")," "),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"insertAll"),":  The ",(0,r.kt)("inlineCode",{parentName:"p"},"insertAll")," function takes multiple records in the form of DbRecord, and has following overloads:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun insertAll(records: Flowable<DbRecord>): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun insertAll(records: List<DbRecord>): Single<WriteResult>"))),(0,r.kt)("p",null,"Please note that the ","[Single]"," return value of this method is cold. That is, the underlying operation will not be started unless the ","[Single]"," is subscribed to. This can be done either by using one of the ","[Single.subscribe]"," functions, running a blocking operation, or combining multiple Single objects into a Flowable and subscribing to that"),(0,r.kt)("h3",{id:"modify"},"Modify"),(0,r.kt)("p",null,"Modifies single/multiple record in the database, which accepts ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/modify-details/"},"ModifyDetails")," and returns ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/write-result/"},"WriteResult")),(0,r.kt)("h4",{id:"overloads-6"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun modify(details: ModifyDetails): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun modifyAll(details: Flowable<ModifyDetails>): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun modifyAll(details: List<ModifyDetails>): Single<WriteResult>"))),(0,r.kt)("p",null,"Please note that the ","[Single]"," return value of this method is cold. That is, the underlying operation will not be started unless the ","[Single]"," is subscribed to. This can be done either by using one of the ","[Single.subscribe]"," functions, running a blocking operation, or combining multiple Single objects into a Flowable and subscribing to that"),(0,r.kt)("h3",{id:"upsert"},"Upsert"),(0,r.kt)("p",null,"Inserts single/multiple ","[DbRecord]"," into the database if it does not exist, and modifies it otherwise. Which accepts ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/modify-details/"},"ModifyDetails")," and returns ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/write-result/"},"WriteResult")),(0,r.kt)("h4",{id:"overloads-7"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun upsert(details: ModifyDetails): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun upsertAll(details: Flowable<ModifyDetails>): Single<List<WriteResult>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun upsertAll(details: List<ModifyDetails>): Single<List<WriteResult>>"))),(0,r.kt)("p",null,"Please note that the ","[Single]"," return value of this method is cold. That is, the underlying operation will not be started unless the ","[Single]"," is subscribed to. This can be done either by using one of the ","[Single.subscribe]"," functions, running a blocking operation, or combining multiple Single objects into a Flowable and subscribing to that"),(0,r.kt)("h3",{id:"delete"},"Delete"),(0,r.kt)("p",null,"Deletes a record/records from the database and returns ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/write-result/"},"WriteResult")),(0,r.kt)("h4",{id:"overloads-8"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun delete(record: DbRecord): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun deleteAll(records: Flowable<DbRecord>): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun deleteAll(records: List<DbRecord>): Single<WriteResult>"))),(0,r.kt)("p",null,"Please note that the ","[Single]"," return value of this method is cold. That is, the underlying operation will not be started unless the ","[Single]"," is subscribed to. This can be done either by using one of the ","[Single.subscribe]"," functions, running a blocking operation, or combining multiple Single objects into a Flowable and subscribing to that"),(0,r.kt)("h3",{id:"recover"},"Recover"),(0,r.kt)("p",null,"Performs recover operations on provided record/records and returns ",(0,r.kt)("a",{parentName:"p",href:"/database/helper-classes/write-result/"},"WriteResult"),". This is a special operation meant to preserve the original timestamps"),(0,r.kt)("h4",{id:"overloads-9"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun recover(record: DbRecord): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun recoverAll(records: Flowable<DbRecord>): Single<WriteResult>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun recoverAll(records: List<DbRecord>): Single<WriteResult>"))),(0,r.kt)("p",null,"Please note that the ","[Single]"," return value of this method is cold. That is, the underlying operation will not be started unless the ","[Single]"," is subscribed to. This can be done either by using one of the ","[Single.subscribe]"," functions, running a blocking operation, or combining multiple Single objects into a Flowable and subscribing to that"),(0,r.kt)("h2",{id:"transactional-operations"},"Transactional Operations"),(0,r.kt)("h3",{id:"read-transactions"},"Read transactions"),(0,r.kt)("p",null,"Read transactions ensure all read operations are consistent. Intervening writes will not affect reads within the\ntransaction. The return value in the transaction will also be returned from the transaction. For the ",(0,r.kt)("inlineCode",{parentName:"p"},"RxDb"),", it\nwill be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Single<T>")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is the value returned in the ",(0,r.kt)("inlineCode",{parentName:"p"},"readTransaction")," lambda."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'    rxDb.readTransaction(readTxn -> {\n        DbRecord recordToGet = new DbRecord("TRADE");\n        recordToGet.setString("ID", "Trade1");\n\n        DbRecord record = readTxn.get(recordToGet, "TRADE_BY_ID").blockingGet();\n\n        return Single.just(record);\n    });\n')),(0,r.kt)("h3",{id:"write-transactions"},"Write transactions"),(0,r.kt)("p",null,"Write transactions ensure all read and write operations are consistent. If any exception reaches the\ntransaction level, all writes are rolled back. The ",(0,r.kt)("inlineCode",{parentName:"p"},"writeTransaction")," will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Single<Pair<String List<WriteResult>>>"),",\nwhere ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is the value returned in the ",(0,r.kt)("inlineCode",{parentName:"p"},"writeTransaction")," lambda."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'    rxDb.writeTransaction(writeTxn -> {\n        DbRecord rec = new DbRecord("TRADE");\n        rec.setString("ID", "Trade1");\n        rec.setInteger("QUANTITY", 5000);\n        rec.setBigDecimal("PRICE", new BigDecimal(32.44));\n        rec.setEnum("STATUS", "PENDING");\n        rec.setString("CLIENT_ID", "Client1");\n\n        return writeTxn.insert(rec);\n    });\n')),(0,r.kt)("h2",{id:"subscribe-operations"},"Subscribe Operations"),(0,r.kt)("p",null,"Subscribe starts a database listener that receives updates to tables"),(0,r.kt)("p",null,"For table, the way it works is you subscribe to updates, and:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"when a record is inserted, you get an insert update"),(0,r.kt)("li",{parentName:"ul"},"when a record is modified you get a modify update"),(0,r.kt)("li",{parentName:"ul"},"when a record is deleted you get a delete update")),(0,r.kt)("h3",{id:"bulk-subscribe"},"Bulk subscribe"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"bulkSubscribe")," combines a ",(0,r.kt)("inlineCode",{parentName:"p"},"getBulk")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe")," call into a single function. This operation is useful when a class needs to read a full table and then receive updates of changes to the underlying table."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"bulkSubscribe")," supports the following parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tableName"),": Name of the table whose updates need to be subscribed."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delay"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Int")," the listener will batch updates every x milliseconds."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fields"),": Is a list of Strings, on which an update queue listener is added and these fields are returned if provided. All fields will be returned if not provided or an empty list is provided."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"indexName"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," index name of table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subscribeLocally"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Boolean")," only publish updates local to the node.")),(0,r.kt)("h4",{id:"overloads-10"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun bulkSubscribe(tableName: String, fields: List<String> = emptyList(), delay: Int? = null, subscribeLocally: Boolean = false,): Flowable<Bulk<DbRecord>>"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun bulkSubscribe(tableName: String, indexName: String, fields: List<String> = emptyList(), delay: Int? = null, subscribeLocally: Boolean = false,): Flowable<Bulk<DbRecord>>"),".")),(0,r.kt)("h3",{id:"range-subscribe"},"Range subscribe"),(0,r.kt)("p",null,"Range subscribe is like bulk subscribe, but it combines a ",(0,r.kt)("inlineCode",{parentName:"p"},"getRange")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribe"),". This operation is useful when\na class needs to read part of a table or view and then keep updated of any changes."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rangeSubscribe")," supports the following parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"startRecord"),": Defines where the range should start from."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endRecord"),": This is an optional end record for where the range should end."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delay"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Int")," the listener will batch updates every x milliseconds."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"numKeyFields"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Int")," the number of key fields to take into account for the range."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fields"),": Is a set of Strings, on which an update queue listener is added and these fields are returned if provided. All fields will be returned if not provided, or an empty set is provided."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"indexName"),": It is the String name of the Index upon which the range spans."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"subscribeLocally"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Boolean")," only publish updates local to the node."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updateFrequency"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"PalDuration")," a schedule for updating dynamic ranges.")),(0,r.kt)("h4",{id:"overloads-11"},"Overloads"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun rangeSubscribe(startRecord: DbRecord, endRecord: DbRecord?, indexName: String, numKeyFields: Int, fields: Set<String> = emptySet(), delay: Int? = null, subscribeLocally: Boolean = false,): Flowable<Bulk<DbRecord>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun rangeSubscribe(startRecord: DbRecord, indexName: String, numKeyFields: Int, fields: Set<String> = emptySet(), delay: Int? = null, subscribeLocally: Boolean = false,): Flowable<Bulk<DbRecord>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun rangeSubscribe(startRecord: () -> DbRecord, endRecord: (() -> DbRecord)?, indexName: String, numKeyFields: Int, fields: Set<String> = emptySet(), delay: Int? = null, subscribeLocally: Boolean = false, updateFrequency: PalDuration = PalDuration.Never,): Flowable<Bulk<DbRecord>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fun rangeSubscribe(startRecord: () -> DbRecord, indexName: String, numKeyFields: Int, fields: Set<String> = emptySet(), delay: Int? = null, subscribeLocally: Boolean = false, updateFrequency: PalDuration = PalDuration.Never,): Flowable<Bulk<DbRecord>>"))))}k.isMDXComponent=!0}}]);