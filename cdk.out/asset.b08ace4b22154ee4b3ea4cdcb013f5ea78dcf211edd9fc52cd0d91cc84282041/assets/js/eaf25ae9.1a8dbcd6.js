"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[32236],{44433:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return o},default:function(){return c},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return d}});var a=n(87462),r=n(63366),s=(n(67294),n(3905)),l=(n(61839),["components"]),i={title:"Request Server - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","request server","advanced"],tags:["server","request server","advanced"]},o=void 0,u={unversionedId:"server/request-server/advanced",id:"server/request-server/advanced",title:"Request Server - Advanced",description:"Pre-processing a request",source:"@site/docs/03_server/03_request-server/03_advanced.md",sourceDirName:"03_server/03_request-server",slug:"/server/request-server/advanced",permalink:"/next/server/request-server/advanced",draft:!1,tags:[{label:"server",permalink:"/next/tags/server"},{label:"request server",permalink:"/next/tags/request-server"},{label:"advanced",permalink:"/next/tags/advanced"}],version:"current",sidebarPosition:3,frontMatter:{title:"Request Server - Advanced",sidebar_label:"Advanced",id:"advanced",keywords:["server","request server","advanced"],tags:["server","request server","advanced"]},sidebar:"serverModulesSidebar",previous:{title:"Basics",permalink:"/next/server/request-server/basics"},next:{title:"Examples",permalink:"/next/server/request-server/examples"}},p={},d=[{value:"Pre-processing a request",id:"pre-processing-a-request",level:2},{value:"Limit the number of rows returned",id:"limit-the-number-of-rows-returned",level:2},{value:"Timeout",id:"timeout",level:2},{value:"Ranges",id:"ranges",level:2},{value:"Permission",id:"permission",level:2},{value:"Dynamic permission:",id:"dynamic-permission",level:3},{value:"Permission codes",id:"permission-codes",level:3},{value:"Custom Request Servers",id:"custom-request-servers",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Client-side (runtime) options",id:"client-side-runtime-options",level:2}],m={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"pre-processing-a-request"},"Pre-processing a request"),(0,s.kt)("p",null,"Request Server scripts can optionally transform a request parameter\u2019s value using ",(0,s.kt)("inlineCode",{parentName:"p"},"withTransformation"),". This takes two inputs:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"the request parameter\u2019s value (which is nullable)"),(0,s.kt)("li",{parentName:"ul"},"the full request message")),(0,s.kt)("p",null,"In the example below, ",(0,s.kt)("inlineCode",{parentName:"p"},"withTransformation")," is used twice."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},'If the ALTERNATE_TYPE parameter value is null, then the Request Server will use "UNKNOWN" by default.'),(0,s.kt)("li",{parentName:"ul"},'If the ALTERNATE_TYPE parameter has the value "RIC", then the transformation block will use the value of INSTRUMENT_CODE from the request. Otherwise, it will assign it the value "NOT_RIC" before making the database lookup. ')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply("INSTRUMENT_DETAILS", INSTRUMENT_DETAILS) {\n\n        request {\n            ALTERNATE_TYPE withTransformation { type, _ ->\n                type?.toUpperCase() ?: "UNKNOWN"\n            }\n            INSTRUMENT_CODE withTransformation { type, set ->\n                val value = if (set.fields["ALTERNATE_TYPE"].toString().toUpperCase() == "RIC") {\n                    type\n                } else {\n                    "NOT_RIC"\n                }\n                value\n            } withAlias "ALTERNATE_CODE"\n        }\n\n        reply {\n            INSTRUMENT_CODE\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n        }\n    }\n}\n')),(0,s.kt)("h2",{id:"limit-the-number-of-rows-returned"},"Limit the number of rows returned"),(0,s.kt)("p",null,"You can limit the number of rows returned using the property ",(0,s.kt)("inlineCode",{parentName:"p"},"rowReturnLimit"),". In this example, we limit it to 2."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply(INSTRUMENT_DETAILS) {\n\n        rowReturnLimit = 2\n\n        request {\n            ALTERNATE_TYPE\n            INSTRUMENT_CODE withAlias "ALTERNATE_CODE"\n        }\n\n        reply {\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n        }\n    }\n}\n')),(0,s.kt)("h2",{id:"timeout"},"Timeout"),(0,s.kt)("p",null,"You can specify a timeout (in seconds) for a Request Server using the property ",(0,s.kt)("inlineCode",{parentName:"p"},"timeout"),". In this example, we set a timeout of 10 seconds."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply("QUICK_INSTRUMENT", INSTRUMENT_DETAILS) {\n\n        timeout = 10\n\n        request {\n            ALTERNATE_TYPE\n            INSTRUMENT_CODE withAlias "ALTERNATE_CODE"\n        }\n\n        reply {\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n        }\n    }\n}\n')),(0,s.kt)("h2",{id:"ranges"},"Ranges"),(0,s.kt)("p",null,"You can specify ranges from the client of the requestReply server by post-fixing the request parameter names with _FROM and _TO. The example below shows a client building a GenesisSet request based upon\nthe requestReplies defined from previous example. This example stipulates a price range between 1,000 and 10,000. Leaving out FROM will define a top-end range, leaving out TO will define a bottom-end range. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'\n    // client building request  \n    val request = genesisSet {\n    \n        "DETAILS" with genesisSet {\n            "LAST_TRADED_PRICE_FROM" to 1_000\n            "LAST_TRADED_PRICE_TO" to 10_000\n        }\n    }\n\n    reply(request)\n')),(0,s.kt)("p",null,"Note that ranges that are not based on indexes perform more slowly than those that are."),(0,s.kt)("h2",{id:"permission"},"Permission"),(0,s.kt)("p",null,"You can use a permissioning block to define both dynamic permissions (AUTH) and permission codes (based on RIGHT_SUMMARY rights) on Request Servers, which is similar to Event Handler and Data Server."),(0,s.kt)("h3",{id:"dynamic-permission"},"Dynamic permission:"),(0,s.kt)("p",null,"Similar to Data-Server, you can provide dynamic permissioning on Request Server by using table/view reference."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'    requestReply("MARKET_INSTRUMENTS", INSTRUMENT_DETAILS) {\n\n        permissioning {\n            auth("EXCHANGE") {\n                INSTRUMENT_DETAILS.EXCHANGE_ID // This cannot be done on Custom request-server see ex below\n            }\n        }\n\n        request {\n            ...\n        }\n\n        reply {\n            ...\n        }\n    }\n')),(0,s.kt)("p",null,"Permissioning is different when you use ",(0,s.kt)("a",{parentName:"p",href:"/server/request-server/advanced/#custom-request-servers"},"Custom Request Servers"),", which is similar to Event-Handler permissioning.\nAs you use any class/DAO as input and output classes - you cannot use field syntax under auth block ex: Use instrumentId instead of INSTRUMENT_DETAILS.INSTRUMENT_ID"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReply<AltInstrumentId.ByAlternateTypeAlternateCode, AltInstrumentId> {\n    permissioning {\n        auth("INSTRUMENT") {\n            field { instrumentId }\n        }\n    }\n\n    reply { byAlternateTypeAlternateCode ->\n        ...\n    }\n}\n')),(0,s.kt)("h3",{id:"permission-codes"},"Permission codes"),(0,s.kt)("p",null,"Similar to Event Handlers and Request Servers you can add permission code as specified below."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'    requestReply(INSTRUMENT_DETAILS) {\n\n        permissioning {\n            permissionCodes = listOf("LICENSE_TO_KILL", "LICENSE_TO_BILL")\n        }\n\n        request {\n            ...\n        }\n\n        reply {\n            ...\n        }\n    }\n')),(0,s.kt)("p",null,"You can find out more details in our section on ",(0,s.kt)("a",{parentName:"p",href:"/server/access-control/authorisation-overview/"},"authorisation"),"."),(0,s.kt)("h2",{id:"custom-request-servers"},"Custom Request Servers"),(0,s.kt)("p",null,"By defining your own Request Servers, you have maximum flexibility. You can specify any class for the input and output, similar to Event Handlers. For the request, optional fields should have a default value in the primary constructor. You cannot use native Kotlin classes. You should wrap these in custom input and output classes."),(0,s.kt)("p",null,"We recommend that you locate your classes within the messages module of your application. This is where we place all the custom message types for our application. You need to ensure that the ",(0,s.kt)("em",{parentName:"p"},"app-name"),(0,s.kt)("strong",{parentName:"p"},"-script-config")," module has a dependency on the messages module."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'    api(project(":{app-name}-messages"))\n')),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"requestReply")," code blocks can be as simple or complex as your requirements. They are useful, for example, if you want to request data from a number of different tables and views that are not related. By nesting and joining all the relevant data in your ",(0,s.kt)("inlineCode",{parentName:"p"},"requestReply")," statement, you create your own metadata for the Request Server, so it can then be used anywhere in the module."),(0,s.kt)("h3",{id:"syntax"},"Syntax"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'// the name is optional, if none is provided, then request will be based on the \n// output class, e.g. REQ_OUTPUT_CLASS\nrequestReply<[input class], [output class]> ("{optional name}") {\n  // permissioning is optional\n  permissioning {\n    // multiple auth blocks can be combined with the and operator and the or operator\n    auth("{map name}") {\n        // use a single field of output_class\n        field { fieldName }\n        // or use multiple fields of output_class\n        fields { listof(fieldNameA, fieldNameB) }\n        \n        // hide fields are supported\n        hideFields { userName ->\n            listOf("FIELD_NAME_A")\n        }\n        \n        // predicates are supported\n        where {\n        }\n    }\n  }\n  \n  // a reply tag is required; there are three types.\n  // the reply tag will have a single parameter, the request, which will be of type \n  // [input class]\n  // all three have these fields available:\n  // 1. db          - readonly entity database \n  // 2. userName    - the name of the user who made the request\n  // 3. LOG         - logger with name: global.genesis.requestreply.pal.{request name}\n  \n  // either:\n  reply { request -> \n  }\n  \n  // or: \n  replySingle { request -> \n  }\n  \n  // or:\n  replyList { request ->\n  }\n}\n')),(0,s.kt)("p",null,"In this example, we define two data classes; Hello and World. We use these to create a Hello World request:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class Hello(val name: String)\ndata class World(val message: String)\n\nrequestReply<Hello, World>("HELLO_WORLD") {\n    replySingle { hello: Hello ->\n        World("Hello ${hello.name}")\n    }\n}\n')),(0,s.kt)("p",null,"We can also check who made the request by accessing the ",(0,s.kt)("inlineCode",{parentName:"p"},"userName")," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReply<Hello, World>("HELLO_WORLD_CHECK") {\n    replySingle { hello: Hello ->\n        when (userName) {\n            hello.name -> World("Hello ${hello.name}")\n            else -> World("You\'re not ${hello.name}!")\n        }\n    }\n}\n')),(0,s.kt)("p",null,"In this next example, we are using the generated dao classes to get a single record from the ",(0,s.kt)("inlineCode",{parentName:"p"},"INSTRUMENT_DETAILS")," table using the ",(0,s.kt)("inlineCode",{parentName:"p"},"ByInstrumentId")," index. We use the ",(0,s.kt)("inlineCode",{parentName:"p"},"db")," property to access the entity db."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},"requestReply<InstrumentDetails.ByInstrumentId, InstrumentDetails> {\n    replySingle { byId->\n        db.get(byId)\n    }\n}\n")),(0,s.kt)("p",null,"Next is a more complex example.\nThe first block checks that the user is authorised to view the instrument."),(0,s.kt)("p",null,"The second block uses the ALT_INSTRUMENT_ID table. The index is used as the input, but we return either a ",(0,s.kt)("inlineCode",{parentName:"p"},"getBulk"),", a ",(0,s.kt)("inlineCode",{parentName:"p"},"getRange")," or a ",(0,s.kt)("inlineCode",{parentName:"p"},"get"),", depending on the input."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReply<AltInstrumentId.ByAlternateTypeAlternateCode, AltInstrumentId> {\n    permissioning {\n        auth("INSTRUMENT") {\n            field { instrumentId }\n        }\n    }\n    \n    reply { byAlternateTypeAlternateCode ->\n        when {\n            byAlternateTypeAlternateCode.alternateType == "*" ->\n                db.getBulk(ALT_INSTRUMENT_ID)\n            byAlternateTypeAlternateCode.alternateCode == "*" ->\n                db.getRange(byAlternateTypeAlternateCode, 1)\n            else -> db.get(byAlternateTypeAlternateCode).flow()\n        }\n    }\n}\n')),(0,s.kt)("p",null,"In the example below, we have defined a more complicated auth logic:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReply<AltInstrumentId.ByAlternateTypeAlternateCode, AltInstrumentId>("FANCY_INSTRUMENT") {\n    permissioning {\n        auth("INSTRUMENT") {\n            field { instrumentId }\n            where {\n                alternateType == "FOO"\n            }\n        } or auth("ALTERNATE_CODE") {\n            field { alternateCode }\n            where {\n                alternateType == "BAR"\n            }\n        }\n    }\n    reply { byAlternateTypeAlternateCode ->\n        db.getRange(byAlternateTypeAlternateCode, 1)\n    }\n}\n')),(0,s.kt)("p",null,"Helpers exist to assist interacting with the Kotlin Flow type, which is the return type within the reply block. These helpers are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"T.flow() - Converts to the Flow type"),(0,s.kt)("li",{parentName:"ul"},"T.distinct() - Returns a Flow of all distinct values"),(0,s.kt)("li",{parentName:"ul"},"T.distinctBy(selector: (T) -> K?) - Returns a Flow of all distinct values given a selector"),(0,s.kt)("li",{parentName:"ul"},"T.sorted() - Returns a Flow of all sorted values"),(0,s.kt)("li",{parentName:"ul"},"T.sortedBy(selector: (T) -> K?) - Returns a Flow of all sorted values given a selector")),(0,s.kt)("h2",{id:"client-side-runtime-options"},"Client-side (runtime) options"),(0,s.kt)("p",null,"When a client initiates a request to a Request Server with a request message, there are several options that can be specified. None of these options is mandatory; you don't have to specify any to send a request.\nThe features of the options are explained below."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Option"),(0,s.kt)("th",{parentName:"tr",align:null},"Default"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"MAX_ROWS"),(0,s.kt)("td",{parentName:"tr",align:null},"Equal to the rowReturnLimit configuration value defined for the target Request Server"),(0,s.kt)("td",{parentName:"tr",align:null},"Maximum number of rows to be returned as part of the reply message")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"CRITERIA_MATCH"),(0,s.kt)("td",{parentName:"tr",align:null}),(0,s.kt)("td",{parentName:"tr",align:null},"Clients can send a Groovy expression to filter specific rows on the reply message provided by the Request Server. For example: ",(0,s.kt)("inlineCode",{parentName:"td"},"Expr.dateIsBefore(TRADE_DATE,'20150518')")," or ",(0,s.kt)("inlineCode",{parentName:"td"},"QUANTITY > 10000"))))),(0,s.kt)("p",null,"You can find out more details about the CRITERIA_MATCH parameter ",(0,s.kt)("a",{parentName:"p",href:"/server/data-server/advanced/#criteria-matching"},"here"),"."))}c.isMDXComponent=!0}}]);