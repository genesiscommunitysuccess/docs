"use strict";(self.webpackChunk_genesislcap_docs=self.webpackChunk_genesislcap_docs||[]).push([[14729],{41974:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return o},default:function(){return m},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return p}});var i=n(87462),r=n(63366),a=(n(67294),n(3905)),l=(n(61839),["components"]),s={title:"Request Server - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","request server","introduction"],tags:["server","request server","introduction"]},o=void 0,u={unversionedId:"server/request-server/basics",id:"version-2022.3/server/request-server/basics",title:"Request Server - Basics",description:"Let's make things really simple.",source:"@site/versioned_docs/version-2022.3/03_server/03_request-server/02_basics.md",sourceDirName:"03_server/03_request-server",slug:"/server/request-server/basics",permalink:"/server/request-server/basics",draft:!1,tags:[{label:"server",permalink:"/tags/server"},{label:"request server",permalink:"/tags/request-server"},{label:"introduction",permalink:"/tags/introduction"}],version:"2022.3",sidebarPosition:2,frontMatter:{title:"Request Server - Basics",sidebar_label:"Basics",id:"basics",keywords:["server","request server","introduction"],tags:["server","request server","introduction"]},sidebar:"serverModulesSidebar",previous:{title:"Request Server",permalink:"/server/request-server/introduction"},next:{title:"Advanced",permalink:"/server/request-server/advanced"}},d={},p=[{value:"Basic definition",id:"basic-definition",level:3},{value:"Adding a name",id:"adding-a-name",level:3},{value:"Multiple Request Servers",id:"multiple-request-servers",level:3},{value:"Specifying fields on request and reply",id:"specifying-fields-on-request-and-reply",level:3},{value:"Specifying derived fields",id:"specifying-derived-fields",level:3},{value:"Using an index",id:"using-an-index",level:3},{value:"Where block",id:"where-block",level:3}],c={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's make things really simple."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A Request Server is a component that supplies static data to the front end of your application."),(0,a.kt)("li",{parentName:"ul"},"You define your application's Request Reply in a kotlin script file  ",(0,a.kt)("em",{parentName:"li"},"application-name"),(0,a.kt)("strong",{parentName:"li"},"-reqrep.kts"),". This file should be in the ",(0,a.kt)("em",{parentName:"li"},"application-name"),"-script-config module."),(0,a.kt)("li",{parentName:"ul"},"In this file, you define specific ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReply")," codeblocks, each of which is designed to supply different sets of data; this could be a table or view, or just a subset of the fields in a table or view."),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReply")," can include a number of other subtleties, such as ",(0,a.kt)("inlineCode",{parentName:"li"},"where")," clauses or ranges, so that you can create code that matches your precise requirements."),(0,a.kt)("li",{parentName:"ul"},"If you use AppGen to build from your dictionary, then a basic kts file will be built automatically for you, covering all the tables and views in your data model. You can edit this file to add sophistication to the component."),(0,a.kt)("li",{parentName:"ul"},"Otherwise, you can build your kts by defining each ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReply")," codeblock from scratch. ")),(0,a.kt)("h3",{id:"basic-definition"},"Basic definition"),(0,a.kt)("p",null,"Here is the definition of a simple Request Server file. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The whole content is wrapped in a single ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReplies")," statement. This applies no matter how many ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReply")," codeblocks you specify."),(0,a.kt)("li",{parentName:"ul"},"In the ",(0,a.kt)("inlineCode",{parentName:"li"},"requestReply")," codeblock, you must at least specify either a table or a view. In this example, we are using the table ",(0,a.kt)("inlineCode",{parentName:"li"},"INSTRUMENT_DETAILS"),". A request to this Request Server will return all the fields in that table.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"requestReplies {\n    requestReply(INSTRUMENT_DETAILS)\n}\n")),(0,a.kt)("h3",{id:"adding-a-name"},"Adding a name"),(0,a.kt)("p",null,'Every requestReply in your .kts must have a unique name. If you do not provide one, it will be allocated automatically. In the previous example, the requestReply will automatically be named as REQ_INSTRUMENT_DETAILS.\nIf you name it as "INSTRUMENT_INFO" then it will be registered as "REQ_INSTRUMENT_INFO"'),(0,a.kt)("h3",{id:"multiple-request-servers"},"Multiple Request Servers"),(0,a.kt)("p",null,"Almost certainly, your application will need to have more than one ",(0,a.kt)("inlineCode",{parentName:"p"},"requestReply"),". So, let us state the obvious and show you a file with two ",(0,a.kt)("inlineCode",{parentName:"p"},"requestReply")," codeblocks. Again, each is the simplest kind you could possibly have."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"requestReplies {\n    requestReply(COUNTERPARTY)\n\n    requestReply(INSTRUMENT_DETAILS)\n}\n")),(0,a.kt)("h3",{id:"specifying-fields-on-request-and-reply"},"Specifying fields on request and reply"),(0,a.kt)("p",null,"With all those basic ",(0,a.kt)("inlineCode",{parentName:"p"},"requestReply")," codeblocks we have seen so far, all the fields in the table are returned."),(0,a.kt)("p",null,"We can add some precision using ",(0,a.kt)("inlineCode",{parentName:"p"},"request")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"reply")," blocks within a ",(0,a.kt)("inlineCode",{parentName:"p"},"requestReply")," statement."),(0,a.kt)("p",null,"When defining a ",(0,a.kt)("inlineCode",{parentName:"p"},"request")," block, you must define at least one primary key or index. In the example below, the fields ",(0,a.kt)("inlineCode",{parentName:"p"},"ALTERNATE_TYPE")," AND ",(0,a.kt)("inlineCode",{parentName:"p"},"INSTRUMENT_CODE")," together form the primary key."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply(INSTRUMENT_DETAILS) {\n        request {\n            ALTERNATE_TYPE\n            INSTRUMENT_CODE withAlias "ALTERNATE_CODE"\n        }\n\n        reply {\n            INSTRUMENT_CODE\n            INSTRUMENT_ID\n            INSTRUMENT_NAME\n            LAST_TRADED_PRICE\n            VWAP\n            SPREAD\n            TRADED_CURRENCY\n            EXCHANGE_ID\n        }\n    }\n}\n')),(0,a.kt)("p",null,"Note the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When you do not define a ",(0,a.kt)("inlineCode",{parentName:"li"},"request")," block, the primary key for the table or view is used as the default request field."),(0,a.kt)("li",{parentName:"ul"},"When you do not define a ",(0,a.kt)("inlineCode",{parentName:"li"},"reply block"),", all the fields will be returned.")),(0,a.kt)("h3",{id:"specifying-derived-fields"},"Specifying derived fields"),(0,a.kt)("p",null,"You can define derived fields to be included on the reply, where the input for the derived field is the reply entity. "),(0,a.kt)("p",null,"Derived fields cannot be used within a ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," block."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply(INSTRUMENT_DETAILS) {\n        derivedFields {\n            derivedField("IS_USD", BOOLEAN) {\n                tradedCurrency == "USD"\n            }\n        }\n    }\n}\n')),(0,a.kt)("h3",{id:"using-an-index"},"Using an index"),(0,a.kt)("p",null,"The example below uses an index as the request definition. This provides additional indexing at the request level."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"requestReplies {\n    requestReply(INSTRUMENT_DETAILS) {\n        request(INSTRUMENT_DETAILS.BY_INSTRUMENT_ID)\n    }\n}\n")),(0,a.kt)("h3",{id:"where-block"},"Where block"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," block enables you to specify the conditions for which data should be returned. The ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," block can take two optional parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"row - this represents a row from the table or view"),(0,a.kt)("li",{parentName:"ul"},"parameters - this a GenesisSet that holds the parameters that are passed on the request; the parameters can be accessed by using the GenesisSet getters to access named parameters")),(0,a.kt)("p",null,"In this contrived example below, the ",(0,a.kt)("inlineCode",{parentName:"p"},"where"),' block filters rows whose instrumentCode is not equal to "ALLL3" and the request parameter "ALTERNATE_TYPE" is either "RIC" or "BLOOMBERG".\nThe row parameter represents the rows returned from the table or view defined at the top of the ',(0,a.kt)("inlineCode",{parentName:"p"},"requestReply")," definition, in this case INSTRUMENT_DETAILS."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'requestReplies {\n    requestReply("INSTRUMENT_DETAILS", INSTRUMENT_DETAILS) {\n\n        request {\n            ALTERNATE_TYPE\n        }\n\n        where { row, parameters ->\n            "ALLL3" == row.instrumentCode &&                         \n             parameters.getString("ALTERNATE_TYPE") in listOf("RIC", "BLOOMBERG") \n        }\n    }\n}\n')),(0,a.kt)("p",null,"Note - You cannot use derived fields within a ",(0,a.kt)("inlineCode",{parentName:"p"},"where")," block."))}m.isMDXComponent=!0}}]);