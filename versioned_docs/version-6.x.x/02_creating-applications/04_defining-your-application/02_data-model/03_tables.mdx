---
title: Tables
sidebar_label: Tables
id: tables
sidebar_position: 3
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Tables are used to store the underlying data. They are made up of [fields](/creating-applications/defining-your-application/data-model/fields/) and must also at least define a `primaryKey` which tells the underlying database how to index the table's data

Here is a simple example definition of your tables. It contains just one table with three fields in it.
```kotlin
tables {

  table( name= "POSITION", id = 11002) {
    sequence(POSITION_ID, "PS")
    INSTRUMENT_ID
    QUANTITY
    NOTIONAL

    primaryKey {
     POSITION_ID
    }
  }

}
```

<Tabs defaultValue="whereToDefine" 
        values={[{ label: 'Where to define', value: 'whereToDefine', }, 
                 { label: 'Technical details', value: 'techDetails', }, 
                 { label: 'Advanced technical details', value: 'advTechDetails', },
                 { label: 'More examples', value: 'examples', }]}>
<TabItem value="whereToDefine">

Tables are defined in the file _application-name_**-tables-dictionary.kts**. 

So, if your application is called **position** application, the file name will be **position-tables-dictionary.kts**.

</TabItem>
<TabItem value="techDetails">

### Table name

When you define a table, you must start by giving it a name that is unique to the application: 


```kotlin
  table( name= "POSITION")
```

### Table ID

Tables must also be given an ID that is unique to the application. This ensures that you can rename a table without losing the data in it.
 
```kotlin
  table( name= "POSITION", id = 11002)
```

### Fields
After specifying a name and an ID, you specify the fields in the table. 

Each field's type and other attributes are inherited from the field definition.

If you are using intelliJ IDE, it will auto-suggest the available fields; any references that are not known will be shown in red.


```kotlin

  table( name= "POSITION", id = 11002) {
    sequence(POSITION_ID, "PS")
    INSTRUMENT_ID
    QUANTITY
    NOTIONAL

  }

```

### Primary key

A table must have a single primary key.

It is common to use a single sequenced/autoIncrement field in the table as a `primaryKey`.

The `primaryKey` needs to contain one or more fields in the table. Where using more than one field, the order of the fields matters in the case of wanting to search performantly based on a partial key.

The example below shows a `primaryKey` with a single field: `POSITION_ID`:

```kotlin
tables {

  table( name= "POSITION", id = 11002) {
    sequence(POSITION_ID, "PS")
    INSTRUMENT_ID
    QUANTITY
    NOTIONAL

    primaryKey {
     POSITION_ID
    }
  }

}
```

### Indices

You can define indices on a table in a similar fashion to `primaryKey`. The indices are used in the following scenarios:

- Creating additional unique constraints to the table's primary key
- Providing a performant record lookup (`unique` index)
- Providing an index for a performant ranged lookup (`nonUnique` index, else `unique` index but searching on part of the key)

As with keys, indices are made up of one or more fields from the table. Where the indices are made up of multiple fields, the order of the fields matters in the case of wanting to performantly search based on a partial index.

```kotlin
    indices {
        unique {
            SESSION_AUTH_TOKEN
        }
        nonUnique {
            USER_NAME
        }
    }
```

When you define an index, you cannot supply exactly the same fields in exactly the same order as the primary Key or another index on the same table.

#### Primary key and index names

It is not mandatory to give a primary key or index a name. If you don't provide a name, it will be inferred:

 `[TABLE_NAME]_BY_[FIELD_1](_[FIELD_N])`
 
 where FIELD_1 - FIELD_N are all the fields that make up the key/index in the order specified.

One exception is the common use case where the primary key is made up of a single field with a name of format `[TABLE_NAME]_[ID]`. In this case, the inferred name is `[TABLE_NAME]_BY_ID`.


Let's see some examples. Below, the table name is `POSITION`. The inferred names are shown in the comment before each primary key.


```kotlin
    
    //POSITION_BY_ID
    primaryKey { 
        POSITION_ID
    }

    //POSITION_BY_OTHER_FIELD
    primaryKey { 
        OTHER_FIELD
    }
    
    //POSITION_BY_POSITION_ID_OTHER_FIELD_ANOTHER_FIELD
    primaryKey { 
        OTHER_FIELD
        ANOTHER_FIELD
    }
```

In this example, we have specified the name of the primary key in the `name` parameter.

```kotlin
    primaryKey(name = "POSITION_PRIMARY_KEY" ) {
     POSITION_ID
    }
```

Indices work the same way; either you specify the name in the `name` parameter or the name will be automatically inferred.

</TabItem>
<TabItem value="advTechDetails">

### Subtables

A subtable provides a unique point of view on the data schema, which goes further than a simple join relationship. It gives extra functionality to a main table.

For example, a financial instrument can be modelled as an INSTRUMENT table, but this table on its own isn’t be enough to represent all the possible symbologies. So, we could add a subtable called ALT_INSTRUMENT_ID, in which the relationship is one-to-many from INSTRUMENT to ALT_INSTRUMENT_ID.

ALT_INSTRUMENT_ID is likely to inherit key fields from the INSTRUMENT table, and it simply acts as a lookup table for INSTRUMENT records.

This requirement occurs for different tables (e.g. COUNTERPARTY → ALT_COUNTERPARTY_ID, GENESIS_PROCESS → GENESIS_PROCESS_MONITOR, etc).

Subtables are defined within the body of the table definition. 

The example below shows the `GENESIS_PROCESS` monitoring table.

After the fields and the primary key have been defined, you can see the subtable `GENESIS_PROCESS_MONITOR`.

Within this subtable, the fields that are used to generate the join operation are defined first. These fields are inherited automatically. Then the additional fields and keys are defined.


```kotlin
table(name = "GENESIS_PROCESS", id = 12) {
    PROCESS_NAME
    PROCESS_STATUS
    PROCESS_STATUS_MESSAGE
    PROCESS_STATE_TEXT
    PROCESS_RESOURCES
    PROCESS_HOSTNAME
    PROCESS_CPU_USAGE
    PROCESS_MEM_USAGE
    PROCESS_SECURE
    PROCESS_PORT
    LOG_LEVEL
    DATADUMP
    START_TIME
    RESOURCE_TYPES
    primaryKey {
        PROCESS_NAME
        PROCESS_HOSTNAME
    }
    subTables {
        fields(PROCESS_HOSTNAME, PROCESS_NAME)
            .joiningNewTable(name = "GENESIS_PROCESS_MONITOR", id = 20) {
                MONITOR_NAME
                MONITOR_MESSAGE
                MONITOR_STATE

            primaryKey(name = "GENESIS_PROCESS_MONITOR_BY_HOSTNAME", id = 1) {
                    PROCESS_HOSTNAME
                    PROCESS_NAME
                    MONITOR_NAME
                }
            }
    }
}
```


</TabItem>
<TabItem value="examples">

```kotlin
tables {
  table (name = "TRADE", id = 11000, audit = details(id = 11001, sequence = "TR", tsKey = true)) {
    // Source: Trade
    sequence(TRADE_ID, "TR")
    INSTRUMENT_ID not null
    COUNTERPARTY_ID not null
    QUANTITY not null
    SIDE not null
    PRICE not null
    TRADE_DATETIME
    ENTERED_BY
    TRADE_STATUS

    primaryKey {
      TRADE_ID
    }

    indices {
      nonUnique {
        TRADE_DATETIME
      }
    }
  }

  table( name= "POSITION", id = 11002) {
    sequence(POSITION_ID, "PS")
    INSTRUMENT_ID
    QUANTITY
    NOTIONAL

    primaryKey {
     POSITION_ID
    }
  }

}
```

</TabItem>
</Tabs>
